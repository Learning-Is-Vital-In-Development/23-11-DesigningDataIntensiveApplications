### 지식, 진실, 그리고 거짓말


#### 진실은 다수결로 결정된다

분산 시스템은 종족수, 즉 노드들 사이의 투표에 의존한다.
정족수는 보통 과반수를 기준으로 한다.

#### 리더와 잠금

리더 노드가 죽었다고 선언되어 새로운 리더 노드를 선출했을 때, 기존 리더 노드가 살아난 뒤에도 권한을 행사하려한다면 문제를 유발할 수 있다.

> [예시] 저장 서비스에 있는 어떤 파일을 한 번에 클라이언트 하나씩만 접근하는 프로그램을 만들고, 클라이언트가 그 파일에 접근하기 전에 잠금 서비스로부터 임차권(lease)을 얻도록 해서 기능을 구현한 경우<br>
> ![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/4f99bce4-4e35-4dca-b3b0-8de6e8c8bc0c)
> <br>결과적으로 클라이언트들의 쓰기가 충돌되고 파일이 오염된다


#### 펜싱 토큰(fencing token)

위처럼 자신이 리더라고 잘못 믿고있는 노드가 시스템을 방해할 수 없도록 하는 단순한 기법으로 펜싱(fencing) 이 있다.

잠금 서버가 임차권(lease)을 승인할 때마다 펜싱 토큰(fencing token) 도 반환하도록 하자.<br>
스토리지는 자신이 처리한 쓰기작업의 토큰번호(34)를 기억해뒀다가 오래된 토큰(33)이 올 경우 쓰기를 거부한다.

>  클라이언트1은 토큰이 만료되어 쓰기가 거부된다.<br>
> ![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/07591289-7965-402e-9324-8359c67a12d3)

클라이언트에서 토큰을 검증할 수도 있지만 클라이언트는 믿을 수 없기 때문에 서버에서 토큰을 확인하는 것이 좋다.

#### 비잔틴 결함(Byzantine fault)

펜싱 토큰은 부주의에 의한 오류에 빠진 노드를 감지하고 차단할 수 있다. 하지만 고의로 가짜 토큰을 보내는 노드에는 취약하다.

노드가 받지 않은 메시지를 받았다고 하는 등의 "거짓말"을 하는 것을 **비잔틴 결함(Byzantine fault)**이라고 하며,<br>
이런 신뢰할 수 없는 환경에서 합의에 도달하는 문제를 **비잔틴 장군 문제(Byzantine Generals Problem)** 라고 한다.

비잔틴 내결함성을 가지는 프로토콜을 만드는 것은 매우 복잡하며 비용이 크다.


#### 약한 형태의 거짓말

신뢰할 수 있는 노드일지라도 하드웨어 문제, 소프트웨어 버그 등 약한 형태의 "거짓말"은 할 수 있다.<br>
따라서 이를 보호해주는 메커니즘을 소프트웨어에 추가해주는것도 좋다.

- 네트워크 패킷은 때때로 오염되는데, TCP와 UDP에 내장된 체크섬으로 검출되지만 검출을 피하는 경우도 있다. 보통 애플리케이션 수준 프로토콜에서 체크섬을 쓰는 방식으로 해결된다.
- 공개적으로 접근 가능한 애플리케이션은 사용자 입력을 신중하게 검사해야 한다.
- NTP 클라이언트는 여러 서버 주소를 설정해서 서버 한 대를 쓸 때보다 견고해질 수 있다.

### 시스템 모델과 현실

분산 시스템 문제를 해결하기 위해 많은 알고리즘이 설계되고 있다.
이러한 알고리즘이 특정 하드웨어/소프트웨어에 심하게 의존되지 않도록 결함의 종류를 시스템 모델로 정형화 한다.

- 타이밍 가정 모델: 동기식 모델, 부분 동기식 모델, 비동기식 모델
- 노드 장애 모델: crash-stop 결함 모델, crash-recovery 결함 모델, 비잔틴 결함 모델

#### 알고리즘의 정확성

알고리즘의 정확도 = 속성을 잘 만족하는가

- `유일성` : 펜싱 토큰 요청이 같은 값을 반환하지 않는다.
- `단조 일련 번호` : 요청 x가 토큰 t1을, 요청 y가 토큰 t2를 반환했고 y가 시작하기 전에 x가 완료됐다면 t1 < t2를 만족한다
- `가용성` : 펜싱 토큰을 요청하고 죽지 않은 노드는 결국 응답을 받는다

알고리즘이 아무리 정확해도 모든 노드가 죽거나 모든 네트워크 지연이 무한히 길어진다면 어떤 알고리즘이라도 동작할 수 없다.

#### 안정성과 활동성

- 안정성 : 비공식적으로 나쁜 일은 일어나지 않는다고 정의하는 속성
  - 예) 유일성, 단조 일련번호
  - 항상 만족되기를 요구
  - 모든 노드가 죽거나 네트워크 장애가 나더라도 알고리즘은 옳은 결과를 반환
- 활동성 : 결국에는(eventually) 이라는 단어를 포함하는 속성(좋은 일은 결국 일어난다고 정의)
  - 예) 가용성, 최종적 일관성(eventually consistency)
  - 경고를 하는 것이 허용
  - 노드의 다수가 죽지 않고 네트워크가 중단으로부터 결국 복구됐을 때만 요청이 응답을 받아야 한다..

#### 시스템 모델을 현실 세계에 대응시키기

알고리즘을 이론적으로 설명할 때는 그냥 어떤 일이 일어나지 않는다고 가정할 수 있다.
비잔틴 시스템에서는 일어날 수 있는 결함과 일어날 수 없는 결함에 대해 어떤 가정을 해야 하고, 쓸모없는 코드를 포함시킬 수도 있다.

이론적인 추상 시스템 모델이 쓸모없다고 말하는 것은 아니다.<br>
알고리즘의 증명은 아주 좋은 첫걸음며 이론적 분석은 실제 시스템에 오랫동안 숨어 있다가 흔치 않은 상황에서 발생하기 때문에 이론적 분석과 경험적 실험은 똑같이 중요하다.


### 정리

문제에 대해 비관적으로 생각해서 많은 부분을 고려해야 한다.

- 부분장애를 발생 시 동작을 고려하자
- 네트워크는 신뢰할 수 있는가
- 시계는 신뢰할 수 있는가
- 노드는 신뢰할 수 있는가 
