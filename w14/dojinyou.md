# 분산시스템의 골칫거리(지식, 진실, 그리고 거짓말)

# 지식, 진실 그리고 거짓말

네트워크에 있는 어떤 노드도 확실하게 알 수 있는 건 없다. 네트워크를 통해 받거나 받지 못한 메세지를 통해 추측할 뿐이다.

## 진실은 다수결로 결정된다

받기만 할 수 있고 보내는 메세지가 모두 유실된다면 해당 노드는 죽었다고 판단하게 된다. 해당 노드는 묘지로 끌려가며 소리 지르지만 아무도 그것을 알아 차릴 수 없다. 아주 긴 GC가 실행되는 경우에도 타임아웃이 발생하며 다른 노드는 이 노드를 죽었다고 판단할 수 밖에 없다.

분산 시스템은 한 노드에 의존할 수 없다. 대신 여러 분산 알고리즘은 정족수(quorum)에 의존한다. 일반적으로는 과반 이상을 정족수로 삼는다.

### 리더와 잠금

시스템이 오직 하나의 뭔가를 필요할 때가 자주 있다. 분산 시스템에서 이를 구현하려면 주의해야 한다. 어떤 노드가 스스로 “특별히 선택되었다”고 생각하더라도 노드의 정족수가 반드시 동의한다는 것은 아니다.

실제로 HBase에서는 하나의 파일에 대해 하나의 클라이언트만 접근하도록하여 파일의 오염을 막고자 했다. 해당 로직에서 다음과 같은 케이스가 발생할 수 있다.

1. `클라이언트1`이 `잠금 서비스`로부터 권한을 획득한다. 이후 STW로 인해 동작이 중지된다.
2. `잠금 서비스`는 일정 시간이 지나 권한 만료를 통보하지만 `클라이언트1`은 받을 수 없다.
3. `클라이언트2`는 해당 파일에 대한 권한을 획득하고 작업을 완료한다.
4. `클라이언트1`은 권한이 만료 되었지만 알지 못해 GC 이후 원하는 동작을 수행하게 되고 쓰기 충돌이 발생하며 파일이 오염되게 된다.

### 펜싱 토큰

파일 저장소와 같은 리소스에 대한 접근을 보호하기 위해 잠금을 사용할 떄는 자신이 “선택된 자”라고 잘못 믿는 노드가 나머지 시스템을 방해할 수 없도록 보장해야한다. 이를 쉽게 달성하는 단순한 기법인 `펜싱(fencing)`이다.

잠금 서비스가 잠금 권한을 줄 때 `펜싱 토큰(fencing token)`을 부여한다고 가정하자. `펜싱 토큰`은 권한을 부여할 때마다 단조 증가하는 숫자이다.

이를 통해 앞선 예제에서 클라이언트1의 늦은 쓰기 작업은 더 늦은 펜싱 토큰의 작업인 클라이언트2의 작업이 완료되었으므로 거절될 수 있다.

## 비잔틴 결함

모든 노드들이 `진실`만을 이야기 한다고 가정되지 않는다면 훨씬 더 어려워진다. 실제로 어떤 노드가 받지 않은 메세지에 대해서 받았다고 말할 수 있다. 이러한 신뢰성이 없는 환경에서 합의에 도달하는 문제를 `비잔틴 장군 문제(Byzantine Generals Problems)`라고 한다.

보통은 비잔틴 결함이 없다고 가정할 수 있다. 따라서 대부분 데이터 시스템에서 비잔틴 내결함성 솔루션을 배치하는 것은 비용이 커서 실용적이지 않다.

### 약한 형태의 거짓말

노드들은 일반적으로 정직하지만 버그나 결함과 같은 약한 형태의 거짓말로부터 보호해주는 메커니즘은 가치 있을 수 있다.

- 네트워크 패킷이 오염될 수 있다. 체크섬으로 검증하지만 검증이 안될 수 있어 어플리케이션 레벨에서 체크섬을 도입하는 것도 방법이다.
- 공개적으로 접근 가능한 애플리케이션은 사용자의 입력을 신중하게 살균해야 한다.

## 시스템 모델과 현실

시스템에서 발생할 것으로 예쌍되는 결함의 종류를 정형화 해야한다. 시스템 모델(system model)을 정의해서 정형화하고 알고리즘을 가정하는 것을 기술한 추상화이다.

- 타이밍 가정
    1. 동기식 모델: 네트워크 지연, 프로세스 중단, 시계 오차에 모두 제한이 있다고 가정한다.
    2. 부분 동기식 모델: 대부분의 시간에는 동기식 시스템처럼 동작하지만 때떄로 네트워크 지연, 프로세스 중단, 시계 드리프트 한계치를 초과한다는 뜻이다. 가장 현실적인 모델이다.
    3. 비동기식 모델: 어떠한 타이밍에 대해서 가정할 수 없다.
- 노드 장애
    1. crash-stop: 죽으면 다시 사용할 수 없다.
    2. crash-recovery: 죽을 수 있지만 시간이 흐른 뒤에 응답할 것이라는 가정
    3. byzantine: 노드는 전적으로 무슨 일이든 할 수 있다.

### 알고리즘의 정확성

알고리즘이 정확하다(correct)는 게 어떤 의미인지 정의하기 위해 알고리즘의 속성(property)을 기술할 수 있다.

예를 들어 펜싱 토큰을 생성한다면 그 알고리즘은 다음 속성을 지녀야 한다.

- 유일성: 펜싱 토큰 요청이 같은 값을 반환하지 않는다.
- 단조 일련번호: 요청 x가 토큰 tx를, 요청 y가 토큰 ty를 반환했고 y가 시작하기 전에 x가 완료되었다면 tx<ty를 만족한다.
- 가용성: 펜싱 토큰을 요청하고 죽지 않는 노드는 결국에 응답을 받는다.

### 안전성과 활동성

상황을 분명히 하기 위해 안전성(safety)와 활동성(liveness)을 구별할 필요가 있다. 앞선 예시에서 유일성과 단조 일련번호는 안전성 속성이며 가용성은 활동성 속성이다.활동성 속성들은 흔히 최종적(eventually)를 포함한다.

안전성은 흔히 비공식적으로 나쁜 일은 일어나지 않는다이고, 활동성은 좋은 일은 결국에 일어난다고 정의된다.

### 시스템 모델을 현실 세계에 대응시키기

이론적인 추상 시스템 모델은 현실과 다른 점이 많지만 쓸모 없다고 말하는 것은 아니다. 오히려 추상 시스템 모델은 현실 시스템의 복잡함에서 우리가 추론할 수 있는 관리 가능한 결함 집합을 뽑아내고, 문제를 이해하여 체계적으로 해결할 수 있도록 하는 데 엄청난 도움이 된다.

알고리즘이 올바르다고 증명됐더라도 반드시 현실 시스템에서의 구현도 언제나 올바르게 동작한다는 뜻은 아니다.
