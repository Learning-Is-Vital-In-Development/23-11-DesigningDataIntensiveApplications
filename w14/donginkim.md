# 지식, 진실, 그리고 거짓말

- 분산 시스템은 공유 메모리가 없고 지연 변동이 큰 신뢰할 수 없는 네트워크를 통해 메시지를 보낼 수 있을 뿐이다.
    - 부분 장애, 신뢰성 없는 시계, 프로세스 중단에 시달릴 수 있다.
- 네트워크에 있는 노드는 어떤 것도 확실히 알지 못한다. 메시지를 기반으로 추측만 할 수 있다.
- 분산 시스템에서 우리는 동작(시스템 모델)에 관해 정한 가정을 명시하고 이를 만족시키는 방식으로 설계할 수 있다.
    - 기반 시스템 모델이 적은 보장만 제공해도 신뢰성있는 동작을 달성할 수 있다.

## 진실은 다수결로 결정한다

노드가 상황에 대한 자신의 판단을 반드시 믿을 수 없다.

1. 어떠한 노드가 정상 동작을 하는데도 다른 노드가 그 노드가 정상 동작하지 않는다고 판단하는 경우
    - 네트워크 오류 및 지연으로 인해서
2. 한쪽 연결이 끊긴 노드는 자신이 보내는 메시지가 다른 노드로부터 확인 응답을 받지 못하는 것을 알아내서 네트워크 결함이 있는게 확실하다고 깨닫는 경우
    - 다른 노드들이 그 노드가 죽었다고 잘못 선언한고 한쪽 연결이 끊긴 노드는 그에 대해 아무 일도 할 수 없다.
3. stop-the-world 가비지 컬렉션 중단을 할 때 모든 스레드가 GC에 선점되므로 아무 요청을 처리하지 못한다. 다른 노드들은 그 노드가 죽었다고 선언한다. 하지만 그 노드는 GC가 끝나고 실행을 재개한다.

여러 **분산 알고리즘은 정족수(quorum)에 의존**한다. 특정한 노드 하나에 대한 의존을 줄이기 위해 결정을 하려면 여러 노드로부터 어떤 최소 개수의 투표를 받아야한다.

노드의 과반수 이상을 정족수로 삼는 방법

- 과반수 정족수를 사용하면 개별 노드들에 장애가 나더라도 시스템은 동작할 수 있다.
- 3개면 한대에 장애가 나도 괜찮다. 노드가 5대면 두 대가 장애가 나도 괜찮다.
- 시스템에는 오직 하나의 과반수가 존재할 수 있다.

### 리더와 잠금
- 스플릿 브레인을 피하기 위해 오직 한 노드만 데이터베이스 파티션의 리더가 될 수 있다.
![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/93cc8930-8b70-4423-8cf5-f374461d8af8)
> 이것은 노드 간의 네트워크 계층을 고려할 때까지 합리적인 가정처럼 들립니다. 노드 간의 네트워크 경로가 다운되면 어떻게 됩니까?
> 이제 어느 노드도 다른 노드와 통신할 수 없으며 이 상황에서 대기 서버는 활성 노드가 실패했다고 생각하는 것을 기반으로 스스로를 활성 서버로 승격할 수 있습니다. 이로 인해 두 노드가 모두 '활성' 상태가 되어 서로가 다른 노드를 죽은 것으로 간주하게 됩니다. 결과적으로 두 노드의 데이터가 변경됨에 따라 데이터 무결성과 일관성이 손상됩니다. 이것은 **"스플릿 브레인"** .



- 특정한 자원이나 객체에 동시에 쓰거나 오염시키는 것을 방지하기 위해 오직 하나의 트랜잭션이나 클라이언트만 어떤 자원이나 객체의 잠금을 획득할 수 있다.
- 사용자명으로 사용자를 유일하게 식별할 수 있어야 하므로 오직 한 명의 사용자만 특정한 사용자명으로 등록할 수 있다.

어떤 노드가 스스로 ‘선택된 자’(파티션의 리더, 잠금을 획득한 자, 사용자명을 차지하는 데 성공한 사용자의 요청 처리기)라고 믿을지라도 노드의 정족수를 반드시 동의한다는 뜻이 아니다.

노드의 과반수가 어떤 노드가 죽었다고 선언했는데 그 노드가 선택된 자인 것처럼 행동한다면 설계되지 않은 시스템에서는 문제를 유발할 수 있다. 노드는 자신이 정한 능력 내에서 다른 노드들에게 메시지를 보낼 수 있고 다른 노드들이 그 노드를 믿는다면 시스템은 전체적으로 뭔가 잘못된 일을 할 수 있다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/21bc7912-2b25-414e-b445-972efc59ab06)

클라이언트1에서 토큰 만료 로직을 진행하지 않고 STW를 통해 펜딩되었다가 STW가 마쳤을 대 락이 만료되었다는 정보를 확인하지 못하고 쓰기 연산이 들어가는 경우 이를 거부해야한다.

### 펜싱 토큰

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/75e56deb-14e3-46fd-9c38-ba20c6f37c8f)
펜싱 토큰이 증가하는 순서에 맞는 쓰기만 허용함으로써 저장소에 대한 접근을 안전하게 만들기

잠금 서버가 잠금이나 임차권을 승인할 때마다 **펜싱 토큰(fencing token)**도 반환한다고 가정한다. 펜싱 토큰은 잠금이 승인될 때마다 증가하는 숫자다. 그러면 클라이언트가 쓰기 요청을 저장소 서비스로 보낼 때마다 펜싱 토큰을 포함하도록 요구한다.

잠금 서비스로 주키퍼를 사용하면 트랜잭션 ID zxid나 노드 버전 cversion을 펜싱 토큰으로 사용할 수 있다. 이들은 단조증가가 보장되므로 필요한 속성을 지닌다.


