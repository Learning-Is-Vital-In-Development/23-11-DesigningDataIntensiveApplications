# 서론

`데이터 모델`은 소프트웨어 개발에서 제일 중요한 부분일 것이다. 

SW가 어떻게 작성됐는지 뿐만 아니라 해결하려는 문제를 어떻게 생각해야 하는지에 대해서도 영향을 미치기 때문이다. 

대부분의 애플리케이션은 하나의 데이터 모델을 다른 데이터 모델 위에 계층을 둬서 만든다. (**각 계층의 핵심 문제**: 다음 하위 계층에서 데이터 모델 표현하는 방법)

- 애플리케이션 개발자는 현실(사람, 조직, 상품, 센서, 자금 흐름 등)을 보고 객체나 데이터 구조 그리고 이러한 데이터 구조를 다루는 API를 모델링한다.
- 데이터 구조를 저장할 때는 JSON, XML 문서. 관계형 데이터 베이스 테이블이나 그래프 모델 같은 범용 데이터 모델로 표현
- ……

각 계층은 명확한 데이터 모델을 제공해 하위 계층의 복잡성을 숨긴다.  (ex - API : 여러 api 기반으로 만든 api처럼 중간 단계를 더 둘 수 있지만 기본 개념은 동일) 

복잡성을 숨김으로써 다른 그룹의 사람들이 더 효율적으로 함께 이할 수 있게끔 한다. 

애플리케이션이 어떤 데이터를 다루느냐에 따라 어떤 데이터 모델을 선택할지 결정된다. (소프트웨어가 할 수 있는 일과 할 수 없는 일에 영향을 주므로)

**데이터 모델은 소프트웨어가 할 수 있는 일과 없는 일에 영향을 주므로 어플리케이션에 적합한 모델을 찾는 것이 중요**하다.

### ****데이터 모델링이란?****

데이터를 생산하여 Database에 저장하기 위해 처리하는 과정

데이터 모델에는 그 객체가 다른 객체와 규칙을 대표하도록 설계되어야 하고 이 과정에서 데이터는 비즈니스 규칙, 규제 그리고 정부의 정책까지 데이터를 통해 표현할 수 있도록 한다(이러한 로직 들)

데이터 모델은 데이터의 설명과 의미 및 데이터의 일관성 제약 조건을 구성하는 추상 모델로 정의된다.

- 추상화: 현실 세계를 일정한 형식에 맞추어 표현한다.
- 단순화: 현실 세계를 약속된 규약이나 제한된 표기법과 언어로 표현한다
- 명확화: 누구나 이해가기 쉽게 애매모호함을 제거한다.

### ****모델링의 3단계****

개념적 모델링 → 논리적 모델링 → 물리적 모델링

`개념적 모델링`: 현실 세계의 데이터를 추상화하여 데이터로 표현하는 과정

- Entity를 구성하고 그 entity 의 속성, 필드 등을 정의한다.

`논리적 모델링`: 논리적으로 데이터를 저장하기 위해 수립하는 단계

- 데이터의 구성 요소를 구조화 하고, 그들간의 관계를 정의한다.

`물리적 모델링`: 디스크에 데이터가 저장될 수 있도록 논리적 모델을 물리적 데이터 구조로 변환시키는 과정

- DB에서 구현하기 위한 데이터 모델을 표현한다

---

# **1. 관계형 모델과 문서 모델(relational/document model)**

관계형 모델을 기반으로 한 `SQL`이 오늘 날 가장 잘 알려져 있다.

- RDB에서 데이터는 `관계(relation)`로 구성되고, 각 관계(relation)은 `순서 없는 튜플(tuple)`(SQL에서 로우(row))모음이다.
- 관계형 모델은 이론적 제안이었기 때문에 효율성에 많은 문제를 제기했었다.
    - 하지만 관계형 데이터베이스 관리 시스템(relational database management system,`RDBMS`)와 SQL는 정규화된 구조로 데이터를 저장하고 **질의를 수행할 필요가 있는 사람**들이 대부분 선택하는 도구가 됐다.
- 관계형 데이터 베이스의 근원은 **트랜잭션 처리**나 **일괄 처리** 같은 **`비지니스 데이터 처리`**에 근원을 두고 있다.
    
    > *트랜잭션 처리 : 영업이나 은행 거래, 항공 예약, 창고 재고 보관
    *일괄 처리 : 고객 송장 작성, 급여 지불, 보고
    > 

- 수년 동안의 데이터 저장과 질의를 위한 접근 방식
    - 1970-1980: 네트워크/계층 모델 < 관계형 모델
    - 1980년 후반 1990초반: 객체 데이터
    - 2000년대 초 : XML 데이터  (매우 적게 채택)
    
    → 오늘날 웹에서 보는 대부분의 서비스는 `관계형 데이터 베이스`
     (ex-온라인 게시물, 토론, 소셜 네트워크, SaaS(software-as-a-service)생산성 애플리케이션 등)  
    

## 1) **NoSQL의 탄생**

2010년대 NoSQL은 관계형 모델의 우위를 뒤집으려는 가장 최신 시도이다. NoSQL은 **Not Only SQL**로 재해석 된다. 

NoSQL 데이터베이스를 채택 이유 

- 대규모 데이터셋에서 매우 높은 쓰기 처리량 달성을 RDBMS보다 쉽게 할 수 있을만큼의 뛰어난 확장성.
- 상용 DB보다 무료 무료 오픈소스에 대한 선호도 확산
- 관계형 모델에서는 지원하지 않는 특수 질의
- 관계형에서 스키마 제한에 대한 불만, 동적이고 풍부한 데이터 모델에 대한 바람

애플리케이션은 저마다 요구사항이 달라 하나의 선택이 전체의 최적의 선택이 아닐 수 있다.
따라서 가까운 미래에는 RDBMS가 다양한 비관계형 데이터 스토어와 함께 사용될 것이다. 

> →  RDB가 다양함을 가진 비관계형 data store와 함께 사용 개념을 **`다중 저장소 지속성(polyglot persistence)`** 이라고 한다
> 

## 2) **객체 관계형 불일치**

`객체 지향 프로그래밍` (오늘날 대부분의 애플리케이션은 객체 지향 프로그래밍 언어로 개발 됨.) 
RDBMS에 저장하려면 애플리케이션 코드와 데이터베이스 모델 객채(테이블, 로우, 컬럼) 사이에 거추장스러운 전환 계층이 필요하다. 

→ 이런 모델의 분리를 **`임피던스 불일치(impedance mismatch)`**라고 부른다

> *임피던스 불일치(impedance mismatch) :객체 지향형 언어로 개발하면 관계형 DB를 사용할 경우 로우, 칼럼을 객체로 변경하는 전환 계층이 필요하다. 이러한 불일치를 의미
> 

액티브레코드(ActiveRecord)나 하이버네이트(Hibernate) 같은 **객체 관계형 맵핑(ORM) 프레임워크**는 전환 계층에 필요한 상용구 코드(boilerplate code)의 양을 줄이지만 두 모델간 차이를 완벽히 숨길 수 없다.

예시) 관계형 스키마에서 이력서를 표현할 경우

- 대부분의 사람은 학력 기간과 연락처 정보등 하나 이상의 데이터를 담아야한다.
- 프로필 고유 식별자(user id), 다른 필드(first_name, last_name, 경력, 학력기간, 연락처 정보)
- 사용자와 이들 항목은 **일대다(one-to-many)관계**이며 이는 아래와 같은 다양한 방법으로 나타 낼 수 있다.
    - 전통적인 SQL모델에서는 각 학력과 연락처등 정보를 개별 테이블에 넣고 외래키로 참조한다
    - 이후 SQL마지막 버전에서는 구조화된 데이터 타입과 XML데이터에 대한 지원도 되었다.
    - 마지막으로는, 직업 학력 연락처 정보를 JSON등으로 부호화해 텍스트 칼럼에 저장하여 애플리케이션이 해석하도록 하는 방식이다.
     -> but, 부호화된 칼럼의 값을 질의하는 DB는 사용할 수 없다.

위의 예인 이력서 같은 구조는 모든 내용을 갖추고 있는 문서라 JSON 표현에 매우 적합하다. 몽고DB, 리싱크DB, 카우치DB, 에스프레소 같은 문서 지향 DB는 JSON데이터 모델을 지원한다. 일부 개발자들은 JSON 모델이 임피던스 불일치를 줄인다고 생각하는데, 사실 JSON 자체가 가진 문제도 있다(이후 4장에서 설명). JSON식의 표현은 다중 테이블 스키마 보다 **더 나은 `지역성(locality)`**를 갖는다. 관계형 예제에서 다중 질의(각 테이블에 user_id로 질의)와 같은 복잡한 조인이 필요없다. 

> *지역성(locality) : 한번 접근한 데이터는 다시 접근할 가능성이 높다.
> 

→ JSON 표현에서는 모든 관련 정보가 한 곳에 있기 때문에 질의 하나로 충분하다. 

사실 이력서 상의 **일대다 관계 데이터**들은 `TREE구조`와 같은데, 이는 JSON 표현에서 명시적으로 드러나게 된다.

## 3) **다대일과 다대다 관계**

앞선 예제에서 지역과 업계는 직접 입력받는 것이 아닌 region_id 와 industry_id를 사용했는데, 이렇게 표준 목록으로 드롭다운 리스트 형식으로 만든데에는 여러 장점이있다.

- 프로필간 일관된 스타일의 철자 & 모호함 회피, 현지화 지원 , 갱신의 편의성, 더 나은 검색

ID나 텍스트 문자열의 저장 여부는 중복의 문제이다. 

- ID를 사용하는 경우 (자선 활동이라는 단어처럼) 의미 있는 정보는 **한 곳에만 저장**하고 그것을 **참조하는 모든 것은 ID를 사용**한다.
- 텍스트를 직접 저장한다면 그것을 사용하는 모든 레코드에서 사람을 의미하는 정보를 **중복 저장**하게 된다.

→ ID 장점: 중복 제거, 변경 용이

중복된 데이터를 정규화 하려면 다대일 관계가 필요하지만, 문서 모델에서 **다대일 관계는 적합하지 않다**. 
따라서 데이터 베이스에 대한 다중 질의를 만들어서 애플리케이션 코드에서 조인을 흉내내야 하기에 어렵다.

> 💡 문서모델 다대일 관계에서 다중 질의를 만든다는게 무엇인가?
> 
> 
> ![추천서와 같은 새로운 기능이 Many-to-Many를 어떻게 필요로 하는지 보여준다.](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e7dd74dc-18d7-4535-9cbb-e5a7091310c0/Untitled.png)
> 
> 추천서와 같은 새로운 기능이 Many-to-Many를 어떻게 필요로 하는지 보여준다.
> 
> - entity 로 조직을 연결한다면 조직에 관련된 정보를 링크하거나, 그 조직의 로고, 추가 정보를 관리할 수 있다.
> - 이력서에 추천서를 추가할 경우 추천인의 사진이 변경되면 한번에 모든 추천서의 사진이 변경되도록 구현이 가능하다.

## 4) **문서 데이터베이스는 역사를 반복하고 있나??**

RDBMS는 일상적으로 다대다 관계와 조인을 사용하지만
문서형 DB와 NOSQL은 DB에서 다대다(Many-to-Many) 관계 표현의 가장 좋은 방법에 대한 논쟁을 펼치고 있다.

1970년대 비지니스 데이터 처리를 위해 IBM의 정보 관리 시스템을 데이터베이스로 가장 많이 사용했는데, 이는 계층 모델이라 부르는 상당히 간단한 모델을 사용했다. 계층 모델은 오늘날 사용하는 JSON 모델과 놀랍도록 비슷하며, 모든 데이터를 레코드 내에 중첩된 레코드 트리로 표현한다.

하지만 계층 모델 역시 다대다 관계 표현이 어려워 오늘날과 똑같은 고민했고, 이런 계층 모델의 한계를 해결하기 위해 관계형 모델과 네트워크 모델이 나타나게 되었다.

### ****네트워크 모델 (≒ 코다실 모델)****

`코다실 모델 (Conference on Data System Language,CODASYL)`

코다실 모델이라고 부르기도한다. 계층 모델을 일반화한 모델로, 계층 모델의 트리 구조에서는 모든 레코드는 정확하게 하나의 부모가 존재하는데, 네트워크 모델에서는 다중 부모가 존재가능하다. 레코드에 접근하는 유일한 방법은 최상위 레코드에서부터 연속된 연결 경로를 따르는 방법으로, 이를 **접근 경로** 라고 하며, 외래키(foreign key)보다는 `프로그래밍 언어의 포인터`와 더 비슷하다. (삽입시 조인 수행)

> *외래키:
*포인터:
> 

**네트워크 모델의 “접근 경로는 없다”**

- 없다기 보다는 `질의 최적화(Query Optimizer)`가 자동으로 대신 만드는 것

만약 레코드가 다중 부모를 가진다면 애플리케이션 코드는 다양한 관계를 모두 추적해야하며, 이런 수동 접근 경로 선택은 데이터베이스 질의와 갱신을 위한 코드가 복잡하고 유연하지 못하다. 
M:N을  구현하면 마치 N차원 공간 항해랑 같기 때문에, 접근 경로를 수정할 수 있지만 많은 수작업 질의코드를 살펴봐야하고 재작성 하는 등 매우 어려운 일이다.

### **관계형 모델**

대조적으로 관계형 모델이 하는 일은 알려준 모든 데이터를 배치하는 것으로, 단순히 튜플의 컬렉션이 전부이다. 다른 테이블과의 관계를 신경쓰지 않고 새 로우를 삽입할 수 도 있다. 
이런 RDB에서 query optimizer는 질의의 어느 부분을 어떤 순서로 실행할지 결정하고 사용할 색인을 자동 결정한다. 이 선택이 바로 실제 “접근 경로”인 것. 하지만 개발자가 아니라 query optimizer기가 자동으로 만드므로 개발자가 고려할 필요가 없다.
→ index를 변경하면 옵티마이저가 자동으로 적합한 방법을 선택하니 새로운 기능을 추가하는 것이 훨씬 쉽다 (**범용 최적화기 사용시 모든 애플리케이션이 혜택**)

### **문서 데이터베이스와의 비교**

문서 데이터베이스는 상위 레코드 내에 중첩된 레코드를 저장한다는 측면에서 계층 모델로 되돌아갔다. 하지만 다대일과 다대다를 표현할때 RDB와 근본적으로 다르지 않았으며, 관계형 모델에서 외래키가 문서 모델에서의 문서 참조(document reference)와 같다.

> *중첩된 레코드를 저장한다라는 의미?
> 

## 5) **관계형 데이터베이스와 오늘날의 문서 데이터베이스**

- `관계형(RDB) 선호` : 조인, 다대다(M:1N), 다대일(M:1) 관계 지원하면서 문서 데이터 모델에 대항
- `문서 데이터(document) 모델 선호` : 스키마 유연성, 지역성에 기인한 더 나은 선택 때문
    
    > ***스키마 유연성**: 관계형 데이터베이스의 ‘스키마'가 주는 제한에서 벗어나 동적이고 자유로운 데이터 모델의 필요성으로 등장
    ***지역성**: 모든 정보가 한 문서에 저장되어 있다. 이 지역성 때문에 관계형 모델모다 성능이 더 좋다.
    > 

### **어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 할까?**

애플리케이션 데이터가 문서와 비슷한 구조라면 문서 모델을 사용하는 것이 좋다. 
관계형 모델은 문서와 비슷한 구조를 여러 테이블로 나누어 **찢기(shredding)** 때문에 복잡한 애플리케이션 코드를 발생시킨다.

But, 문서 모델은 중첩항목을 바로 참조할 수 없고, 미흡한 조인 지원은 때떄로 문제가 된다(때로는 아닐 수 있음). 다대다 관계를 사용하면 문서 모델의 매력은 떨어지는것이 대표적인 문제다.

결론 : 일반적으로 어떤 데이터 모델이 코드를 더 간단하게 만드는지 말할수 없음. (데이터 유형에 따라 다름!)

*발표하신 스터디원 분께서 몽고DB같은게 로그 검색에 유의미한 이유를 알게 된것 같았다, 라고 했는데. 듣고보니 오 .. 그렇구나 싶었다. 생각해보면 로그 데이터는 애초에 조인이 필요하지 않는 그저 쌓이는 문서지만 필요할때 찾아보면 좋을 데이터이기 때문이다!*

### **문서모델에서의 스키마 유연성**

문서 데이터베이스는 종종 스키마리스(schemaless)로 불리지만, 이는 오해의 소지가 있는 표현이며, 데이터를 읽는 코드는 보통 구조의 유형을 어느정도 가정한다. 즉 쓰기 스키마말고 읽기 스키마 인것이다.

> 쓰기 스키마와 읽기 스키마
> 
> - **쓰기 스키마(schema-on-write)** : RDB의 전통적인 접근 방식으로 스키마는 명시적으로 DB는 쓰여진 모든 데이터가 스키마를 따르고 있음을 보장한다
>     - 정적 타임 확인과 유사하다
> - **읽기 스키마(schema-on-read)** : 데이터 주고는 암묵적으로 읽을때만 해석이 된다.
>     - 프로그래밍 언어에서 동작 타입 확인과 유사하다

예를들어 현재의 이름을 성과 이름 필드로 분리할 경우, “동적 타입”에서는 예전 문서를 읽은 경우를 처리하는 코드만 있으면 되는데, “정적 타입”의 경우 **마이그레이션 작업**이 필요하다

스키마 변경에 대한 평판은 매우 나쁘지만, 사실 대부분의 RDBMS에서 ALTER TABLE 문은 수 밀리초 안에 수행한다. 하지만 MYSQL의 경우 **전체 테이블을 복사하여 수분에서 수초까지 중단 시간이 발생**한다.

UPDATE 문을 실행하면 모든 로우가 재작성 될 수 있기에 오래걸릴 수 있다.

읽기 스키마 접근 방식은 컬렉션 안의 항목이 모두 동일한 구조가 아닐때 유리하다. 왜냐면

- 각 유형의 오브젝트 별로 자체 테이블에 넣는 방법은 실용적이지 않다.
- 언제나 변경 가능한 외부 시스템에 의해 데이터 구조가 결정되기 때문

스키마는 득보다 싫이 많지만, 모든 레코드가 동일한 구조라 예상 가능하다면 스키마는 문서화와 구조를 강제하기 위한 아주 좋은 메커니즘이다.

**질의를 위한 데이터 지역성**

문서는 보통 JSON이나 부호화된 단일 연속 문자열(몽고DB 같은)로 저장된다. 애플리케이션이 자주 전체 문서에 접근해야할 때 **저장소 지역성(storage locality)**를 활용하면 성능상의 이점이 있다.

지역성의 이점은 해당 문서의 많은 부분을 필요로 하는 경우에 적용된다. 따라서 일반적으로 문서를 아주 작게 유지하면서 문서의 크기가 증가하는 쓰기를 피하라고 권장한다.

지역성은 문서모델에만 국한되지 않는데, 오라클은 다중 테이블 색인 클러스터 테이블(multi-table index cluster table)기능을 사용해 지역적 특성을 제공한다

**문서 데이터베이스와 관계형 데이터베이스의 통합**

RDB랑 문서DB는 시간이 지남에 따라 점점 더 비슷해지고 있으며, 서로 부족한 부분은 보완해 나가고 있다. 이 두 DB의 혼합 모델은 미래 데이터베이스들이 가야할 올바른 길이라고 이야기한다.
