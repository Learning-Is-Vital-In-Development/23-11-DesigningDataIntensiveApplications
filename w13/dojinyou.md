# 분산시스템의 골칫거리(결함과 부분 장애, 신뢰성 없는 네트워크, 신뢰성 없는 시계)

“**잘못될 가능성이 있다면 잘못되었다.”** 라고 가정한다.

분산 시스템을 다루는 것은 한 컴퓨터에서 실행되는 소프트웨어를 작성하는 일과는 근본적으로 다르다.

# 결함과 부분 장애

단일 컴퓨터에서 실행되는 소프트웨어는 하드웨어가 올바르게 작동한다면 항상 같은 결과를 낸다.(결정적)

컴퓨터에 내부 결함이 발생하면 잘못된 결과가 아니라 완전히 동작하지 않기를 원한다. 잘못된 결과는 다루기 어렵고 혼란스럽기 때문이다.

네트워크로 연결된 여러 컴퓨터에서 실행되는 소프트웨어를 작성할 때는 근본적으로 상황이 다르다. 분산시스템에서 어떤 부분은 잘 동작하지만 다른 부분은 예측할 수 없는 방식으로 고장나는 것도 무리가 아니다. 이를 부분 장애(partial failure)이라 한다. (비결정적)

## 클라우드 컴퓨팅과 슈퍼컴퓨팅

대규모 컴퓨팅 시스템의 극단은 압도적인 슈퍼컴퓨팅과 엄청난 수의 클라우드 컴퓨팅으로 표현할 수 있다. 경우에 따라 결함에 대한 처리방식도 다르다.

슈퍼 컴퓨터에서 부분 장애가 발생하면 모든 노드의 연산을 멈추고 복구한다. 이후 지속적으로 기록한 마지막 체크상태로 돌아가 다시 실행한다. 단일 노드의 장애를 전체로 전파하고 전체가 죽게한다.

분산 시스템이 동작하게 하려면 부분 장애 가능성을 받아들이고 내결함성 매커니즘을 넣어야 한다.

# 신뢰성 없는 네트워크

여기서 말하는 분산 시스템은 비공유 시스템으로 네트워크가 유일한 통신 수단이다. 인터넷은 이러한 비공유 시스템을 구축하는 일반적인 방법이다. 인터넷은 비동기 패킷 네트워크(asynchronous packet network)인데 다른 노드로의 메세지 전송이 언제 도착할 지, 도착하기는 하는지를 보장할 수 없다.

이 문제를 다루는 흔한 방법은 타임아웃으로 일정 시간이 지나면 받지 않았다고 판단해버린다.

## 현실의 네트워크 결함

여러분의 환경에서 네트워크 결함은 언제든 일어날 수 있고 소프트웨어는 이를 처리할 수 있어야 한다. 하지만 반드시 견뎌내도록(tolerating) 해야하는 것은 아니다. 평소에 네트워크는 상당히 믿을만 하고 장애가 있다면 일시적으로 오류 메세지를 보여줄 수도 있다.

## 결함 감지

많은 시스템은 결함이 있는 노드를 자동으로 감지할 수 있어야 한다. 하지만 네트워크의 불확실성은 이를 어렵게 한다. TCP 패킷이 전달되었다는 확인 응답(ack)을 받더라도 실제로 애플리케이션이 이를 처리 했다고 확신할 수 없다. 애플리케이션의 긍정 응답을 받아야 한다.

## 타임아웃과 기약 없는 지연

**“타임아웃은 어느 정도로 잡아야 할까?”** 에 대한 명확한 답은 없다. 타임 아웃이 길면 노드 장애 판단이 늦어지며 너무 짧으면 일시적으로 느려진 노드도 죽었다고 판단할 수 있다. 노드가 죽었다고 판단하면 다른 노드에게 작업을 시켜 중복된 작업을 하거나 작업 부하를 더 크게할 수 있다. 따라서 섣부른 판단이 문제를 악화시킬 수도 있다.

비동기 네트워크는 기약 없는 지연(unbounded delay)이 있고 서버 구현은 대부분 어떤 최대 시간 내에 요청을 처리할 것이라고 보장할 수 없다.

### 네트워크 혼잡과 큐 대기

대부분의 네트워크 문제를 큐 대기 지연에서 발생한다. 네트워크 스위치의 패킷 처리 큐, OS의 작업 큐 등등 다양한 작업 대기를 위한 큐들이 존재하고 이들로 인해 문제가 발생한다. 큐 대기 지연은 시스템이 최대 용량에 가까울 때 특히 광범위하게 일어난다.

이러한 환경에서는 타임아웃을 실험적으로 선택할 수 밖에 없다. 변동성이 얼마나 되는 지 분포를 측정하고 그게 맞게 적절하게 트레이프 오프를 통해 결정한다.

더 좋은 방법은 지속적으로 응답시간과 변동성을 관찰하고 그에 따라 자동으로 조절하는 것이다.

## 동기 네트워크  대 비동기 네트워크

전화 네트워크에서 통화를 할 때는 회선(circuit)이 만들어진다. 이러한 네트워크는 동기식이며 큐 대기 문제도 겪지 않아 네트워크 종단 지연 시간의 최대치가 고정돼 있다. 이를 제한 있는 지연(bounded delay)이라고 한다.

### 그냥 네트워크 지연을 예측 가능하게 만들 순 없을까?

전화 네트워크는 회선이 만들어져있는 동안 고정적인 대역폭을 사용할 수 있지만, TCP 연결은 가용 가능한 네트워크 대역폭의 일부를 기회주의적으로 사용한다.

회선 교환 네트워크는 연결 시에 왕복시간의 최대치를 보장할 수 있다. 하지만 이더넷과 ip는 큐 대기 영향을 받는 패킷 교환(packet-swtich) 프로토콜이다.

이러한 패킷 교환 방식은 순간적으로 몰리는 트래픽(bursty traffic)에 최적화 됐기 때문이다.

# 신뢰성 없는 시계

시계와 시간을 중요하다. 타임아웃이 되었는 지 판단하기 위해서도 시간이 필요하다. 분산 시스템에서 통신은 즉각적이지 않으므로 시간은 다루기 까다롭다. 메세지가 네트워크를 거쳐 한 장비에서 다른 장비로 전달되는 데 시간이 소요된다.

게다가 네트워크에 있는 개별 장비들은 개별 시계를 가지고 있다. 이 시계들은 완벽하게 정확하진 않아서 다른 장비보다 약간 빠르거나 느릴 수 있다.

시간을 어느 정도 동기화 할 수 있고 이를 위해 가장 널리 사용되는 매커니즘은 네트워크 시간 프로토콜(Network Time Protocol, NTP)로 서버 그룹에서 보고한 시간에 따라 컴퓨터 시계를 조절할 수 있게 한다.

## 단조 시계 대 일 기준 시계

현대 컴퓨터는 일 기준 시계(time-of-day clock)와 단조 시계(monotonic clock)의 두 종류의 시계를 가진다.

### 일 기준 시계

어떤 달력에 따라 현재 날짜와 시간을 반환하는 역할을 한다. 리눅스의 `clock_gettime(CLOCK_REALTIME)`과 자바의 `System.currentTimeMillis()`는 에포크(epoch) 이래로 경과된 초나 밀리초를 표현한다.

일 기준 시계는 보통 NTP로 동기화 된다. 따라서 어떤 장비의 일 기준 시계 값이 다른 시계의 일 기준 시계의 값과 같은 의미이다. 하지만 NTP 서버보다 로컬 시계가 너무 앞서면 강제로 리셋되어 시간이 뒤로 돌아가는 것처럼 보일 수 있다. 이러한 사실은 경과 시간을 측정하기엔 부적절하다는 것을 의미한다.

### 단조 시계

타임 아웃이나 서비스 응답 시간 같은 지속 시간을 재는데 적합하다. 리눅스의 `clock_gettime(CLOCK_MONOTONIC)`과 자바의 `System.nanoTime()`이 있다.

한 시점에서 단조 시계를 확인하고 어떤 일을 한 뒤에 다시 시계를 확인하여 두 값의 차이로 소요된 시간을 측정할 수 있다. 따라서 시계는 값은 절대적인 의미를 가지지 않는다.

NTP는 컴퓨터의 로컬 시계가 느리거나 빠르다면 단조 시계의 진행하는 속도를 조절할 수 있다.

## 시계 동기화와 정확도

일 기준 시계는 외부 시간과 동기화 되어야 유용하지만 이러한 동기화 작업이 기대만큼 신뢰성이 있거나 정확하지 않다.

컴퓨터의 수정 시계는 아주 정확하지 않다. 더 빠르게 흐르거나 느리게 흐르는 드리프트(drift) 현상이 발생되는데 이러한 현상은 장비의 온도에 따라 달라진다.

시계의 정확도가 아주 중요하다면 많은 자원을 투자해 정확도를 매우 높일 수 있다.

## 동기화된 시계에 의존하기

시계의 문제 중 하나는 시계가 잘못되었다는 것을 눈치채기가 어렵다는 것이다. 소프트웨어의 특정 부분이 동기화된 시계에 의존한다면 극단적인 고장보다는 아주 미세하게 데이터의 오류가 발생할 가능성이 높다. 따라서 동기화된 시계가 필요한 소프트웨어를 사용한다면 필수적으로 모든 장비의 시계를 모니터링 해야 한다.

### 이벤트 순서화용 타임스탬프

**최종 쓰기 승리(last write wins, LWW)**라고 불리는 충돌 해소 전략은 다중 리더 복제와 카산드라, 리악 같은 리더 없는 데이터 베이스에서 널리 사용된다. 이는 결국 가장 “최근” 값을 유지하는 다른 것을 버리는 전략이다.  이때 “최근”을 정의하는 시계는 틀릴 수 있다는 것을 알고 있어야 한다.

증가하는 카운터를 기반으로 하는 논리적 시계는 이벤트 순서화의 안전한 대안이다. 기준 시간이나 경과한 시간이 아닌 이벤트의 상대적인 순서만 측정한다.

### 시계 읽기는 신뢰 구간이 있다.

시계는 네트워크 지연 등의 이유로 다양하게 부정확할 수 있다. 따라서 시계 읽기를 특정 시점으로 생각하는 것보다 신뢰 구간의 범위로 읽는 것이 나을 수 있다.

### 전역 스냅샷용 동기화된 시계

가장 흔한 스냅샷 격리 구현은 단조 증가하는 트랜잭션 id가 필요하다. 단조 증가하는 트랜잭션 id를 통해 해당 트랜잭션의 자신보다 먼저 일어난(id값이 작은) 트랜잭션을 볼 수 없다.

스패너는 이러한 방식으로 데이터 센터에 걸쳐서 스냅샷 격리를 구현하고 두 타임스탬프 기간이 겹치지 않는다면 명시적으로 순서를 정할 수 있다.

## 프로세스 중단

쓰레드가 버퍼 이상의 시간이 중단되면 권한이 회수되지만 쓰레드는 이를 알 수가 없다. 임의로 발생할 수 있고 병렬성이 발생할 수 있으므로 타이밍에 대한 어떤 가정도 할 수 없다. 이를 위한 다양한 장치가 있지만 이를 바로 분산 시스템에 적용할 수 없다.

### 응답 시간 보장

충분히 열심히 노력하면 중단 원인을 제거할 수 있다. 항공기, 로켓 등에서는 일정 시간 내에 응답해야하는 데드라인이 명시되고 이를 지키지 않으면 전체 시스템 장애를 유발할 수 있다. 이를 엄격한 실시간 시스템이라고 한다.

이를 위해서는 프로세스가 명시된 간격의 CPU 시간을 할당 받을 수 있게 보장되도록 스케쥴링 해주는 실시간 운영체제(Real Time Operating System, RTOP)이 필요하다. 실시간과 고성능은 따르다. 실시간은 제때를 의미한다.

### 가비지 컬렉션(GC)의 영향을 제한하기

언어 런타임은 객체 할당률가 시간에 따라 남아 있는 여유 메모리 공간을 추적할 수 있으므로 언제 가지비 컬렉션을 할지와 관련된 어느 정도의 유연성을 갖고 있다.
