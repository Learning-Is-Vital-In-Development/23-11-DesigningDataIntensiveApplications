## 분산 시스템의 골칫거리

### 결함과 부분 장애

분산 시스템에서는 전체가 아닌 어떤 부분만 예측할 수 없는 방식으로 고장날 수도 있는데, 이를 부분 장애(partial failure) 라고 한다. 

#### 클라우드 컴퓨팅과 슈퍼 컴퓨팅

- 고성능 컴퓨팅(high-performance coimputing, HPC)
  - 슈퍼 컴퓨터는 보통 일기예보나 분자 동력학처럼 비용이 큰 과학 계산 작업에 쓰인다
  - 결함 처리 방식
    - 가끔씩 계산 상태를 지속성 있는 저장소에 체크포인트로 저장
    - 노드 하나에 장애가 발생했을 때는 그냥 전체 클러스터 작업부하를 중단
    - 장애가 발생한 노드가 복구된 후 마지막 체크포인트로부터 계산을 재시작
  - 분산 시스템보다는 단일 노드 컴퓨터에 가깝다
- 클라우드 컴퓨팅
  - 멀티 테넌트 데이터센터, IP 네트워크로 연결된 상용 컴퓨터, 신축적(elastic)/주문식(on-demand) 자원할당, 계량 결제(metered billing)..
  - 결함 처리 방식
    - 인터넷 관련 애플리케이션은 사용자에게 지연 시간이 낮은 서비스를 제공해야 하기 때문에 클러스터 중단을 할 수 없다
    - 상용 장비를 사용해 구축하는데, 규모의 경제를 이유로 비용대비 높은 성능을 제공하지만 실패율도 높다
    - 지리적으로 분산된 배포를 할 때 통신은 인터넷을 거치기에 로컬에 비해 느리고 신뢰성도 떨어진다  
    - 데이터센터의 네트워크는 IP와 이더넷을 주로 기반으로 하며 높은 양단 대역폭(bisection bandwidth)을 제공하기 위해 클로스 토폴로지(Clos topology)로 연결돼 있다.

결함 처리는 소프트웨어 설계의 일부여야 하며, 결함이 발생하면 어떻게 동작할지도 알아야 한다.

### 신뢰성 없는 네트워크

> (a)요청손실 (b)노드장애 (c)응답손실, 요청 이후 응답이 오지 않을 때 무엇이 원인인지 알 수 없음
![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/4795ed77-1fd0-41b3-bc26-c27d48c71500)

이 문제를 다루는 흔한 방법은 타임아웃 이다. 그러나 타임아웃이 발생했을 때 원격 노드가 응답을 받았는지 아닌지는 여전히 알 수 없다.


#### 현실의 네트워크 결함

네트워크 결함의 원인은 다양하기 때문에 네트워크 결함을 반드시 견뎌낼 필요는 없고, 중요한 점은 결함의 가능성을 인지하는것이다.<br>
네트워크 문제가 발생하면 어떻게 반응하는지 알고, 복구할 수 있도록 보장해야 한다.<br>
고의로 네트워크 문제를 유발하고 시스템을 테스트하는것도 좋다. (카오스 엔지니어링)

#### 결함 감지

시스템은 결함이 있는 노드를 자동으로 감지할 수 있어야 한다.

- 로드 밸런서는 죽은 노드로 요청을 그만 보내야 한다.
- 단일 리더 복제를 사용하는 분산 데이터베이스에서 리더에 장애가 나면 팔로워 중 하나가 리더가 되어야 한다.


#### 타임아웃과 기약 없는 지연

- 타임아웃이 길 때 : 노드가 죽었다고 선언될 때까지 기다리는 시간이 길어진다
- 타임아웃이 짧을 때 : 원격 노드의 문제가 일시적이라도 죽었다고 판단할 위험이 높아지고, 같은 동작을 한 번 이상 실행하게 될 수도 있다.

**합리적인 타임아웃 계산 방식**  

- 모든 패킷은 시간 **d** 내에 전송되거나 손실되지만 전송 시간이 결코 d보다 더 걸리지는 않는다
- 정상 노드는 항상 요청을 **r** 시간 내에 처리한다고 보장할 수 있다

두 가지 가정 하에 성공한 모든 요청은 **2d + r** 시간 내에 응답을 받는다고 보장할 수 있다.

하지만 우리가 사용하는 시스템은 대부분 위 가정 중 어떤 것도 보장하지 않는다.<br>
비동기 네트워크는 기약 없는 지연(unbounded delay)이 있고, 서버 구현은 요청 처리 시간을 보장하지 못한다.

#### 네트워크 혼잡과 큐 대기

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/410c3eda-933f-48f0-abfe-bfacab3dd476)


여러 노드가 동시에 같은 목적지로 패킷을 보내면 네트워크 스위치는 패킷을 큐에 넣고 처리한다.<br>
큐가 꽉 차면 패킷이 유실될 수 있다. 스위치 외에도 큐가 여러곳에 존재한다.

네트워크 지연을 예측하려는 방법은 대부분 한계가 있고, 현재로서는 네트워크 지연과 신뢰성에 대해 어떤 보장도 할 수 없다.<br>
네트워크 혼잡, 큐 대기, 기약 없는 지연이 발생할 가능성을 생각해야 하며, 타임아웃은 실험을 통해 결정해야 한다.


### 신뢰성 없는 시계

애플리케이션은 타임아웃, 응답시간, 성능분석, 기능구현 등 여러 방면으로 시계에 의존한다.

- 지속 시간에 대한 질의
  - 이 요청이 타임아웃됐나?
  - 이 서비스의 99분위 응답 시간은?
  - 이 서비스는 지난 5분간 평균 초당 몇 개의 질의를 처리했나?
  - 사용자가 우리 사이트에서 얼마나 머물렀나? 
- 시점에 대한 질의
  - 이 기사가 언제 게시됐나?
  - 며칠 몇 시에 미리 알림 이메일을 보내야 하나?
  - 이 캐시 항목은 언제 만료되나?
  - 로그 파일에 남은 이 오류 메시지의 타임스탬프는 무엇인가?
 
분산 시스템에서는 통신이 즉각적이지 않기 때문에 시간을 다루기 까다롭다.<br>
일반적으로 NTP(네트워크 시간 프로토콜)서버를 통해 각 장비의 시계를 조정한다.


#### 단조 시계 대 일 기준 시계

- `일 기준 시계(time-of-day clock)` : 흔히 아는 벽시계 시간. 보통 NTP로 동기화된다.
  - ex. Linux/clock_gettime(CLOCK_REALTIME), Java/System.currentTimeMillis()
- `단조 시계(monotonic clock)` : 장비 내 타이머에 의해 경과 된 시간.
  - ex. Linux/clock_gettime(CLOCK_MONOTONIC), Java/System.nanoTime()
 
#### 시계 동기화와 정확도

아쉽게도 두 시계 모두 기대만큼 신뢰성을 보장하지는 않는다.

- 컴퓨터의 쿼츠 시계는 장비의 온도에 따라 더 빠르거나 느려질 수 있다(드리프트(drift) 현상)
- 로컬시계가 NTP서버와 너무 차이가 나면 로컬 시계가 리셋될 수 있다.
- 노드와 NTP서버간 방화벽이 막혀 노드가 한동안 잘못된 설정으로 돌아갈 수 있다.
- NTP 동기화 오차는 네트워크 성능에 영향을 받는다.
- NTP서버에 이상이 있을수도 있다.
- 윤초가 발생하면 이를 고려하지 않은 시스템은 오동작할 수 있다.
- 가상 장비에서 CPU 공유로 인해 VM간 시간차이가 발생할 수 있다.
- 사용자가 고의로 시간을 바꿀수도 있다.

#### 동기화된 시계에 의존하기

네트워크에 결함이 있다는것을 인지하듯이 시계 역시 잘못될 수 있다는점을 인지해야 한다.

시계 오류는 티가 잘 안나기 때문에 티 안나는 데이터 손실이 발생할 수 있다.
따라서 동기화 된 시계가 필요한 소프트웨어를 사용한다면 장비 사이의 시계 차이를 주의깊게 모니터링해야 한다.
다른 노드와 시계 차이가 큰 노드는 죽은 것으로 선언하고 클러스터에서 제외해야 한다.
