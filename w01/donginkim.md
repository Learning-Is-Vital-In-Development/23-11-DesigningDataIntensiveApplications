# Overview

오늘날 많은 애플리케이션은 계산 중심(compute-intensive)과 다르게 데이터 중심(data-intensive)이다.

데이터 중심 애플리케이션은 공통으로 필요로 하는 기능을 표준 구성 요소(standard building block)으로 만든다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/745c6b0a-5f24-46a8-9021-a3b493930ab5)

- 구동 애플리케이션이나 다른 애플리케이션에서 나중에 다시 데이터를 찾을 수 있게 데이터를 저장(데이터베이스)
- 읽기 속도 향상을 위해 값비싼 수행을 기억(캐시)
- 사용자가 키워드로 데이터를 검색하거나 다양한 방법으로 필터리할 수 있게 제공(검색 색인(search index))
- 비동기 처리를 위해 다른 프로세스로 메시지 보내기(스트림 처리(stream processing))
- 주기적으로 대량의 누적된 데이터를 분석(일괄 처리(batch processing))

책에서 말하는 데이터 시스템은 뭘까?

1. 데이터 저장과 처리를 위한 여러 새로운 도구는 최근에 만들어졌다.
2. 점점 더 많은 애플리케이션이 단일 도구로는 더 이상 데이터 처리와 저장 모두를 만족시킬 수 없는 과도하고 광범위한 요구사항을 갖고 있다.

서비스 제공을 위해 각 도구를 결합할 때 서비스 인터페이스나 애플리케이션 프로그래밍 인터페이스는 기본적으로 더 작은 범용 구성 요소들로 새롭고 특수한 목적의 데이터 시스템을 만든다. 개발자는 애플리케이션 개발자뿐만 아니라 데이터 시스템 설계자이기도 하다.

대부분의 소프트웨어 시스템에서는 다음 세 가지 관심사에 중점을 둔다.

- 신뢰성(Reliability)
    
    하드웨어나 소프트웨어 결함, 인적 오류(human error) 같은 역경에 직면하더라도 시스템은 지속적으로 올바르게 동작(원하는 성능 수준에서 정확한 기능을 수행)해야 한다.
    
- 확장성(Scalability)
    
    시스템의 데이터 양, 트래픽 양, 복잡도가 증가하면서 이를 처리할 수 있는 적절한 방법이 있어야 한다.
    
- 유지보수성(Maintainability)
    
    시간이 지남에 따라 여러 다양한 사람들이 시스템 상에서 작업(현재 작업을 유지보수하고 새로운 사용 사례를 시스템에 적용하는 엔지니어링과 운영)할 것이기 때문에 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있게 해야한다.
    

# 신뢰성

일반적인 소프트웨어에 대한 기대치는 다음과 같다.

- 애플리케이션은 사용자가 기대한 기능을 수행한다.
- 시스템은 사용자가 범한 실수나 예상치못한 소프트웨어 사용범을 허용할 수 있다.
- 시스템 성능은 예상된 부하와 데이터 양에서필수적인 사용 사례를 충분히 만족한다.
- 시스템은 허가되지 않은 접근과 오남용을 방지한다.

이 모든 것을 올바르게 동작함이라고 의미한다고 하면 “무언가 잘못되더라도 지속적으로 올바르게 동작함”을 신뢰성의 의미로 이해할 수 있다.

잘못될 수 있는 일을 결함(fault)라고 부른다. 그 결함을 예측하고 대처할 수 있는 시스템을 내결함성(fault-tolerant) 또는 탄력성(resilient)을 지녔다고 말한다. 하지만 결함의 범위는 너무 크기 때문에 특정 유형의 결함 내성에 대해서만 이야기하는 것이 타당하다.

결함은 장애(failure)와 동일하지 않다. 일반적으로 결함은 사양에서 벗어난 시스템의 한 구성 요소로 정의되지만 장애는 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우다. 따라서 결함으로 인해 장애가 발생하지 않게끔 내결함성 구조를 설계하는 것이 가장 좋다.

고의적으로 결함을 유도함으로써 내결함성 시스템을 지속적으로 훈련하고 테스트해서 결함이 자연적으로 발생했을 때 올바르게 처리할 수 있어야 한다. 넷플릭스(Netflix)의 카오스 몽키(Chaos Monkey)가 이러한 접근 방식이다.

## 하드웨어 결함

- 하드디스크의 평균 장애 시간(mean time to failure, MTTF)은 10-50년
- 시스템 장애율을 줄이기 위해서는 하드웨어 구성 요소에 중복(redundancey)을 추가하는 방법이 일반적
- 클라우드의 발전으로 단일 장비 신뢰성보다 유연성(flexibility)과 탄력성(elasticity)을 우선적으로 처리하도록 설계.
- 내결함성 기술을 사용하거나 하드웨어 중복성을 추가해 전체 장비의 손실을 견딜 수 있는 시스템으로 옮겨갈 수 있다. 장비 장애를 견딜 수 있는 시스템은 전체 시스템의 중단시간 없이 한 번에 한 노드씩 패치할 수 있다.

## 소프트웨어 오류

- 소프트웨어 결함을 유발하는 버그는 특정 상황에 의해 발생하기 전까지 오랫동안 나타나지 않는다. 따라서 신속한 해결책이 없다.
- 시스템이 뭔가를 보장하길 기대한다면 수행 중에 특정 지표를 지속적으로 모니터링하여 차이가 생기는 경우 경고를 발생시킬 수 있다.

## 인적 오류

- 비프로덕션 샌드박스(sandbox)를 제공해라
- 단위 테스트, 통합 테스트, 수동 테스트까지모든 수준에서 철처하게 테스트하라. 자동 테스트는 정상적인 동작에서 거의 발생하지 않는 코너 케이스(corner case)를 다루는데 유용하다.
- 인적 오류를 빠르고 쉽게 복구할 수 있게 해야한다. 변경 내역을 빠르게 롤백(roll back)하고 새로운 코드를 서서히 롤 아웃(roll out)하게 만들고 계산이 잘못된 경우 재계산할 수 있게 해야한다.
- 성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책을 만들어야 한다. 모니터링을 다른 엔지니어링 분야에서는 원격 측정(telemetry)를 해야한다. 모니터링은 조기에 경고 신호를 보내줄 수 있고 특정 가정이나 제한을 벗어나는지 확인할 수 있게 한다. 문제가 발생했을 대 지표(metrics)는 문제를 분석하는데 중요하다.

# 확장성

- 성능 저하를 유발하는 흔한 이유는 부하 증가이다.
- 확장성은 증가한 부하에 대처하는 시스템 능력을 설명하는 데 사용하는 용어지만 시스템에 부여하는 일차원적인 표식이 아니다.
- 확장성을 논한다는 것은 “시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?”, “추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까?”이다.

## 부하 기술하기

- 시스템의 현재 부하를 간결하게 기술해야 한다. 그래야 부하 성장 질문(부하가 두 배로 되면 어떻게 될까?)를 논의할 수 있다.
- 부하는 **부하 매개변수(load parameter)**라 부르는 몇 개의 숫자로 나타낼 수 있다.
    - 적합한 부하 매개변수 선택은 시스템 설계에 따라 달라진다.
- 부하 매개변수로 웹 서버의 초당 요청 수, 데이터베이스의 읽기 대 쓰기 비율, 대화방의 동시 활성 사용자(active user), 캐시 적중률 등이 될 수 있다.
- 평균적인 경우가 중요할 수도 소수의 극단적인 경우가 명목 현상의 원인일 수도 있다.

### 트위터(Twitter) 예시

트위터의 두가지 동작

- 트윗(tweet) 작성
    - 사용자는 팔로워에게 새로운 메시지를 게시할 수 있다.
- 홈 타임라인(timeline)
    - 사용자는 팔로우한 사람이 작성한 트윗을 볼 수 있다(초당 300k 요청)

초당 12,000 건의 쓰기(피크일 때 작성 속도) 처리는 쉽다. 하지만 트위터의 확장성 문제는 주로 트윗 양이 아니라 팬 아웃(fan-out) 때문이다. 

1. 트윗 작성은 간단히 새로운 트윗을 트윗 전역 컬렉션에 삽입한다. 사용자가 자신의 홈 타임라인을 요청하면 팔로우하는 모든 사람을 찾고 이 사람들의 모든 트윗을 찾아 시간순으로 정렬해서 합친다.
    
    ```sql
    SELECT tweets.*, users.* FROM tweets
    	JOIN users ON tweets.sender_id = users.id
    	JOIN follows ON follows.followee_id = users.id
    	WHERE follows.folloer_id = current_user
    ```
    
2. 각 수신 사용자용 트윗 우편함처럼 개별 사용자의 홈 타임라인 캐시를 유지한다. 사용자가 트윗을 작성하면 해당 사용자를 팔로우하는 사람을 모두 찾고 팔로워 각자의 홈 타임라인 캐시에 새로운 트윗을 삽입한다. 그러면 홈 타임라인의 읽기 요청은 요청 결과를 미리 계산했기 때문에 비용이 저렴하다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/e9e97964-26b6-4f4a-bbf4-bde28019867e)

- 트위터는 처음에 접근 방식 1을 사용했지만 홈 타임라인 질의 부하를 버텨내기 위해 고군분투해야 했다. 그 결과 접근 2로 변경했다.
    - 평균적인 트윗 게시 요청량이 홈 타임 라인 읽기 요청량에 비해 수백배 적기 때문이다.
    - 쓰기 시점에에 더 많은 일을 하고 읽기 시점에 적은 일을 하는 것이 바람직하다.
- 접근 2방식의 단점
    - 트윗 작성이 많은 부가 작업을 필요하다.
    - 평균적으로 트윗은 약 75명 팔로워에게 전달되고 초당 4.6K 트윗은 홈 타임라인 캐시에 초당 345K 건의 쓰기가 된다. 하지만 일부 사용자는 3천만명이 넘어 단일 트윗이 3천만 건 이상의 쓰기 요청이 될 수도 있다.

트위터는 접근방식을 견고하게 구현한 두 접근 방식의 혼합형(hybrid)으로 바꾸고 있다. 대부분의 사용자는 접근 2 방식으로 진행되지만 일부 유명 인플루언서는 팬 아웃에서 제외된다. 사용자가 팔오우한 인플루언서의 트윗은 별도로 가져와 접근 1방식 처럼 읽는 시점에 사용자의 홈 타임라인에 합쳐진다.

## 성능 기술하기

부하가 증가할 때 일어날 일을 조사하는 방법

1. 부하 매개변수를 증가시키고 시스템 자원(CPU, 메모리, 네트워크 대역폭)은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?
2. 부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 많이 늘려야 할까?

두 방법모두 성능 수치가 필요하다.

하둡(Hadoop) 같은 일괄 처리 시스템은 보통 처리량(throughput, 초당 처리할 수 있는 레코드수나 일정 크기의 데이터 집합으로 작업을 수행할 때 걸리는 전체 시간)에 관심을 가지낟.

온라인 시스템에서 더 중요한 사항은 클라이언트가 요청을 보내고 응답을 받는 서비스 응답 시간(response time)에 관심을 갖는다.

<aside>
💡 지연 시간(latency)과 응답 시간(response time)
지연 시간과 응답 시간을 종종 같은 뜻으로 사용하지만 동일하지 않다. 응답시간은 클라이언트 관점으로 요청을 처리하는 실제 시간(서비스 시간) 외에도 네트워크 지연과 큐 지연도 포함한다. 지연 시간은 요청이 처리되길 기다리는 시간으로 서비스를 기다리며 휴지(latent) 상태인 시간을 말한다.

</aside>

응답시간은 매번 달라지므로 단일 숫자가 아니라 **측정 가능한 값의 분포**로 생각해야한다. 대부분의 요청은 꽤 빠르지만 가끔 꽤 오래 걸리는 특이 값(outlier)이 있다. 아마도 느린 요청은 더 많은 데이터를 처리하기 때문에 본질적으로 비싸곤 하다.

**지연이 발생하는 이유**

- 백그라운드 프로세스의 컨텍스트 스위치(context switch)
- 네트워크 패킷 손실과 TCP 재전송
- 가비지 컬렉션 휴지(harbage collection pause)
- 디스크에서 읽기를 강제하는 페이지 폴트(page fault)
- 서버 랙의 기계적인 진동이나 다른 여러원인으로 추가지연이 생길 수 있다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/814ddb66-7cde-45df-a203-9148fe28065a)

- 서비스의 평균 응답 시간을 살피는 일은 일반적이다.
    - 대개 산술 평균(arithmetic mean, n개 값이 주어진다면 모든 값을 더하고 n으로 나눔)
- 전형적인 응답 시간을 알고 싶다면 평균은 그다지 좋은 지표가 아니다. 얼마나 많은 사용자가 실제로 지연을 경험했는지 알려주지 않기 때문이었다.
- 평균보다 백분위(percentile)을 사용하는게 좋다. 중앙값(median)을 사용하는 것이다.
- 특이값을 알아보기 위해 95분위, 99분위, 99.9분위(p95, p99, p99.9) 응답시간을 확인해야 한다.
- 꼬리 지연 시간(tail latency)으로 알려진 상위 백분위 응답 시간은 서비스의 사용자 경험에 직접 영향을 주기 때문에 중요하다.
- 보통 응답 시간이 가장 느린 요청을 경험한 고객들은 많은 구매를 해서 고객 중에서 계정에 가장 많은 데이터를 가진 경우이다.
- 백분위는 서비스 수준 목표(service level objective, SLO)와 서비스 수준 협약서(service level agreement, SLA)에 자주 사용하고 기대 성능과 서비스 가용성을 정의하는 계약서에도 등장한다.
- 큐 대기 지연(queueing delay)은 높은 백분위에서 응답 시간의 상당 부분을 차지한다. 서버는 병렬로 소수의 작업을 처리하기 때문에 소수의 느린 요청 처리만으로도 후속 요청 처리가 지체된다. 이 현상을 선두 차단(head-of-line blocking)이라 한다.
    - 서버에서 후속 요청이 빠르게 처리되더라도 이전 요청이 완료되길 기다리는 시간 때문에 클라이언트는 전체적으로 응답 시간이 느리다고 생각한다.

## 부하 대응 접근 방식

사람들은 확장성과 관련해 용량 확장(scaling up)(수직 확장(vertical scaling) 좀 더 강력한 장비로 이동)과 규모 확장(scaling out)(수평 확장(horizontal scaling), 다수의 낮은 사양 장비에 부하를 분산)으로 구분한다.

다수의 장비에 부하를 분산하는 아키텍처를 비공유(shared-nothing) 아키텍처라고 부른다. 일부 시스템은 탄력적(elastic)이다. 즉 부하 증가를 감지하면 컴퓨팅 자원을 자동으로 추가할 수 있다.

statless 서비스를 배포하고 단일 노드에 상태 유지(stateful)하는 데이터 시스템을 분산 설치하는 것은 어렵다. 분산 시스템을 위한 도구와 추상화가 좋아지면서 이 통념이 적어도 일부 애플리케이션에서는 바뀌었다. 분산 데이터 시스템을 다루고 확장성있는 시스템을 만드는 것은 향후 기본 아키텍처로 자리 잡을 수 있다.

확장성을 갖춘 아키텍처가 특정 애플리케이션에 특화됐을지라도 이런 아키텍처는 보통 익숙한 패턴으로 나열된 범용적인 구성 요소로 구축한다.

# 유지보수성

레거시 소프트웨어를 직접 만들지 않도록 고려해야할 소프트웨어 시스템 설계 원칙

- 운용성(operability)
    - 운영팀이 시스템을 원활하게 운영할 수 있게 쉽게 만들어라
- 단순성(simplicity)
    - 시스템에서 복잡도를 최대한 제거해 새로운 엔지니어가 시스템을 이해하기 쉽게 만들어라
- 발전성(evolvability)
    - 엔지니어가 이후에 시스템을 쉽게 변경할 수 있게하라. 그래야 요구사항 변경 같은 예기치 않은 사용 사례를 적용하기 쉽다. 이 속성은 유연성(extensibility), 수정 가능성(modifiability), 적응성(plasticity)으로 알려져있다.

## 운용성: 운영의 편리함 만들기

운영 중 일부 측면은 자동화할 수 있고 또 자동화해야 한다. 

- 시스템 상태를 모니터링하고 상태가 좋지 않다면 빠르게 서비스를 복원
- 시스템 장애, 성능 저하 등의 문제의 원인을 추적
- 보안 패치를 포함해 소프트웨어와 플랫폼을 최신 상태로 유지
- 다른 시스템이 서로 어떻게 영향을 주는지 확인해 문제가 생길 수 있는 변경 사항을 손상을 입히기 전에 차단
- 미래에 발생 가능한 문제를 예측해 문제가 발생하기 전에 해결

좋은 운영성이란 동일하게 반복되는 태스크를 쉽게 수행하게끔 만들어 운영팀이 고부가가치 활동에 노력을 집중한다는 의미다.

- 모니터링 툴, 표준 도구를 이용해 자동화, 개별 장비 의존성 회피

## 단순성: 복잡도 관리

소규모 프로젝트는 간단하고 표현이 풍부한 코드로 말끔하게 시스템을 작성할 수 있지만 프로젝트가 커지면 시스템은 복잡하고 이해하기 어려워진다.

- 복잡도는 같은 시스템에서 작업해야 하는 모든 사람의 진행을 느리게하고 유지보수 비용이 증가한다.
- 복잡도 수렁에 빠진 소프트웨어 프로젝트를 커다란 진흙 덩어리(big ball of mud)로 묘사한다.

복잡도 때문에 시스템 유지보수가 어려울 대 예산과 일정이 초과되곤한다. 반대로 복잡도를 줄이면 소프트웨어 유지보수성이 크게 향상된다.

소프트퉤어가 풀어야 할 (사용자에게 보이는) 문제에 내재하고 있지 않고 구현에서만 발생하는 이우발적 복잡도(accidental complexity)를 줄인다는 뜻일 수 있다. 우발적 복잡도를 제거하기 위한 최상의 도구는 **추상화**다.

좋은 추상화는 깔끔하고 직관적인 외관 아래로 많은 세부 구현을 숨길 수 있다.

## 발전성: 변화를 쉽게 만들기

시스템의 요구사항은 끊임없이 변화할 가능성이 있다. 새로운 사실을 배우고 예기치 않은 사용 사례가 나타나고 비즈니스 우선순위가 바뀌고 사용자가 새로운 기능을 요청하고 새로운 플랫폼이 기존 플랫폼을 대체하고 법적 또는 규제 요구사항이 변경될 수 있다.

애자일(agile) 작업 패턴은 변화를 적응하기 위한 프레임워크를 제공한다. TDD, 리팩토링 같이 자주 변화하는 환경에서 소프트웨어를 개발할 때 도움이되는 기술이 있다.

데이터 시스템 변경을 쉽게 하고 변화된 요구사항에 시스템을 맞추는 방법은 시스템의 간단함과 추상화와 밀접한 관련이 있다.

# 정리

애플리케이션이 유용하려면 다양한 요구사항을 충족시켜야 한다.

- 기능적 요구사항(여러 방법으로 데이터를 저장하고 조회하고 검색하고 처리하게끔 허용하는 작업)
- 비기능적 요구사항(보안, 신뢰성, 법규 준수, 확장성, 호환성, 유지보수성과 같은 일반 속성)
- 신뢰성
    - 결함이 발생해도 시스템이 올바르게 동작
    - 결함은 소프트웨어 버그와 사람에게 있을 수 있다.
    - 내결함성 기술은 최종 사용자에게 특정 유형의 결함을 숨길 수 있게 만든다.
- 확장성
    - 부하가 증가해도 좋은 성능을 유지하기 위한 전략을 의미한다.
    - 양적으로 부하와 성능을 설명할 수 있어야 한다.
    - 확장 가능한 시스템에서는 부하가 높은 상태에서 신뢰성을 유지하기 위해 처리 용량을 추가할 수 있다.
- 유지보수성
    - 시스템에서 작업하는 엔지니어와 운영팀의 삶을 개선하는 데 있다.
    - 좋은 추상화는 복잡도를 줄이고 쉽게 시스템을 변경할 수 있게 해야한다.
