## 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 어플리케이션

**신뢰할 수 있고, 확장가능하며, 유지보수하기 쉬운** 데이터 시스템을 구축하기 위한 방법을 알아보자.

데이터 중심 어플리케이션 : 공통으로 필요로 하는 기능을 제공하는 표준 구성 요소로 이루어짐

- 데이터베이스
- 캐시
- 검색 색인(Search Index)
- 스트림 처리(Stream Processing)
- 일괄 처리(Batch Processing)

### 데이터 시스템에 대한 생각

일반적으로 DB, Queue, Cache는 각각 “데이터를 저장”한다는 특징이 있지만 사용하는 접근방식이나 용도가 다르다.

그럼에도 왜 모든것을 “데이터 시스템”이라고 묶어야 하는가?

1. 새로운 도구들은 다양한 사용사례에 최적화되었기 때문에 더 이상 전통적인 분류에 딱 들어맞지 않는다.
```
Redis as Message queue, DB처럼 durability를 제공하는 메시지 큐인 Kafka 등
```
2. 단일 도구로는 더 이상 데이터 처리와 저장 모두를 만족시킬 수 없는 광범위한 요구사항이 많아졌다. 단일 프로세스에서 수행 할 수 있는 작업 단위로 분리 후 각 도구(프로세스)를 결합하여 이용한다.
```
메인 DB / 앱계층 전용 캐시 / ElasticSearch 등 검색 서버를 sync하여 사용
```

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/0f54d8ae-e956-4edf-8ba7-db95a308e582)

이처럼 데이터 시스템이나 서비스를 설계할 때 까다로운 문제가 많이 생긴다.

내부적으로 문제가 있어도 데이터를 정확하고 완전하게 유지하려면 어떻게 해야할지, 시스템의 일부 성능이 저하되더라도 클라이언트에 일관되게 좋은 성능을 제공할 수 있는지? 등

실무자의 기술 숙련도, 기존 시스템의 의존성, 전달 시간 척도, 다양한 종류의 위험에 대한 조직의 내성, 규제 제약 등은 시스템 설계에 영향을 줄 수 있는 많은 요소다.

신뢰할 수 있는 시스템을 구축하는 세 가지 키워드
- `신뢰성(Reliablility)` : 여러 문제들을 직면하게 되더라도 시스템은 지속적으로 올바르게 동작해야 한다.
- `확장성(Scalability)` : 시스템의 데이터 양, 트래픽 양, 복잡도가 증가할 떄 이를 처리할 적절한 방법이 있어야 한다.
- `유지보수성(Maintainability)` : 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있게 해야 한다.



## 신뢰성

> 결함이 발생해도 시스템이 올바르게 동작하는 것

잘못될 수 있는 일을 결함(fault)이라 부른다. (결함, fault != 장애, failure)
<br>그리고 결함을 예측하고 대처할 수 있는 시스템을 내결함성(fault-tolerant) 또는 탄력성(resilient)을 지녔다라고 말한다.

> [고의적으로 내결함성을 훈련하고 테스트 하는 넷플릭스의 chaos monkey](https://github.com/codecentric/chaos-monkey-spring-boot)

### 해결책이 있는 결함유형
| 유형 | 방안 | 예시 | 
|:--:|:--|:--|
| 하드웨어 결함 | 각 하드웨어 구성요소의 이중화 | 디스크 raid 구성, 이중전원, hot-swap 가능한 cpu, 데이터센터의 예비 발전기 구축|
| 소프트웨어 오류 | 신속한 해결책은 없고, 여러 작은 작업이 문제 해결에 도움이 됨 | 프로세스 격리, 프로세스 재시작 허용, 빈틈없는 테스트, 모니터링, 로깅...|
| 휴먼 에러 | 에러의 75~90% 원인 | 방어로직 설계, 시스템 환경 격리 운영, 단위테스트-E2E 테스트 까지 운영하기 및 테스트 자동화, 배포 롤백도구 이용, 모니터링 도구(알람, 메트릭), 조작교육과 실습 |

## 확장성

> 부하가 증가해도 좋은 성능을 유지하는 것

### 부하 기술하기

- 가장 적합한 부하 매개변수(load parameter)은 시스템 설계에 따라 달라진다.
- 웹서버의 TPS, 데이터베이스의 읽기 대 쓰기 비율, 동시 활성자 수(active user), 캐시 적중률 등

### 성능 기술하기

기술된 부하를 기준으로 부하가 증가할 때 어떤 일이 일어나는지 조사할 수 있다.

- 부하 매개변수를 증가시키고 시스템 자원(CPU, 메모리, 네트워크 대역폭 등)은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?
- 부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 많이 늘려야 할까?

- 성능 수치
- 처리량(throughtput)
  - 초당 처리할 수 있는 레코드 수나 일정 크기의 데이터 집합으로 작업을 수행할 때 걸리는 전체 시간
  - 하둡 같은 일괄 처리 시스템에서 사용하는 지표
- 응답시간(response time)
  - 온라인 시스템에서 더 중요한 사항은 서비스 응답시간(TPS)과 지연시간(latency)
  - 클라이언트가 동일한 요청을 하더라도 매번 응답 시간이 다르다
    - 그러므로 응답 시간은 단일 숫자가 아니라 측정 가능한 값의 분포로 생각해야 한다.
    - 추가지연을 유발 할 수 있는 원인은 백그라운드 프로세스의 컨텍스트 스위치, 네트워크 패킷 손실과 TCP 재전송, GC pause, 디스크에서 읽기를 강제하는 페이지 폴트(page fault) 등이 있다.
    - 얼마나 많은 사용자가 지연을 경험했는지 알려주지 않기 때문에 평균 응답 시간은 좋은 지표가 아니다.
    - 일반적인 평균보다는 백분위(percentile)을 사용하는 편이 좋다.

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/dc59260c-6403-4a2f-bbfd-28bd68c3ded7)


- 중앙값(median, p50): 사용자가 보통 얼마나 오랫동안 기다려야 하는지
- 95분위, 99분위, 99.9분위: 상위 느린 요청들에 대한 집합 분포, 특이 값이 얼마나 좋지 않은지

 
![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/fd374a79-4934-4631-a802-cf8a5e7e1e66)

- 꼬리 지연 시간(tail latency)
  - 상위 백분위 응답시간은 서비스의 사용자 경험에 직접 영향을 주기 때문에 중요하다.
  - 최상위 백분위는 통제할 수 없는 임의 이벤트에 쉽게 영향을 받기 떄문에 응답 시간을 줄이기가 매우 어려워 이점은 더욱 줄어든다.
  - 99.99분위(가장 느린 1건)를 최적화하는 작업에는 비용이 너무 많이 들어서 아마존이 추구하는 목표에 충분히 이익을 가져다주지 못한다고 여겨진다.
- 꼬리지연증폭: 병렬로 호출해도 최종 사용자 요청은 여전히 병렬 호출 중 가장 느린 호출이 완료되길 기다려야 한다. 그래서 최종 사용자 요청 중 많은 비율의 응답 시간이 결국 느려진다.
- 선두 차단(Head of Line Blocking)
  - 큐 대기 지연(Queueing delay)는 응답시간의 상당부분을 차지한다.
  - 서버는 병렬로 소수의 작업을 처리 할 수 있기 때문에(CPU 코어수의 한계) 소수의 느린 처리로도 후속 요청 처리가 지체된다.
  - 이 때문에 인위적으로 부하를 생성시에는 지속적으로 요청을 보내야 한다.

> 비동기 서비스에서 백분위의 의미가 있을까?


### 부하 대응 접근 방식

- scaling up (vertical scaling): 고스펙 장비로 변경
- scaling out (horizontal scaling): 여러 대의 장비에 부하를 분산비공유(shared-nothing) 아키텍처라 부른다.


- 탄력적(elastic): 부하 증가를 감지하면 컴퓨팅 자원을 자동으로 추가할 수 있다.
- 수동 확장 : 탄력적인 시스템은 부하를 예측할 수 없기 때문에 매우 유용하지만, 수동 확장이 더 간단하고 운영상 예상치 못한 일이 더 적다

  
## 유지보수성

> 시간이 지나도 엔지니어가 시스템 상에서 생산적으로 작업할 수 있는 것

레거시 소프트웨어를 직접 만들지 않기 위한 소프트웨어 시스템 설계원칙 세가지

- `운용성(operability)` : 운영팀이 시스템을 원활하게 운영할 수 있게 쉽게 만들어라.
- `단순성(simplicity)` : 시스템에서 복잡도를 최대한 제거해 새로운 엔지니어가 시스템을 이해하기 쉽게 만들어라.
- `발전성(evolvability)` : 엔지니어가 이후에 시스템을 쉽게 변경할 수 있게 하라.

### 운용성

좋은 운영팀의 책임

- 시스템 상태 모니터링 후 문제 발견시 빠르게 서비스 복원 가능
- 시스템 장애 및 성능 저하의 원인 추적
- 보안 패치 등 소프트웨어와 플랫폼 최신 상태 유지
- 배포, 설정 관리 등을 위한 모범 사례와 도구 마련
- 마이그레이션, 설정 변경 등에서 유지보수
- 개인 인사 이동에도 시스템에 대한 조직의 지식보존(인수인계)

### 단순성

- 응집도는 높이고 결합도는 낮춰야한다
- 좋은 추상화를 통해 재사용성과 효율성을 확보해야한다

  
### 발전성
- 애자일 작업 패턴을 통해 변화에 적응하기 위한 프레임워크를 제공
- TDD와 리팩토링 같이 자주 변화하는 환경에서 소프트웨어를 개발할 때 도움이 되는 기술 적용

## 정리

- **신뢰성** : 결함이 발생해도 시스템이 올바르게 동작하게 만드는 것
- **확장성** : 부하가 증가해도 좋은 성능을 유지하기 위한 전략
- **유지보수성** : 시스템에서 작업하는 엔지니어와 운영 팀의 더 나은 개발 환경을 만들어주는 것

**물론 애플리케이션을 신뢰할 수 있고 확장 가능하며 유지보수하기 쉽게 만들어주는 간단한 해결책은 없다.**
하지만 특정 패턴과 기술이 도움을 줄 수 있다.
