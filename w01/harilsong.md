# 01. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션

오늘날 애플리케이션은 데이터 중심적이다. CPU 성능 보다는 보통 데이터의 양, 데이터의 복잡도, 데이터의 변화 속도가 문제가 된다.

## 데이터 시스템에 대한 생각

데이터베이스, 큐, 캐시 등은 매우 다른 접근 패턴을 갖고 있어 서로 다른 성능 특성이 있기 때문에 구현 방식이 매우 다르다.

그렇다면 왜 모든 것을 **데이터 시스템** 이라는 포괄적 용어로 묶어야 할까?

1. 최근 등장하는 도구들은 다양한 사용 사례에 최적화 됐기 때문에 더 이상 전통적인 분류에 딱 들어맞지 않는다.
2. 점점 더 많은 애플리케이션이 단일 도구로는 더 이상 데이터 처리와 저장 모두를 만족시킬 수 없는 과도하고 광범위한 요구사항을 갖고 있다.

## 신뢰성

- 애플리케이션은 사용자가 기대한 기능을 수행한다
- 시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용할 수 있다
- 시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족한다
- 시스템은 허가되지 않은 접근과 오남용을 방지한다

잘못될 수 있는 일을 결함(fault)이라고 부른다. 그리고 결함을 예측하고 대처할 수 있는 시스템을 내결함성(fault-tolerant) 또는 탄력성(resilient) 을 지녔다고 말한다.

결함은 장애(failure)와 동일하지 않다.

- 결함: 사양에서 벗어난 시스템의 한 구성 요소
- 장애: 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우

내결함성 시스템에서 경고 없이 개별 프로세스를 무작위로 죽이는 것과 같이 고의적으로 결함을 일으켜 결함률을 증가시키는 방법은 납득할 만하다. 실제로 많은 중대한 버그는 미흡한 오류 처리에 기인한다. 고의적으로 결함을
유도함으로써 내결함성 시스템을 지속적으로 훈련하고 테스트해서 결함이 자연적으로 발생했을 때 올바르게 처리할 수 있다는 자신감을 높인다. 넷플릭스(Netflix)의 카오스 몽키(Chaos Monkey)가 이러한 접근
방식의 한 예다.

- Java 의 픽스쳐 몽키(Fixture Monkey) 는 카오스 몽키의 오마주이다.

### 하드웨어 결함

10,000 개의 디스크로 구성된 저장 클러스틑 평균적으로 하루에 한 개의 디스크가 죽는다고 예상한다.

과거의 일반적인 대응은 다음과 같았다.

- 디스크를 RAID 구성으로 설치
- 서버는 이중 전원 디바이스와 핫 스왑 가능한 CPU 를 사용
- 데이터센턴느 건전지와 예비 전원용 디젤 발전기를 갖춤

구성 요소 하나가 죽으면 고장난 구성 요소가 교체되는 동안 중복된 구성 요소를 대신 사용할 수 있다. 이런 접근 방식은 하드웨어 문제로 장애가 발생하는 것을 완전히 막을 수는 없지만 이해하기 쉽고 보통 수년 간
장비가 중단되지 않고 계속 동작할 수 있게 한다.

AWS 같은 일부 클라우드 플랫폼은 단일 장비 신뢰성보다 유연성과 탄력성을 우선적으로 처리하게끔 설계되었기 때문에 별도의 경고 없이 사용할 수 없게 되는 상황이 상당히 일반적이다. 따라서 소프트웨어 내결함성 기술을
사용하거나 하드웨어 중복성을 추가해 전체 장비의 손실을 견딜 수 있는 시스템으로 점점 옮겨가고 있다.

### 소프트웨어 오류

소프트웨어 결함을 유발하는 버그는 특정 상황에 의해 발생하기 전까지 오랫동안 나타나지 않는다. 소프트웨어의 체계적 오류 문제는 신속한 해결책이 없다. 시스템의 가정과 상호작용에 대해 주의 깊게 생각하기, 빈틈없는
테스트, 프로세스 격리, 죽은 프로세스의 재시작 허용, 프로덕션 환경에서 시스템 동작의 측정, 모니터링, 분석하기와 같은 여러 작은 일들이 문제 해결에 도움을 줄 수 있다.

### 인적 오류

대규모 인터넷 서비스에 대한 한 연구에 따르면 운영자의 설정 오류가 중단의 주요 원인인 반면 하드웨어 결함은 중단 원인의 10~25% 정도에 그친다.

사람이 미덥지 않음에도 시스템을 어떻게 신뢰성 있게 만들까? 최고의 시스템은 다양한 접근 방식을 결합한다.

- 오류의 가능성을 최소화하는 방향으로 시스템을 설계하라
- 사람이 가장 많이 실수하는 장소(부분)에서 사람의 실수로 장애가 발생할 수 있는 부분을 분리하라
- 단위 테스트부터 전체 시스템 통합 테스트와 수동 테스트까지 모든 수준에서 철저하게 테스트하라
- 장애 발생의 영향을 최소화하기 위해 인적 오류를 빠르고 쉽게 복구할 수 있게 하라
- 성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책을 마련하라
- 조작 교육과 실습을 시행하라

### 신뢰성은 얼마나 중요할까?

비즈니스 애플리케이션에서 버그는 생산성 저하의 원인이고 전자 상거래 사이트의 중단은 매출에 손실이 발생하고 명성에 타격을 준다는 면에서 많은 비용이 든다.

증명되지 않은 시장을 위해 시제품을 개발하는 비용이나 매우 작은 이익률의 서비스를 운영하는 비용을 줄이려 신뢰성을 희생해야 하는 상황이 있다. 하지만 이 경우에는 비용을 줄여야 하는 시점을 매우 잘 알고 있어야
한다.

## 확장성

확장성은 시스템의 부하가 증가함에 따라 어떻게 대처할 것인가에 대한 문제이다. 확장성은 증가한 부하에 대처하는 시스템 능력을 설명하는 데 사용하는 용어지만 시스템에 부여하는 일차원적인 표식이 아님을 주의하자.
확장성을 논한다는 것은 "시스템이 특정 방식으로 커지면 이에 대처하기 위한 선택은 무엇인가?"와 "추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까?"같은 질문을 고려한다는 의미다.

### 부하 기술하기

무엇보다 시스템의 현재 부하를 간결하게 기술해야 한다. 그래야 부하 성장 질문(부하가 두 배로 되면 어떻게 될까?)를 논의할 수 있다. 부하는 **부하 매개변수(load parameter)** 라 부르는몇 개의
숫자로 나타낼 수 있다.

- 웹 서버의 초당 요청 수
- 데이터베이스의 읽기 대 쓰기 비율
- 캐시의 적중률
- 동시 활성 사용자

트위터를 예로 살펴보자

- 트윗 작성: 사용자는 팔로워에게 새로운 메시지를 게시할 수 있다(평균 초당 4.6k 요청, 피크일 때 초당 12k 요청 이상)
- 타임라인: 사용자는 팔로우한 사람이 작성한 트윗을 볼 수 있다(초당 300k 요청)

단순히 초당 12,000건의 쓰기 처리는 상당히 쉽다. 트위터의 확장성 문제는 주로 트윗 양이 아닌 팬 아웃(fan-out) 때문이다. 개별 사용자는 많은 사람을 팔로우하고 많은 사람이 개별 사용자를 팔로우한다. 이
두 가지 동작을 구현하는 방법은 크게 두 가지다.

1. 트윗 작성은 간단히 새로운 트윗을 전역 컬렉션에 삽입한다. 사용자가 자신의 타임라인을 요청하면 팔로우하는 모든 사람을 찾고, 이 사람들의 모든 트윗을 찾아 시간순으로 정렬해서 합친다. 관계형 데이터베이스에서는
   다음과 같이 질의를 작성한다.

   ```sql
   SELECT tweets.*, users.*
   FROM tweets
            JOIN users ON tweets.sender_id = users.id
            JOIN follows ON follows.followee_id = users.id
   WHERE follows.follower_id = current_user
   ```

2. 각 수신 사용자용 트윗 우편함처럼 개별 사용자의 타임라인 캐시를 유지한다. 사용자가 트윗을 작성하면 해당 사용자를 팔로우하는 사람을 모두 찾고 팔로워 각자의 홈 타임라인 캐시에 새로운 트윗을 삽입한다. 그러면 타임라인의 읽기 요청은 요청 결과를 미리 계산했기 때문에 비용이 저렴하다(= 속도가 빠르다).

2번의 방식은 사용자가 많아질 경우 1번에 비해 훨씬 잘 동작한다. 하지만 접근 방식 2의 불리한 점은 이제 트윗 작성이 많은 부가 작업을 필요로 한다는 점이다. 일부 사용자는 팔로워가 3천만 명이 넘는다. 이것은 단일 트윗이 홈 타임라인에 3천만 건 이상의 쓰기 요청이 될지도 모른다는 의미다. 적시에 트윗을 전송하는 작업이 중요한 도전 과제다.

최종적으로는 혼합 방식을 사용한다. 대부분 사용자의 트윗은 계속해서 사람들이 작성할 때 타임라인에 펼쳐지지만 팔로워 수가 매우 많은 소수 사용자는 팬 아웃에서 제외된다. 사용자가 팔로우한 유명인의 트윗은 별도로 가져와 접근 방식 1처럼 읽는 시점에 사용자의 홈 타임라인에 합친다. 이 혼합형 접근 방식은 좋은 성능으로 지속적인 전송이 가능하다.

### 성능 기술하기

- 부하 매개변수를 증가시키고 시스템 자원은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?
- 부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 많이 늘려야 할까?

하둡과 같은 일괄 처리 시스템은 보통 처리량에 관심을 가지고, 온라인 시스템에서 더 중요한 사항은 서비스 응답 시간, 즉 클라이언트가 요청을 보내고 응답을 받는 사이의 시간이다.

평균 응답 시간을 살피는 일은 일반적이다. 전형적인 응답 시간을 알고 싶다면 평균은 그다지 좋은 지표가 아니다. 얼마나 많은 사용자가 실제로 지연을 경험했는지 알려주지 않기 때문이다.

일반적으로 평균보다는 **백분위(percentile)** 를 사용하는 편이 더 좋다. 응답 시간 목록을 가지고 가장 빠른 시간부터 제일 느린 시간까지 정렬하면 중간 지점이 **중앙값(median)** 이 된다. 예를 들어, 중간 응답 시간이 200밀리초면 요청의 반은 200밀리초 미만으로 반환되고 나머지 반은 그보다 오래 걸린다는 뜻이다.

사용자가 보통 얼마나 오랫동안 기다려야 하는지 알고 싶다면 중앙값이 좋은 지표다. 중앙값은 50분위로서 p50 으로 축약할 수 있다.

특이 값이 얼마나 좋지 않은지 알아보려면 상위 백분위를 살펴보는 것도 좋다.

**꼬리 지연 시간(tail latency)** 로 알려진 상위 백분위 응답 시간은 서비스의 사용자 경험에 직접 영향을 주기 때문에 중요하다. 예를 들어 아마존은 내부 서비스의 응답 시간 요구사항을 99.9분위로 기술한다. 99.9분위는 요청 1,000개 중 1개만 영향이 있음에도 말이다. 아마존은 응답 시간이 100 밀리초 증가하면 판매량이 1% 줄어들고 1초가 느려지면 고객의 만족도는 16% 줄어드는 현상을 관찰했다.

반면 99.99분위(10,000건의 요청 중 가장 느린 1건)를 최적화하는 작업에는 비용이 너무 많이 들어서 아마존이 추구하는 목표에 충분히 이익을 가져다주지 못한다고 여겨진다. 최상위 백분위는 통제할 수 없는 임의 이벤트에 쉽게 영향을 받기 때문에 응답 시간을 줄이기가 매우 어려워 이점은 더욱 줄어든다.

큐 대기 지연은 높은 백분위에서 응답 시간의 상당 부분을 차지한다. 서버는 병렬로 소수의 작업만 처리할 수 있기 때문에 소수의 느린 요청 처리만으로도 후속 요청 처리가 지체된다. 이 현상을 선두 차단(head-of-line blocking) 이라 한다. 서버에서 후속 요청이 빠르게 처리되더라도 이전 요청이 완료되길 기다리는 시간 때문에 클라이언트는 전체적으로 응답시간이 느리다고 생각할 것이다. 이런 문제 때문에 클라이언트 쪽 응답 시간 측정이 중요하다.

### 부하 대응 접근 방식

- 용량 확장
- 규모 확장
- 탄력적

이 책의 나머지 부분에서 설명한다..

스타트업 초기 단계나 검증되지 않은 제품의 경우에 미래를 가정한 부하에 대비해 확장하기보다는 빠르게 반복해서 제품 기능을 개선하는 작업이 좀 더 중요하다.

## 유지보수성

소프트웨어 비용의 대부분은 초기 개발이 아니라 지속해서 이어지는 유지보수에 들어간다는 사실은 잘 알려져 있다.

- 버그 수정
- 시스템 운영 유지
- 장애 조사
- 새로운 플랫폼 적응
- 새 사용 사례를 위한 변경
- 기술 채무 상환
- 새로운 기능 추가

레거시 소프트웨어를 직접 만들지 않게끔 주의를 기울여야 할 소프트웨어 시스템 설계 원칙은 다음 세 가지다.

- 운용성
- 단순성
- 발전성

### 운용성: 운영의 편리함 만들기

시스템이 지속해서 원활하게 작동하려면 운영팀이 필수다. 좋은 운영팀은 일반적으로 다음과 같은 작업 등을 책임진다.

- 시스템 상태를 모니터링하고 상태가 좋지 않다면 빠르게 서비스를 복원
- 시스템 장애, 성능 저하 등의 문제의 원인을 추적
- 보안 패치를 포함해 소프트웨어와 플랫폼을 최신 상태로 유지
- 다른 시스템이 서로 어떻게 영향을 주는지 확인해 문제가 생길 수 있는 변경 사항을 사전 차단
- 발생 가능한 문제를 예측해 문제가 발생하기 전에 해결(예를 들어 용량 계획)
- 배포, 설정 관리 등을 위한 모범 사례와 도구를 마련
- 애플리케이션을 특정 플랫폼에서 다른 플랫폼으로 이동하는 등 복잡한 유지보수 태스크를 수행
- 설정 변경으로 생기는 시스템 보안 유지보수
- 예측 가능한 운영과 안정적인 서비스 환경을 유지하기 위한 절차 정의
- 개인 인사 이동에도 시스템에 대한 조직의 지식을 보존함

좋은 운영성이란 동일하게 반복되는 태스크를 쉽게 수행하게끔 만들어 운영팀이 고부가가치 활동에 노력을 집중한다는 의미다. 데이터 시스템은 동일 반복 태스크를 쉽게 하기 위해 아래 항목 등을 포함해 다양한 일을 할 수 있다.

- 좋은 모니터링으로 런타임 동작과 시스템 내부에 대한 가시성 제공
- 표준 도구를 이용해 자동화와 통합을 위한 우수한 자원을 제공
- 개별 장비 의존성을 회피, 유지보수를 위해 장비를 내리더라도 시스템 전체에 영향을 주지 않고 계속해서 운영 가능해야 함
- 좋은 문서와 이해하기 쉬운 운영 모델 제공
- 만족할 만한 기본 동작을 제공하고, 필요할 때 기본값을 다시 정의할 수 있는 자유를 관리자에게 부여
- 적절하게 자기 회복이 가능할 뿐 아니라 필요에 따라 관리자가 시스템 상태를 수동으로 제어할 수 있게 함
- 예측 가능하게 동작하고 예기치 않은 상황을 최소화함

### 단순성: 복잡도 관리

복잡도는 같은 시스템에서 작업해야 하는 모든 사람의 진행을 느리게 하고 나아가 유지보수 비용이 증가한다.

복잡도는 다양한 증상으로 나타난다.

- 상태 공간의 급증
- 모듈 간 강한 커플링
- 복잡한 의존성
- 일관성 없는 naming 과 용어
- 성능 문제 해결을 목표로 한 해킹
- 임시방편으로 문제를 해결한 특수 사례

증가하는 복잡도는 소프트웨어에서 변경이 발생할 때 버그가 생길 위험이 더 크다. 반대로 복잡도를 줄이면 소프트웨어 유지보수성이 크게 향상된다. 따라서 단순성이 구축하려는 시스템의 핵심 목표여야 한다.

시스템을 단순하게 만드는 일이 반드시 기능을 줄인다는 의미는 아니다. 우발적 복잡도를 줄인다는 뜻일 수도 있다.

우발적 복잡도를 제거하기 위한 최상의 도구는 **추상화**다. 좋은 추상화는 깔끔하고 직관적인 외관 아래로 많은 세부 구현을 숨길 수 있다.

책 전반에 걸쳐 좋은 추상화를 눈여겨볼 것이다.

### 발전성: 변화를 쉽게 만들기

시스템의 요구사항은 끊임없이 변화한다. 비즈니스 우선순위가 바뀌고 사용자가 새로운 기능을 요청하고 법적 또는 규제 요구사항이 변경되고 시스템의 성장으로 인한 아키텍처 변화 등이 이런 요구사항에 해당한다.

조직 프로세스 측면에서 **애자일(agile)** 작업 패턴은 변화에 적응하기 위한 프레임워크를 제공한다. 애자일 기법에 대한 설명은 대부분 매우 작고, 로컬 규모에 초점을 맞추고 있다.

## 정리
