
# 1. 신뢰할 수 있고 확장 가능하며 유지하기 쉬운 어플리케이션


오늘날 많은 애플리케이션은 `계산 중심(compute-intensive)`과는 다르게 `데이터 중심적(data-intensive)`이다.
이러한 애플리케이션의 경우 CPU 성능은 애플리케이션을 제한하는 요소가 아니며, 보통 `데이터의 양, 데이터의 복잡도, 데이터의 변화 속도가 애플리케이션의 병목`이다.

애플리케이션이 필요로 하는 데이터 처리 기능들
- 데이터베이스: 구동 애플리케이션 또는 다른 애플리케이션에서 나중에 데이터를 다시 찾을 수 있도록 저장
- 캐시: 읽기 속도 향상을 위해 값비싼 결과를 기억
- 검색 색인: 사용자가 키워드로 데이터를 검색하거나 다양한 방법으로 필터링할 수 있게 제공
- 스트림 처리: 비동기 처리를 위해 다른 프로세스로 메시지 보내기
- 배치 처리: 주기적으로 대량의 누적된 데이터 처리



## 1.1. 데이터 시스템에 대한 생각

일반적으로 데이터베이스, 큐, 캐시 등을 매우 다른 범주에 속하는 도구로 생각한다.
- 요즘의 새로운 도구들은 다양한 사용 사례에 최적화 되었고 전통적인 분류에 딱 들어맞지 않는다.
	- Redis: 캐시로도 메시지큐로도 활용할 수 있다.

요즘의 개발자는 애플리케이션 개발자일뿐만 아니라 데이터 시스템 설계자이기도 하다.
- 아래 그림 1-1. 처럼 다양한 데이터 도구를 애플리케이션 코드를 이용해 연결한다.


![alt](image/1.1.다양한%20구성%20요소를%20결합한%20데이터%20시스템%20아키텍처의%20예.png)

![[1.1.다양한 구성 요소를 결합한 데이터 시스템 아키텍처의 예.png]]

데이터 시스템 설계 시 까다로운 점들
1. 내부 결함이 발생해도 데이터를 정확하고 완전하게 유지하기
2. 시스템의 일부 성능이 저하되더라도 클라이언트에게 일과된 성능 제공하기
3. 부하 증가시 확장 고려
4. 데이터 시스템 연결을 위한 API 정의


- 신뢰성 (Reliability)
```text
하드웨어나 소프트웨어 결함, 심지어 인적 오류같은 상황에 직면하더라도 시스템은 지속적으로 올바르게 동작(원하는 성능 수준에서 정확한 기능을 수행)해야 한다. 
```
- 확장성 (Scalability)
```text
시스템의 데이터 양, 트래픽 양, 복잡도가 증가할 경우 이를 처리할 수 있는 적절한 방법이 있어야 한다.
```
- 유지보수성 (Maintainability)
```text
시간이 지남에 따라 여러 다양한 사람들이 시스템 상에서 작업(유지보수 및 개선)할 것이기 때문에 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있어야 한다.
```



## 1.2. 신뢰성

소프트웨어에 대한 일반적인 기대
- 애플리케이션은 사용자가 기대한 기능을 수행한다.
- 시스템은 사용자가 범한 실수나 예상치 못한 소프트웨어 사용법을 허용할 수 있다.
- 시스템 성능은 예상된 부하와 데이터 양에서 필수적인 사용 사례를 충분히 만족한다.
- 시스템은 허가되지 않은 접근과 오남용을 방지한다.

신뢰성: 무언가 잘못되더라도 지속적으로 올바르게 동작함

잘못될 수 있는 일을 결함(fault)이라 한다.
그리고 결함을 예측하고 대처할 수 있는 시스템을 내결함성(fault-tolerant) 또는 탄력성(resilient)이 있다고 말한다.
- 모든 종류의 결함을 견딜 수 있는 시스템은 없다. 특정 유형의 결함 내성에 대해서만 이야기하는 것이 타당하다.

결함은 장애(failure)와 동일하지 않다.
- 일반적으로 결함은 사양에서 벗어난 시스템의 한 구성 요소로 정의되지만, 장애는 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우다.

결함 예방을 넘어 내결함성을 갖기를 선호하지만 보안 문제는 예방이 중요하다.


### 1.2.1. 하드웨어 결함
- 하드디스크 고장, 램에 결함, 대규모 정전 사태, 네트워크 케이블 뽑힘 등
- 하드웨어 결함에 대응하기 위해 하드웨어 구성 요소에 예비 장비를 추가하는 것이 일반적이다.
	- 디스크 RAID, 이중 전원, 핫스왑 CPU, 발전기 준비 등


#### 1.2.2. 소프트웨어 오류

소프트웨어 오류 예시
- 잘못된 특정 입력이 있을 때 모든 애플리케이션 서버 인스턴스가 죽는 소프트웨어 버그
- CPU 시간, 메모리, 디스크 공간, 네트워크 대역폭 처럼 공유 자원을 과도하게 사용하는 일부 프로세스
- 시스템의 속도가 느려져 반응이 없거나 잘못된 응답을 반환하는 서비스
- 한 구성 요소의 작은 결함이 다른 구성 요소의 결함을 야기하고 차례차례 더 많은 결함이 발생하는 연쇄 장애


예방 방법 (잘 만들고 모니터링 한다)
- 시스템의 가정과 상호작용에 대해 주의 깊게 생각하기
- 빈틈 없는 테스트
- 프로세스 격리
- 죽은 프로세스의 재시작 허용
- 운영 환경에서 시스템 동작의 측정, 모니터링, 분석
- 시스템이 기대하는 행동을 정의하고 기대값이 다를 경우 Alert 발생 (ex. 메시지 큐에 수신된 메시지 수 = 송신된 메시지 수)


### 1.2.3. 인적 오류

인터넷 서비스에 대한 연구에 다르면 하드웨어 결함은 중단 원인의 10~25% 정도라고 한다.
- 나머지는 소프트웨어 오류와 운영자의 잘못된 설정 같은 인적 오류이다.

인적오류 에방 하기
- 오류의 가능성을 최소화 하는 방향으로 시스템 설계: 잘 설계된 추성화, API, 관리 인터페이스
- 비 프로덕션 샌드박스 제공 (개발, 테스트 환경)
- 철저한 단위, 통합테스트
- 장애 발생의 영향을 쉽게 복구할 수 있도록 만들기 (Roll back), 새로운 코드는 유저 그룹, 서버 Node 등을 나눠 서서히 Roll Out
- 성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책 마련
- 조직 교육과 실습 시행


### 1.2.4. 신뢰성은 얼마나 중요할까?

상황에 따라 다르다.
- 대규모 전자 상거래 사이트: 중단 시 매출에 손실이 생기고 명성에 타격을 받을 수도 있으며 때때로 보상도 해야한다.
- 시제품 개발: 증명되지 않은 시장에서 시제품을 개발하는 경우 신뢰성을 희생하고 빠른 개발부터 진행할 수 있다.



## 1.3. 확장성

시스템이 현재 안정적으로 동작한다고 해서 미래에도 안정적으로 동작한다는 보장은 없다.
- 성능 저하를 유발하는 흔한 이유: 부하 증가 (ex. 사용자 10만 명 -> 1000만 명)

확장성은 
- 시스템이 특정 방식으로 커지면 이에 대처하기 위해 어떤 선택을 할 것인가?
- 추가 부하를 다루기 위해 계산 자원을 어떻게 투입할까?

### 1.3.1. 부하 기술하기

먼저 시스템의 현재 부하를 간결하게 기술해야한다.
그래야 부하 성장 질문 (부하가 두 배로 되면 어떻게 할 것인가?)을 논의할 수 있다.

부하 매개변수 (load parameter) 예시
- 웹 서버의 초당 요청 수
- 데이터베이스의 읽기 대 쓰기 비율
- 대화방의 동시 활성 사용자 수
- 캐시 적중률 등
부하 매개변수 선택은 시스템 설계에 따라 달라지고 경우에 따라 평균적인 경우가 또는 극단 값이 중요할 수 있다.

1. 사용자가 타임라인을 요청하면 팔로우하는 사람들을 찾아, 시간순으로 데이터를 가져온다.

```sql
SELECT tweets.*, users.* FROM tweets 
JOIN users ON tweets.sender_id = users.id 
JOIN follows ON follows.followee_id = users.id 
WHERE follows.follower_id = current_user
```

2. 사용자가 트윗을 작성하면 팔로워들의 홈 타인라인 캐시에 트윗을 삽입한다.
	- 평균 팔로워 수: 75명
	- 하지만 팔로워가 3천 만명이 넘는 경우도 있다 (이런 경우는 *팬 아웃에서 제외된다.)
	- 팬아웃(fan out): 에서 하나의 논리 게이트의 출력이 얼마나 많은 논리 게이트의 입력으로 사용되는지에 대해 서술할 때 사용

![alt](image/1.3.트위터의%20데이터파이프라인.png)

### 1.3.2. 성능 기술하기

시스템 부하를 기술하면 부하가 증가할 때 어떤 일이 일어나는지 조사할 수 있다.
- 부하 매개변수를 증가시키고 시스템 자원은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?
- 부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 자원을 얼마나 더 늘려야할까?


대용량의 데이터를 처리하는게 목적인 배치 시스템에서는 처리량이 중요하지만 일반적인 온라인 시스템에서는 응답 시간이 더 중요하다.
- 처리량(throughput): 초당 처리할 수 있는 레코드 수나 일정 크기의 데이터 집합으로 작업을 수행할 때 걸리는 전체 시간
- 응답 시간(response time): 클라이언트가 요청을 보내고 응답을 받는 사이의 시간

응답 시간은 클라이언트가 동일한 요청을 하더라도 매번 다르다.
응답 시간을 기술할 때는 일반적으로 평균 보다는 백분위(percentitle)을 사용하는 편이 좋다.

- p50(중위값, median), p99, p999

백분위는 서비스 수준 목표(service level objective, SLO)와 서비스 수준 협약서(service level agreement, SLA)에 도 자주 등장한다.
- ex. 응답 시간 중위값이 200밀리초 미만이고 99분위가 1초 미만이 경우 정상 서비스 상태로 간주하며 서비스 제공 시간은 99.9% 이상이어야 한다.

큐 대기 지연은 높은 백분위에서 응답시간의 상당부분을 차지하는 요소이다.
- 서버가 병렬로 처리할 수 있는 작업은 한정 되기에 이전 요청이 완료 되길 기다려야 한다.
- 큐에서 인출한 작업이 빠르게 처리 되더라도 기다린 시간 때문에 클라이언트는 응답 시간이 느리다고 생각 한다.
- 따라서 클라이언트 쪽 응답 시간 측정이 중요하다.

### 1.3.3. 부하대응 접근 방식

- 용량 확장(scaling up), 수직 확장(vertical scaling): 장비 업그레이드
- 규모 확장(scaling out), 수평 확장(horizontal scaling): 다수의 장비를 도입
	- 다수의 장비에 부하를 분산하는 방법을 비공유 아키텍처라 부른다.
	- 다수의 장비에 상태 비저장(stateless) 서비스를  배포하는 것은 간단하지만
	- 상태 유지(stateful) 데이터 시스템을 분산 설치하는 것은 복잡도가 크다.

분산 시스템을 위한 도구와 추상화가 좋아지고 있어 위와 같은 통념도 바뀌고는 중이다.

대규모로 동작하는 시스템의 아키텍처는 해당 시스템을 사용하는 애플리케이션에 특화돼 있다.
범용적이고 모든 상황에 맞는 확장 아키텍처는 없다.
아키텍처를 결정하는 요소들
- 읽기의 양, 쓰기의 양, 저장할 데이터의 양, 데이터의 복잡도, 응답 시간 요구사항, 접근 패턴
	- 1Kb의 작업을 초당 100,000건 처리
	- 2Gb의 작업을 분당 3건 처리

특정 애플리케이션에 적합한 확장성을 갖춘 아키텍처는 주요 동작이 무엇이고 잘 하지 않는 동작이 무엇인지에 대한 가정을 바탕으로 구축한다. 
이 가정이 곧 부하 매개 변수가 되고 이 가정이 잘못되면 확장에 대한 엔지니어링 노력은 헛수고가 되거나 역효과를 나을수도 있다.



## 1.4. 유지보수성

소프트웨어 비용의 대부분은 초기 개발이 아니라 지속해서 이어지는 유지보수에 들어간다는 사실은 잘 알려져 있다. 이런 유지보수에는 버그 수정,시스템 운영 유지, 장애 조사, 새로운 플랫좀 적용, 새 사용 사례를 위한 변경, 기술 채무 상환, 새로운 기능 추가 등이 있다.

많은 사람들이 레거시 시스템 유지보수 작업을 좋아하지 않는다.
- 다른 사람의 실수를 고쳐야 하거나, 한물 간 플랫폼에서 작업해야하거나 정말 하기 싫은 일을 해야하는 시스템에 관여해야하기 때문이다.

희망적인 점은 유지보수 중 고통을 최소화하고 레거시 소프트웨어를 직접 만들지 않게끔 소프트웨어를 설계할 수 있다는 것이다.

운용성(operability)
- 운영팀이 시스템을 원활하게 운영할 수 있게 쉽게 만들어라

단순성(simplicity)
- 시스템에서 복잡도를 제거해 새로운 엔지니어가 시스템을 이해하기 쉽게 만들어라.

발전성(evolvability)
- 엔지니어가 이후에 시스템을 쉽게 변경할 수 있게 하라.  그래야 요구사항 변경 같은 예기치 않은 사용 사례를 적용하기 쉽다. 이 속성은 유연성(extensibility), 수정 가능성(modifiability), 적응성(plasticity)으로 알려져 있다.

신뢰성, 확장성을 달성하기 위한 쉬운 해결책은 없기에 그보다 운용성, 단순성, 발전성을 염두에 두고 시스템을 생각하려 노력해야 한다.



### 1.4.1. 운용성: 운영의 편리함 만들기

- 좋은 소프트웨어라도 나쁘에 운영할 경우 작동을 신뢰할 수 없다.
- 운영 중 일부 측면은 자동화할 수 있고 또 자동화해야 한다. 그러나 자동화를 처음 설정하고 제대로 동작하는지 확인하는 일은 여전히 사람의 몫이다.

좋은 운용성 예시
- 좋은 모니터링으로 런타임 동작과 시스템의 내부에 대한 가시성 제공
- 표준 도구를 이용해 자동화와 통합을 위한 우수한 지원을 제공
- 개별 장비 의존성을 회피, 유지보수를 위해 장비를 내리더라도 시스템 전체에 영향을 주지 않고 계속해서 운영 가능해야 함
- 좋은 문서와 이해햐기 쉬운 운영 모델 제공
- 만족할 만한 기본 동작을 제공하고, 필요할 때 기본값을 다시 정의할 수 있는 자유를 관리자에게 부여
- 적절하게 자기 회복이 가능할 뿐 아니라 관리자가 시스템 상태를 수동으로 제어할 수 있게 함
- 예측 가능하게 동작하고 예기치 않은 상황을 최소화함


### 1.4.2. 단순성: 복잡도 관리

프로젝트가 커짐에 따라 시스템은 매우 복잡하고 이해하기 어려워 진다.

복잡도 증가의 예시 
- 상태 공간의 급증
- 모듈 간 강한 커플링
- 복잡한 의존성
- 일관성 없는 명명과 용어
- 성능 문제 해결을 목표로한 해킹
- 임시방편으로 문제를 해결한 특수 사례

복잡도 때문에 시스템 유지보수가 어려워지면 예산과 일정이 초과된다. 또한 복잡한 소프트웨어서는 변경이 있을 때 버그가 생길 위험이 더 크다.
개발자가 시스템을 이해하고 추론하기 어려워지면 시스템에 숨겨진 가정과 의도치 않은 결과 및 예기치 않은 상호작용을 간과하기 쉽다. 반대로 복잡도를 줄이면 소프트웨어 유지보수성이 크게 향상된다.
따라서 단순성이 구축하려는 시스템의 핵심 목표여야 한다.

우발적 복잡도를 제거기 위한 최상의 도구는 추상화다.
- 고수준 프로그래밍 언어: 기계언어, CPU 레지스터, 시스템 호출을 숨긴 추상화
- SQL: 디스크에 기록하고 메모리에 저장한 복잡한 데이터 구조와 다른 클라이언트의 동시 요청과 고장 후 불일치를 숨긴 추상화


### 1.4.3. 발전성: 변화를 쉽게 만들기
- 엔지니어가 시스템을 쉽게 변경할 수 있도록 한다.

변화된 요구사항에 시스템을 맞추는 방법은 시스템의 간단함과 추상화와 밀접한 관련이 있다.
간단하고 이해하기 쉬운 시스템은 대게 복잡한 시스템보다 수정하기 쉽다.


## 1.5. 정리

애플리케이션이 유용하려면 다양한 요구사항을 충족해야 한다.
- 기능적 요구사항
	- 여러 방법으로 데이터를 저장하고 조회하고 검색하고 처리하계끔 허용하는 작업과 같이 애플리케이션이 제공 해야하는 일
- 비기능적 요구사항
	- 보안, 신뢰성, 법규 준수, 확장성, 호환성, 유지보수성과 같은 일반 속성

신뢰성
- 결함이 발생해도 시스템이 올바르게 동작하게 만든다는 의미다.
- 결함에는 일반적으로 하드웨어,  소프트웨어에서 기인한 결함과 사람에게서 기인한 결함이 있다.
- 내결함성 기술은 최종 사용자에게 특정 유형의 결함을 숨길 수 있게 해준다 (결함은 있으나 장애는 발생하지 않음)

확장성
- 부하가 증가해도 좋은 성능을 유지하기 위한 전략을 의미한다.
- 확장성을 설명하기 위해서는 양적으로 부하와 성능을 설명하는 방법이 필요하다.

유지보수성
- 유지보수성의 본질은 시스템에서 작업하는 엔지니어와 운영팀의 삶을 개선하는 데 있다.
- 좋은 추상화는 복잡도를 줄이고 쉽게 시스템을 변경할 수 있게하며 새로운 사용 사례에 적용하는 데 도움이 된다.
- 좋은 운용성이란 시스템의 건강 상태를 잘 모니터링할 수 있고 시스템을 효율적으로 관리하는 방법을 보유한다는 의미다.