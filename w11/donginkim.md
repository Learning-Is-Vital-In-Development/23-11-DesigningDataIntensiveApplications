# Overview

---

어떤 저자들은 2단계 커밋에서 유발되는 성능이나 가용성 문제 때문에 생기는 비용이 너무 커서 지원할 수 없다고 주장한다. 하지만 **트랜잭션 없이 코딩하는 것보다 트랜잭션을 과용해서 병목지점이 생기는 성능 문제를 애플리케이션 개발자가 처리하는게 맞다고 생각**한다.

→ 트랜잭션을 사용하면서 병목지점을 해결하자

데이터 시스템은 다음과 같은 문제를 내포한다.

- 데이터베이스 소프트웨어나 하드웨어는 언제라도 실패할 수 있다.
- 애플리케이션은 언제라도 죽을 수 있다.
- 네트워크가 끊기면 애플리케이션과 데이터베이스의 연결이 갑자기 끊기거나 데이터베이스 노드 사이의 통신이 안될 수 있다.
- 여러 클라이언트가 동시에 데이터베이스에 쓰기를 실행해서 다른 클라이언트가 쓴 내용을 덮어쓸 수 있다.
    - 갱신손실
- 클라이언트가 부분적으로만 갱신돼서 비정상적인 데이터를 읽을 수 있다.
- 클라이언트 사이의 경쟁 조건은 예측하지 못한 버그를 유발할 수 있다.

시스템이 신뢰성을 지니려면 이러한 결함을 처리해야한다. 트랜잭션은 이러한 문제를 단순화하는 매커니즘으로 채택되어왔다. **트랜잭션은 애플리케이션에서 몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법**이다. 개념적으로 한 트랜잭션 내의 모든 읽기와 쓰기는 한 연산으로 실행된다. 트랜잭션은 전체가 성공(commit)하거나 실패(abort, rollback)한다.

트랜잭션은 애플리케이션의 프로그래밍 모델을 단순화하여 잠재적인 오류 시나리오와 동시성 문제를 무시하는 목적으로 만들어졌다. 데이터베이스에서 이런 일을 도맡아주기 때문에 **안전성 보장(safety gurantee)**이 된다고할 수 있다.

# 애매모호한 트랜잭션의 개념

---

- 거의 모든 관계형 데이터베이스와 일부 비관계형 데이터베이스가 트랜잭션을 지원한다.
    - 현재 사용하고 있는 RDB의 트랜잭션은 1975년 만들어진 SQL 데이터베이스인 R 시스템의 트랜잭션과 거의 유사하다.
- 2000년 후반에 나온 NoSQL 데이터베이스는 관계형 데이터베이스의 문제를 개선하는 목표로 등장했고 이러한 데이터베이스 다수는 트랜잭션을 완전히 포기하거나 과거에 인식되었던 것보다 약한 보장을 의미하는 단어로 트랜잭션을 재정의했다.
- 높은 성능과 고가용성을 위해서는 트랜잭션을 포기한다거나 트랜잭션적인 보장은 ‘값진 데이터’를 가진 ‘중대한 애플리케이션’에 필수적인 요구사항이라고 하는데 둘다 과장이다.

## ACID의 의미

- 트랜잭션이 제공하는 안전성 보장은 흔히 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)을 의미하는 약어인 ACID로 알려져있다.
- 하지만 현실의 데이터베이스는 구현 방식이 제각각이다.
- ACID를 따르지 않는 시스템을 BASE라고도 부르는데 모호한 개념이다.
    - 기본적으로 가용성을 제공하고(Basically Availiable) 유연한 상태를 가지며(Soft state) 최종적 일관성(Eventually consistency)을 지니는 의미이다.

### 원자성(Atomicity)

- **원자적**이란 더 작은 부분으로 쪼갤 수 없는 무언가이다.
    - 컴퓨터의 다양한 분야별로 의미하는 바가 다르다.
        - 다중 스레드 프로그래밍에서 스레드가 원자적 연산을 실행한다면 다른 스레드에서 절반만 완료된 연산을 관찰할 수 없다. 연산을 실행하기 전이나 실행한 후의 상태에만 있을 수 있으며 중간 상태가 없다.
            - 하지만 ACID 맥락에서 원자성은 동시성과 관련이 없다.
- ACID 원자성은 클라이언트가 쓰기 작업 몇 개를 실행할 때 일부만 처리된 후 결함이 생기면 무슨 일이 생겼는지 설명한다. **여러 쓰기 작업이 하나의 원자적인 트랜잭션으로 묶여 있고 결함 때문에 커밋될 수 없다면 어보트되고 DB는 지금까지 실행한 쓰기를 무시하거나 취소해야한다.**
    - 오류가 생겼을 때 트랜잭션을 어보트하는 능력(Abortability)가 사실 원자성보다 더 맞는 표현에 가깝다.

### 일관성(Consistency)

- 일관성이라는 단어는 다양하게 쓰인다.
    - 복제 일관성(replica consistency)과 비동기식 복제 시스템에서 발생하는 최종적 일관성(eventual consistency)
    - 일관성 해싱: 어떤 시스템들에서 재균형화를 위해 사용하는 파티셔닝 방법
    - CAP 정리에서는 일관성이라는 단어를 선형성(linerzability)을 의미한다.
        - 개별 객체에 실행되는 읽기와 쓰기에 대한 최신성 보장이다. 연산을 트랜잭션으로 묶지 않는다. 327p
    - ACID 맥락에서 일관성은 데이터베이스가 ‘좋은 상태’에 있어야 하는 개념을 의미한다.
- ACID 일관성은 데이터에 관한 어떤 선언(불변식(invariant))이 있어 항상 진실하다는 의미이다.
    - ex) 회계 시스템에서는 모든 계좌에 걸친 대변과 차변은 항상 맞아떨어져야 한다.
    - 이러한 불변식이 유효한 데이터베이스에서 시작하 트랜잭션에서 실행된 모든 쓰기가 유효성을 보존한다면 불변식이 항상 만족된다고 확신할 수 있다.

이러한 일관성은 애플리케이션의 책임이다. 데이터베이스에서 제약조건 등을 통해 일관성을 지키는 불변식이 있긴하다. 하지만 일반적으로는 애플리케이션에서 데이터가 유효한지 아닌지를 정의하고 데이터 베이스는 데이터를 저장한다.

일관성을 달성하기 위해 데이터베이스의 원자성과 격리성 속성에 기댈 수는 있지만 데이터베이스만으로 되지 않는다. **따라서 C(일관성)는 실제로 ACID에 속하지 않는다.**

> PK, FK, Unique 등에 대해서. 현재 우리 회사에서는 제약조건을 엄격하게 사용하고 있다. 이게 어떤 문제를 야기할 수 있을까?

### 격리성(Isolation)

- 여러 클라이언트들이 동일한 데이터베이스 레코드에 접근할 때 동시성 문제(경쟁 조건)에 맞닥뜨린다. **격리성은 동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미**한다.
- 고전적으로는 격리성을 직렬성(Serializability)이라는 용어로 공식화하여 각 트랜잭션이 전체 데이터베이스에서 실행되는 유일한 트랜잭션인 것 처럼 동작할 수 있다는 것을 의미한다.
    - 커밋할 때의 결과가 트랜잭션이 순차적으로 실행됐을 때의 결과와 동일하도록 보장한다.
    
    [(1부) concurrency control 기초 : schedule과 serializability. 트랜잭션들이 동시에 실행될 때 isolation을 보장하는 기초 이론](https://www.youtube.com/watch?app=desktop&v=DwRN24nWbEc)
    
    - 직렬성 격리(serializable isolation)는 성능 손해를 동반하므로 현실에서는 거의 사용되지 않는다.
        - 오라클 등 대중적인 데이터베이스는 구현조자 안하기도 한다.
- 오라클에서는 ‘직렬성(Serializable)’이라는 격리 수준이 있지만 실제로는 **스냅숏 격리**(Snapshot Isolation)를 통해 구현한다.

### 지속성(Durability)

- 데이터베이스 시스템의 목적은 데이터를 잃어버릴 염려가 없는 안전한 저장소를 제공한다.
- 지속성(Durability)는 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장이다.
    - 단일 노드 데이터베이스에서 지속성은 일반적으로 데이터가 하드디스크나 SSD 같은 비휘발성 저장소에 기록됐다는 의미
        - 보통 쓰기 전 로그(write-ahead log, WAL) 등의 방법으로 구현
    - 복제 기능이 있는 데이터베이스에서는 다른 노드 몇 개에 복사됐다는 것을 의미
- 지속성을 보장하려면 트랜잭션이 성공적으로 커밋됐다고 보고하기 전에 쓰기나 복제가 완료될 때까지 기다려야 한다.
- 완벽한 지속성은 존재하지 않는다.

# 단일 객체 연산과 다중 객체 연산

ACID의 원자성과 격리성은 클라이언트가 한 트랜잭션 내에서 여러 번의 쓰기를 하면 데이터베이스가 어떻게 해야하는지를 서술한다.

원자성: 데이터베이스는 전부 반영되거나 아무것도 반영되지 않는 것을 보장함으로써 부분 실패를 걱정할 필요가 없다.

격리성: 동시에 실행되는 트랜잭션들은 서로 방해하지 않아야한다.

한 번에 여러 객체(row, record, document 등)를 변경할 수 있다고 가정한다. 다중 객체 트랜잭션은 흔히 데이터의 여러 조각이 동기화된 상태로 유지돼야 할 때 필요하다.

어떤 사용자의 읽지 않은 메시지 개수를 보여주는 쿼리

```sql
select count(*) from emails where recipient_id = 2 AND unread_flag = true
```

- 이메일이 많으면 이 질의가 느려져서 읽지 않은 메시지 개수를 별개의 필드에 저장하고 싶을 것이다(비정규화)
- 새 메시지가 올 때마다 읽지 않은 메시지 개수도 증가시켜야 하고 메시지도 읽었다고 표시할 때마다 읽지 않은 메시지 개수도 감소시켜야 한다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/fbd6e0a7-4894-4bde-8363-71cd835a5dc6)
격리성 위반: 트랜잭션이 다른 트랜잭션 썻지만 커밋되지 않은 데이터를 읽음(더티 리드)

- 트랜잭션 실행 도중 어느 시점에서 오류가 발생하면 우편함의 내용과 읽지 않은 메시지 개수가 동기화되지 않을 수 있다.
- 원자적 트랜잭션은 개수 갱신을 실패하면 트랜잭션이 어보트되고 삽입된 이메일은 롤백된다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/68175c95-b698-4b99-9a0a-b1956687dad6)
원자성은 오류가 발생하면 트랜잭션에서 이전에 실행한 쓰기를 취소해서 일관성이 깨진 상태가 되지 않게 한다.


다중 트랜잭션은 어떤 읽기 연산과 쓰기 연산이 동일한 트랜잭션에 속하는지 알아야한다.

- RDB
    - 기본적으로 TCP을 기반으로 클라이언트와 연결한다.
    - 특정 연결 내에서 BEGIN TRANSACTION 문과 COMMIT 문 사이의 모든 것은 같은 트랜잭션에 속하는 것으로 여겨진다.
- 비관계형 데이터베이스
    - 연산을 묶는 방법이 없다.
    - 다중 객체 API(다중 put(multi-put) 연산이 있더라도 반드시 트랜잭션 시멘틱을 의미하지 않는다. 즉, 부분적으로 갱신이 되는 경우가 있을 수 있다.

## 단일 객체 쓰기

원자성과 격리성은 단일 객체를 변경하는 경우에도 적용

- 20KB JSON 문서를 데이터베이스에 쓸 때, 10kb만 전송이 되었을 경우
- DB가 디스크에 저장된 기존 값을 덮어쓰는 경우 예기치 못하게 종료가 되는 경우
- 문서를 쓰고 있ㅇ르 때 다른 클라이언트에서 그 문서를 읽었을 경우

원자성은 장애복구(crash recovery)용 로그로 구현

격리성은 각 객체에 잠금을 사용해(동시에 한 스레드만 접근하도록) 구현

데이터베이스가 제공하는 연산

- 증가연산처럼 더 복잡한 원자적 연산
    - 증가 연산은 read-modify-wrtie 주기를 반복할 필요를 제거함
- compare-and-set 연산
    - 변경하려는 값이 누군가에 의해 동시에 바뀌지 않았을 때만 쓰기가 반영되도록 허용

이러한 단일 객체 연산은 여러 클라이언트에서 동시에 같은 객체에 쓰기 연산을 할 때 갱신 손실(lost update)을 방지하므로 유용하다. 또 다른 단일 객체 연산은 ‘경량 트랜잭션(light-weight transaction)으로 불린다.

하지만 **트랜잭션은 보통 다중 객체에 대한 다중 연산을 하나의 실행 단위로 묶는 매커니즘으로 이해**한다.

## 다중 객체 트랜잭션의 필요성

많은 분산 데이터스토어는 다중 객체 트랜잭션 지원을 포기했다. 다중 객체 트랜잭션은 여러 파티션에 걸쳐서 구현하기도 어렵고 매우 높은 가용성과 성능이 필요하는 곳에서는 방해가 되는 경우도 있다.

- 분산 데이터베이스에서 근본적으로 트랜잭션을 막는 것은 없다.

다중 객체 트랜잭션은 정말로 필요할까?

- RDB에서 테이블의 로우는 외래키(FK)를 갖는 경우가 많다.
    - 그래프형 모델(graph-like)에서 정점(vertex)은 다른 정점에 연결된 간선(edge)가 있다.
    - 다중 객체 트랜잭션은 참조가 유효한 상태로 보장해준다. 서로 참조하는 여러 레코드를 삽입할 때 참조키는 올바르게 입력되어야 하고 최신정보를 반영해야 한다.
- 문서 데이터 모델에서는 함께 갱신돼야 하는 필드들이 단일 객체로 다뤄지는 동일한 문서 내에 존재하는 경우가 흔하여 단일 문서를 갱신할 때 다중 객체 트랜잭션이 필요없다. 하지만 조인 기능이 없는 문서 데이터베이스는 비정규화를 장려하기도 한다.
- 인덱스
    - 인덱스가 있는 DB의 경우 값을 변경할 때마다 인덱스도 갱신되어야 한다.
    - 트랜잭션 관점에서 인덱스는 서로 다른 데이터베이스 객체이다.
        - 트랜잭션 격리성이 없으면 어떤 색인에서는 레코드가 보이지만 다른 색인은 갱신되지 않아서 레코드가 보이지 않을 수도 있다.

원자성이 없으면 오류 처리가 복잡해지고 격리성이 없으면 동시성 문제가 발생될 수 있다.

## 오류와 어보트 처리

트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 안전하게 재시도할 수 있다는 점이다. 데이터베이스가 원자성, 격리성, 지속성 보장을 위반할 위험이 있으면 트랜잭션이 절반 정도 완료된 상태에 머물게 하는 대신 트랜잭션을 폐기한다.

모든 시스템이 이 철학을 따르지 않는다.

- 리더 없는 복제 데이터스토어
    - ‘최선을 다하는(best effort)’ 원칙을 기반으로 더 많은 일을 한다.
    - 데이터베이스는 가능한 모든 것을 할 것이며 그 때문에 오류가 발생하면 이미 한 일은 취소하지 않는다.
    - 오류 복구는 애플리케이션에게 책임이 있다.
- ORM을 사용하는 프레임워크는 어보트된 트랜잭션을 재시도하지 않고 에러로 처리할 뿐이다.

어보트된 트랜잭션 재시도하는 것은 효과적인 오류 처리 매커니즘이지만 몇 문제가 있다.

- 트랜잭션이 성공했지만 DB 서버가 클라이언트에게 커밋 성공을 알리는 도중 네트워크 오류가 발생한 경우
    - 트랜잭션을 재시도하면 트랜잭션이 두 번 실행된다.
    - 애플리케이션에 추가적인 중복 제거 매커니즘이 필요하다.
- 과부하로 발생한 오류
    - 트랜잭션 재시도는 문제를 악화시킨다.
    - 피드백 주기를 피하려면 재시도 횟수를 제한하든지 지수적 백오프(exponential backoff)를 사용하거나 과부화와 관련된 오류를 다른 오류와 별도로 처리하는 방법을 사용할 수 있다.
- 일시적인 오류
    - 일시적인 오류사실 재시도해도 소용없다.
- 트랜잭션이 데이터베이스 외부에도 부수 효과가 있으면 트랜잭션이 어보트될 때에도 부수 효과가 실행될 수 있다.
    - ex) 이메일을 보낼 때 트랜잭션을 재시도할 때마다 이메일이 다시 전송되는것을 원하지 않을 수 있다.
    - 여러 개의 다른 시스템들이 반드시 함께 커밋되거나 어보트되게 만드려면 2PC(two-phase commit)을 사용할 수 있다.
- 클라이언트 프로세스가 재시도 중에 죽어버리면 그 클라이언트에서 DB에 쓰려고 했던 데이터가 모두 손실된다.

# 완화된 격리 수준

두 트랜잭션이 동일한 데이터에 접근하지 않으면 서로 의존하지 않으므로 안전하게 병렬 실행될 수 있다. 동시성 문제(경쟁 조건)는 트랜잭션이 다른 트랜잭션에서 동시에 변경한 데이터를 읽거나 두 트랜잭션이 동시에 같은 데이터를 변경하려고 할 때만 나타난다.

- 동시성 버그는 테스트로 발견하기 쉽지 않다. 재현도 어렵고 추론도 어렵다.

데이터베이스는 오랫동안 트랜잭션 격리를 제공함으로써 개발자들에게 동시성 문제를 감추려했다.

- 이론상 격리성은 동시성이 없는 것처럼 행동할 수 있으므로 개발자들의 부담을 줄일 수 있다.

**직렬성 격리**

- 데이터베이스가 여러 트랜잭션들이 직렬적으로 실행되는 것을 의미한다.
- 동시성  없이 한 번에 트랜잭션 하나만 실행
- 성능 비용이 있고 많은 데이터베이스들은 그 비용을 지불하려고 하지 않는다.

**완화된 트랜잭션 격리**

- 어떤 동시성 이슈로부터는 보호해주지만 모든 이슈로부터 보호해주지 않는 완화된 격리 수준이다.
- 금융 데이터를 다룬다면 ACID 데이터베이스를 사용하라! 라는 말이 있다.
- 모든 이슈를 막아주지는 않는다.

## 커밋 후 읽기

커밋 후 읽기(read committed)는 가장 기본적인 수준의 트랜잭션 격리이다.

1. DB에서 읽을 때 커밋된 데이터만 보게 된다. (더티 읽기가 없음)
2. DB에서 쓸 때 커밋된 데이터만 덮어쓰게 된다. (더티 쓰기가 없음)

### 더티 읽기 방지

다른 트랜잭션에서 커밋되지 않은 데이터를 보게 되는 경우를 더티 읽기(dirty read)라고 한다.
![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/871cc5ce-8061-4235-b1cc-16a64fd1c66b)
- 커밋 후 읽기 격리 수준에서 실행되는 트랜잭션은 더티 읽기를 막아야 한다.
- 트랜잭션이 쓴 내용은 커밋된 후에야 다른 트랜잭션에게 보인다.

**더티 읽기를 막는게 좋은 이유**

1. 부분적으로 갱신된 상태의 DB를 보는 것은 사용자에게 혼란스럽고 다른 트랜잭션이 잘못된 결정을 하는 원인이 된다.
2. 트랜잭션이 어보트되면 그때까지 쓴 내용은 모두 롤백되어야 하기 때문에 혼란스럽게 된다.

### 더티 쓰기 방지

아직 커밋되지 않은 트랜잭션에서 쓴 것이고 나중에 실행된 쓰기 작업이 커밋되지 않은 값을 덮어쓰는 것을 더티 쓰기(dirty write)라고 한다.

커밋 후 읽기 격리 수준에서 실행되는 트랜잭션은 더티 쓰기를 방지해야 한다.
![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/7cec5012-357d-454e-bc9c-9f61819f4a3f)

더티 쓰기를 막으면 다음과 같은 동시성 문제를 해결한다.

- 2명의 사람이 같은 객체에 대해 쓰기 연산을 할 때, 서로의 순서가 엉키는 상황이 일어난다.

보통 먼저 쓴 트랜잭션이 커밋되거나 어보트될 때까지 두 번째 쓰기를 지연시키는 방법을 사용한다.

### 커밋 후 읽기 구현

커밋 후 읽기는 오라클, PostgresQL, SQL Server, MemSQL 등 여려 데이터베이스에서 default 설정되는 격리 수준이다.

구현 방법

- row 수준 잠금을 사용
    - 쓰기 연산을 하기 위해서는 해당 객체에 대한 잠금을 획득해야 가능
        - 더티 쓰기 방지
    - 트랜잭션이 커밋되거나 어보트될 때 까지 잠금을 보유하고 있다.
        - 한 트랜잭션만 어떤 주어진 객체에 대한 잠금을 보유할 수 있다.
    - 커밋 후 읽기 모드에서 데이터베이스에 의해 자동으로 실행
- 동일한 잠금을 써서 객체를 읽기 원하는 트랜잭션이 잠시 잠금을 획득한 후 읽기가 끝난 후 바로 해체하게 한다.
    - 객체가 변경됐으나 아직 커밋되지 않은 값을 갖고 있을 때 읽기가 실행되지 않도록 보장할 수 있다. (쓰기를 실행한 트랜잭션이 잠금을 가지고 있을 것이다)

하지만 이러한 잠금 방식은 트랜잭션 하나가 완료될 때까지 기다려야 하기 때문에 성능이 좋지 않다. 이런 이유로 대부분의 DB는 7-4처럼 트랜잭션이 커밋된 후에야 트랜잭션을 읽는 방법을 사용한다.

- 이 경우 쓰여진 모든 객체에 대해 DB는 과거에 커밋된 값과 현재 쓰기 잠금을 갖고있는 트랜잭션에 쓴 새로운 값을 모두 기억한다.
    - 해당 트랜잭션이 실행 중인 동안 그 객체를 읽는 다른 트랜잭션들은 과거의 값을 읽게 된다.
    - 새 값이 커밋돼야만 다른 트랜잭션들이 새 값을 읽을 수 있게 된다.

## 스냅숏 격리와 반복 읽기

커밋 후 읽기 격리는 트랜잭션이 해야 하는 모든 일을 해주는 것 같다. 어보트를 허용하고 트랜잭션의 미완료된 결과 읽는 것을 방지하고 동시에 실행되는 쓰기가 섞이는 것을 막아준다.

하지만 아직 동시성 버그가 생기는 경우가 있다.
![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/a322b4cb-0112-4072-a24a-733f18e8b525)

위에서 사용된 로직은 account1(잔액 500) → account2(잔액 500)로 100을 이체하는 로직이다. 총 1000이 있어야 정상이다. 하지만 Alice가 사용하는 트랜잭션에서는 총 금액이 900이다. 100이 사라졌다.

이러한 현상을 **비반복 읽기(nonrepeatable read)** 혹은 **읽기 스큐(read skew)**라고 한다. 또한 alice가 읽은 2번째 읽기 연산은 송금 트랜잭션이 커밋된 이후에 진행되었기 때문에 커밋 후 읽기 격리에서 발생할 수 있는 문제이다. 하지면 결과적으로는 일관성이 맞춰지기 때문에 일시적인 비일관성이라고 할 수 있다.

하지만 일시적인 비일관성은 문제를 야기하기도 한다.

1. 백업
    - 백업 프로세스가 진행되는 동안 DB에 쓰기가 계속 진행된다. 그렇게 되면 일부 데이터는 과거 버전을 또 다른 일부 데이터는 새버전을 가지고 있을 수 있다. 이런 백업을 사용해서 복원하려면 비일관성이 영속적이게 될 수도 있다.
2. 분석 질의와 무결성 확인
    - 분석 시점에서의 질의는 시점마다 다른 결과를 반환할 수 있다.

읽기 스큐 등의 문제에 대해 가장 흔한 해결책으로 스냅숏 격리를 사용한다.

**스냅숏 격리(Snapshot Isolation)**

- 각 트랜잭션은 데이터베이스의 일관된 스냅숏으로부터 읽는다.
- 트랜잭션은 시작할 때 DB에 커밋된 상태였던 모든 데이터를 본다.
    - 데이터가 나중에 다른 트랜잭션에 의해 바뀌더라도 각 트랜잭션은 특정한 시점의 과거 데이터를 볼 뿐이다.
- 백업이나 분석처럼 실행하는데 오래 걸리고 읽기 요청인 쿼리에 좋다. 트랜잭션이 특정 시점에 고정된 일관된 스냅숏만 볼 수 있다면 이해하기 쉽다.
- PostgreSQL, InnoDB(MySQL), Oracle, SQL Server 등에서 사용된다.

[transaction isolation level 설명합니다! isolation이 안될 때 나타날 수 있는 여러 현상들과 snapshot isolation도 같이 설명합니다!!](https://www.youtube.com/watch?v=bLLarZTrebU)

### 스냅숏 격리 구현

커밋 후 읽기는 기본적으로 더티 쓰기를 방지하기 위해 쓰기 잠금을 사용한다. 쓰기를 실행하는 트랜잭션은 같은 객체에 쓰는 다른 트랜잭션의 진행을 차단할 수 있다. 하지만 읽을 때는 아무 잠금이 없다. 

성능 관점에서 스냅숏 격리의 핵심 원리는 **읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는 것**이다.

스냅숏 격리를 사용하면 데이터베이스는 잠금 경쟁 없이 쓰기 작업이 일상적으로 처리되는 것과 동시에 일관성 있는 스냅숏에 대해 오래 실행되는 읽기 작업을 처리한다.

구현

1. 데이터베이스는 객체마다 커밋된 버전 여러 개를 유지할 수 있어야 한다.
    - 여러 트랜잭션이 서로 다른 시점의 데이터베이스 상태를 봐야할 수 있어야 한다.
    - 객체의 여러 버전을 함께 유지하므로 다중 버전 동시성 제어(multi-version concurrency control, MVCC)라고 한다.
2. 트랜잭션이 시작하면 계속 증가하는 고유한 트랜잭션 ID를 할당받는다.
3. 트랜잭션이 데이터베이스에 데이터를 쓸 때마다 쓰기를 실행한 트랜잭션의 ID가 붙는다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/5b7dbb38-946c-431c-803a-8d72a28949ad)

이전에 봤던 문제와 달리 txid 12의 트랜잭션은 500, 500의 데이터를 확인하며 txid 13의 트랜잭션도 문제없이 커밋을 했다.

[](https://monday9pm.com/mvcc-multi-version-concurrency-control-알아보기-e4102cd97e59)

아무 트랜잭션도 더 이상 삭제된 데이터에 접근하지 않는 게 확실해지면 **DB의 가비지 컬렉션 프로세스가 지웠다고 표시된 로우들을 삭제**해서 사용량을 줄인다.

- 아마 다른 버전도 마찬가지일듯

### 일관된 스냅숏을 보는 가시성 규칙

1. DB는 각 트랜잭션을 시작할 때 그 시점에 진행중인(커밋이나 어보트되지 않은) 모든 트랜잭션의 목록을 만든다. 이 트랜잭션들이 쓴 데이터는 모두 무시된다. 데이터를 쓴 트랜잭션이 나중에 커밋되더라도 마찬가지다.
2. 어보트된 트랜잭션이 쓴 데이터는 모두 무시된다.
3. 트랜잭션 ID가 더 큰 트랜잭션이 쓴 데이터는 그 트랜잭션 커밋 여부와 관계없이 무시된다.
4. 그 밖의 모든 데이터는 애플리케이션의 질의로 볼 수 있다.

아래 두 조건이 모두 참이면 객체를 볼 수 있다.

- 읽기를 실행하는 트랜잭션이 시작한 시점에 읽기 대상 객체를 생성한 트랜잭션이 이미 커밋된 상태였다.
- 읽기 대상 객체가 삭제된 것으로 표시되지 않았다. 또는 삭제된 것으로 표시됐지만 읽기를 실행한 트랜잭션이 시작한 시점에 삭제 요청 트랜잭션이 아직 커밋되지 않았다.

오래 실행되는 트랜잭션은 오랫동안 스냅숏을 사용해서 덮어써지거나 삭제된 지 오래된 값을 계속 읽을 수 있다. 데이터베이스는 갱신할 때 값을 교체하지 않고 값이 바뀔 때마다 새 버전을 생성함으로써 작은 오버헤드만 유발하면서 일관된 스냅숏을 제공할 수 있다.

### 색인과 스냅숏 격리

인덱스가 객체의 모든 버전을 가르키게 하고 볼 수 없는 버전을 걸러낸 후 사용하지 않는 오래된 객체 버전을 삭제할 때 인덱스도 사용하는 것이 좋다.

하지만 현실적으로는 MVCC 성능을 구현하기 위해 서로 다른 방식을 사용한다.

- 카우치DB, 데이토믹, LMDB는 다른 방법을 사용한다. B 트리를 사용하지만 추가 전용이며 쓸 때 복사되는(append-only/copy-on-write) 변종을 사용한다. 페티지가 갱신될 때 덮어쓰는 대신 변경된 페이지의 새로운 복사본을 생성한다.
- B 트리를 사용하면 쓰기를 실행하는 모든 트랜잭션은 B 트리 루트를 생성하며 생성된 시점에 해당하는 DB의 일관도니 스냅숏이 된다.

### 반복 읽기와 혼란스러운 이름

스냅숏 격리는 유용하며 특히 읽기 전용 트랜잭션에 유용하다. 그러나 이를 구현하는 DB에서는 오라클에서는 직렬성, PostgresQL, MySQL에서는 반복 읽기(repeatable read)라고 서로 다르게 부른다.

SQL 표준에 스냅숏 격리의 개념이 없기 때문에 혼란스럽다. 대신 스냅숏 격리와 비슷해 보이는 반복 읽기는 SQL 표준에 정의되어 있다.

하지만 SQL 표준의 격리 수준 정의에는 결함이 있다. 모호하고 부정확하며 표준이 그래야 하는 것만큼 구현 독립적이지 않다. 결과적으로 반복 읽기가 무슨 뜻인지 실제로 아는 사람은 업삳.

## 갱신 손실 방지

동시에 실행되는 쓰기 트랜잭션 사이에서는 갱신 손실(lost update)가 발생할 수 있다.

**갱신 손실 문제**

- DB에서 값을 읽고 변경한 후 변경된 값을 다시 쓸 대(read-modify-write) 발생할 수 있다.
    - 두 트랜잭션이 이 작업을 동시에 하면 두번째 쓰기 작업이 첫 번째 변경을 포함하지 않으므로 변경 중 하나는 손실될 수 있다.
        - 나중에 쓴 것이 먼저 쓴 것을 때려눕힌다(clobber)고 말하기도 한다.

<aside>
💡 갱신 손실 문제 시나리오
- 카운터를 증가시키거나 계좌 잔고를 갱신한다. (현재 값을 읽고 갱신된 값을 다시 써야 한다)
- 복잡한 값을 지역적으로 변경한다. JSON document 내용의 리스트 엘리먼트를 추가하기 위해 문서를 파싱하고 변경하고 변경한 document를 다시 쓴다. 
- 사용자가 편집한 내용을 저장할 때 전체 페이지 내용을 서버에서 보내서 현재 데이터베이스에 저장된 내뇽ㅇ을 덮어 쓰도록 만들어진 위키에서 두 명의 사용자가 동시에 같은 페이지를 편집한다.

</aside>

### 원자적 쓰기 연산

여러 데이터베이스에서 **원자적 갱신 연산**을 제공한다.

**관계형 데이터베이스**

- 이 연산은 애플리케이션에서 read-modify-write 주기를 구현할 필요가 없다.
- 관계형 데이터베이스에서 동시성 안전(currency-safe)하다.

```sql
UPDATE counters SET value = value + 1 WHERE key = 'foo';
```

**문서 데이터베이스**

- 몽고DB는 JSON 문서의 일부를 지역적으로 변경하는 원자적 연산을 제공한다.

**레디스**

- 우선순위 큐(priority queue) 같은 데이터 구조를 변경하는 원자적 연산을 제공한다.

원자적 연산은 보통 객체를 읽을 때 그 객체이 독점적인(exclusive) 잠금을 획득해서 구현한다. 그래서 갱신이 적용될 때까지 다른 트랜잭션에서 그 객체를 읽지 못하게 한다.

- 이 기법을 커서 안정성(cursor stability)이라고 부르기도 한다.
- 다른 선택지는 그냥 모든 원자적 연산을 단일 스레드에서 실행되도록 강제하는 것이다.

<aside>
💡 ORM을 사용하면 뜻하지 않게 DB가 제공하는 원자적 연산을 사용하는 대신 불안전한 read-modify-write 실행하는 코드를 작성하기 쉽다.

</aside>

### 명시적인 잠금

데이터베이스에 내장된 원자적 연산이 필요한 기능을 수행하지 않는다면 애플리케이션에서 갱신할 객체를 명시적으로 잠그는 것이다.

- 애플리케이션이 read-modify-write 주기를 수행할 수 있고 다른 트랜잭션이 동시에 같은 객체를 읽으려고 하면 첫 번째 read-modify-write 주기를 막는 것이다.

```sql
BEGIN TRANSACTION;

SELECT * FROM figures
	WHERE name = 'robot' AND game_id = 222
	FOR UPDATE;

-- 이동이 유효한지 확인한 후
-- 이전의 SELECT의 반환된 것의 위치를 갱신한다.
UPDATE figures SET position = 'c4' WHERE id = 1234;

COMMIT;
```

- `FOR UPDATE`는 데이터베이스가 이 질의에 의해 반환된 모든 로우에 잠금을 획득해야 함을 가리킨다.

### 갱신 손실 자동 감지

원자적 연산과 잠금은 read-modify-write 주기가 순차적으로 실행되도록 강제해서 갱신손실을 방지하는 방법이다. 

→ 대안으로 병렬 실행을 허용하고 트랜잭션 관리자가 갱신 손실을 발견하면 트랜잭션을 어보트시키고 read-modify-write 주기를 재시도하도록 강제하는 방법이 있다. 이 방법은 데이터베이스가 이 확인을 스냅숏 격리와 결합해서 효율적으로 수행할 수 있다.

PostgresQL의 Repeatable Read, Oracle의 Seriazable, SQL Server의 스냅숏 격리 수준은 갱신 손실이 발생하면 자동으로 발견해서 문제가 되는 트랜잭션을 어보트 시킨다. 하지만 **MySQL(InnoDB)의 Repeatable Read는 갱신 손실을 감지하지 않는다.**

### Compare-and-set

값을 마지막으로 읽은 후로 변경되지 않았을 때만 갱신을 허용함으로써 갱신 손실을 회피한다. 현재 값이 이전에 읽은 값과 일치하지 않으면 갱신은 반영되지 않고 read-modify-write 주기를 재시도해야 한다.

```sql
-- DB 구현에 따라 안전할 수도 안전하지 않을 수도 있다.
update wiki_pages SET content = 'new content'
WHERE id = 1234 AND content = 'old content';
```

- 내용이 바뀌어서 where 절에 해당하지 않으면 갱신에 적용되지 않는다. 따라서 갱신이 적용됐는지 확인하고 필요하다면 재시도해야 한다.
- WHERE 절이 오래된 스냅숏으로부터 읽는 것을 허용한다면 이 구문은 갱신 손실을 막지 못할 수도 있다.
- DB의 compare-and-set 연산에 의존하기 전에 먼저 확인이 필요하다.

### 충돌 해소와 복제

여러 노드에 데이터의 복사본이 있어서 데이터가 다른 노드들에서 동시에 변경될 수 있으므로 갱신 손실을 방지하려면 추가 단계가 필요하다.

잠금과 compare-and-set 연산은 데이터의 최신 복사본이 하나만 있다고 가정한다. 그러나 다중 리더 또는 리더 없는 복제를 사용하는 데이터베이스는 일반적으로 여러 쓰기가 동시에 실행되고 비동기식으로 복제되는 것을 허용하므로 데이터의 최신 복사본이 하나만 있는 것을 보장하지 못한다.

원자적 연산은 복제 상황에서도 잘 동작한다. 반면 최종 쓰기 승리(last write wins, LWW) 충돌 해소 방법은 갱신 손실이 발생하기 쉽다. 많은 복제 데이터베이스는 LWW가 기본설정이다.

### 쓰기 스큐와 팬텀

더티 쓰기와 갱신손실의 데이터 오염을 피하려면 경쟁 조건을 방지해야 한다. 이를 방지하기 위해서 DB의 자동 감지, 잠금, 원자적 쓰기 연산 등의 안전장치를 사용해야 한다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/e267adce-deaf-451a-b808-3403e9fdc7f6)

최소 한 명의 의사가 호출 대기(on_call true)를 해야하는데 동시에 로직이 실행되어서 한 명의 사용자도 true가 없는 경우가 발생했다. 

### 쓰기 스큐를 특정짓기

위 예시의 현상을 쓰기 스큐(write skew)이다. 이 경우 두 트랜잭션이 두 개의 다른 객체를 갱신하므로 더티쓰기도 갱신 손실도 아니다. 하지만 두 트랜잭션이 한 번에 하나씩 실행됐으면 이러한 문제가 발생하지 않았을 것이다. 따라서 분명한 경쟁조건이다.

쓰키 스큐를 해결하기 어려운 이유

- 여러 객체가 관련되므로 원자적 단일 객체 연산은 도움되지 않는다.
- 갱신 손실 감지도 도움이 되지 않는다. 자동으로 방지하기 위해서는 진짜 직렬성 격리가 필요하다.
- 제약조건을 설정할 수 있는 데이터베이스가 있다. 하지만 조건이 복잡한 경우 내장되지 않지만 DB에 따라 트리거나 구체화 뷰(materialized view)를 사용해 구현할 수 있다.
- 이런 경우 로우를 명시적으로 잠그는 것이 차선책이다.

```sql
BEGIN TRANSACTION;

SELECT *  FROM doctors
	WHERE on_call = true
	AND shift_id = 1234 FOR UPDATE;

UPDATE doctors
	SET on_call = false
	WHERE name = 'Alice'
	AND shift_id = 1234;

COMMIT;
```

### 추가적인 쓰키 스큐의 예

<aside>
💡 **회의실 예약 시스템**
동시에 같은 회의실 중복 예약할 때

**다중플레이어 게임**
게임의 규칙에 따라 유일성 제약 등을 써야할 수 있다.

**사용자명 획득**
동시에 같은 사용자명으로 계정 생성을 시도할 때

**이중 사용(double-spending) 방지**
돈이나 포인트 지불할 때 지불 예정 항목을 사용자 계좌에 삽입하고 그 계좌에 있는 모든 항목을 나열한 후 그 합이 양수인지 확인하는 방법

</aside>

### 쓰기 스큐를 유발하는 팬텀

위의 예시는 패턴을 만든다.

1. SELECT 질의가 어떤 검색 조건에 부합하는 로우를 검색함으로써 어떤 요구사항을 만족하는지 확인한다.
2. 첫 번째 질의의 결과에 따라 애플리케이션 코드는 어떻게 진행할지 결정한다.
3. 애플리케이션이 계속 처리하기로 결정했다면 데이터베이스에 쓰고 트랜잭션을 커밋한다. 이 쓰기의 효과로 2단계를 결정한 전제 조건이 바뀐다. 쓰기를 커밋한 후 1단계의 SELECT 질의를 재실행하면 다른 결과를 얻게 된다.

이처럼 어떤 트랜잭션에서 실행한 스기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과를 팬텀(phantom)이라고 한다. 스냅숏 격리는 읽기 전용 질의에서는 팬텀을 회피하지만 쓰기 트랜잭션의 경우를 피하기가 어렵다.

### 충돌 구체화

인위적으로 데이터베이스에 잠금 객체를 추가할 수 있을까? 

회의실을 예약하는 경우 시간 슬롯과 회의실에 대한 테이블을 미리 만들 수 있다. 각 로우는 특정한 시간 범위 동안 사용되는 특정한 회실에 해당한다. 회의실과 시간 범위는 조합에 따라 로우를 미리 만들어둘 수 있다. 예약을 하는 트랜잭션은 테이블에서 원하는 회의실과 시간 범위에 해당하는 로우를 잠금을 할 수 있다.

이런 방법을 충돌 구체화(materializing conflict)라고 한다. 팬텀을 데이터베이스에 존재하는 구체적인 로우 집합에 대한 잠금 충돌로 변환하기 떄문이다. 하지만 어렵고 오류가 발생하기 쉽다. 따라서 충돌 구체화는 다른 대안이 불가능할 때 최후의수단이며 대부분의 경우 직렬성 격리수준이 선호된다.
