## 트랜잭션

- 트랜잭션의 개념
  - 몇개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법
  - 전체가 성공(commit) 하거나 실패(abort, 롤백)
- 트랜잭션의 사용 이유
  - 신뢰성(내결함성)을 지닌 시스템 구현하기 위한 다양한 문제들을 단순화하는 메커니즘으로 채택
  - 오류 부분적인 실패를 걱정할 필요가 없다.
  - 동시성 문제의 해결할 수 있다.
  - 어떤 경우는 트랜잭션을 완화/사용않는 것이 안전/성능상의 이점이 있다
- 논의해봐야 할 문제
  - 동시성 문제
  - race condition
  - 격리 수준의 구현 : read commited, snapshot isolation, serialization


### 애매모호한 트랜잭션의 개념

- 전통적인 RDB : "값진 데이터"가 있는 "중대한 애플리케이션"에 필수적인 요구사항이다.
- 새로 등장한 NoSQL : 분산환경에서 높은 성능과 고가용성을 유지하려면 트랜잭션을 포기해야한다. 트랜잭션은 위 두 관점보다 훨씬 약한 보장이다.

#### ACID의 의미

> 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)

1. 원자성(Atomicity)

여러 쓰기 작업이 하나의 원자적인 트랜잭션으로 묶여 있는데 결함 때문에 커밋(commit)될 수 없다면 abort되고 데이터베이스는 이 트랜잭션에서 지금까지 실행한 쓰기를 무시하거나 취소해야 한다.

2. 일관성(Consistency)

일관성이란 단어는 여러 의미로 쓰인다. 

- 5장의 복제 일관성(replica consistency)과 비동기식으로 복제 시스템의 최종적 일관성(eventual consistency) 문제
- 일관성 해싱은 어떤 시스템들에서 재균형화를 위해 사용되는 파티셔닝 방법
- CAP 정리에서 일관성이란 단어는 선형성(linearizability)을 의미
- **ACID의 일관성은 불변식이 유효한 데이터베이스에서 시작하고 트랙잭션에서 실행된 모든 쓰기가 유효성을 보존한다면 불변식이 항상 만족해야 한다는 의미**


일관성은 실제로는 데이터베이스 속성이 아닌 애플리케이션의 속성이다.<br>
일관성의 아이디어는 애플리케이션의 불변식에 의존하며 일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것도 애플리케이션의 책임이다.

3. 격리성(Isolation)

> race condition
![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/9a24a9d1-e26b-4751-b355-854915c34bcb)


격리성은 트랜잭션은 다른 트랜잭션을 방해 할 수 없는 것을 말한다. 즉, 여러 트랜잭션이 동시에 실행되었더라도 그 결과가 순차적으로 실행되엇을 때와 결과가 동일해야함을 말한다

직렬성 격리(serializable isolation)는 성능 손해를 동반하므로 현실에서는 거의 사용되지 않는다.<br>
오라클의 경우 직렬성이라는 격리 수준은 있지만 실제로는 직렬성보다 보장이 약한 스냅숏 격리를 구현한 것이다.

4. 지속성(Durability)

지속성은 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장이다.<br>
지속성을 보장한다는 의미는 commit 전 다른 노드의 복제완료까지를 의미한다.

- 단일 노드 데이터베이스에서 지속성은 일반적으로 데이터가 하드디스크나 SSD 같은 비휘발성 자장소에 기록됐다는 뜻이다.
- 복제 기능이 있는 데이터베이스에서 지속성은 데이터가 성공적으로 다른 노드 몇 개에 복사됐다는 것을 의미한다.

#### 단일 객체 연산과 다중 객체 연산

1. 격리성 위반

격리성은 사용자2가 삽입된 이메일과 갱신된 개수를 모두 보거나 모두 보지 못하게 하고 일관성이 깨진 중간 지점은 없게 해준다

> dirty read
![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/8016fcd2-ae69-489b-a7f7-53660db6e813)


2. 원자성의 필요성

어느 시점에서 오류가 발생하면 우편함의 내용과 읽지 않은 메시지 개수가 동기화되지 않을 수 있다
원자적 트랜젝션은 개수 갱신이 실패하면 트랜젝션이 어보트되고 삽입된 이메일은 롤백된다

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/829ee886-e57d-456c-a5f5-b0007dbed143)


### 완화된 격리 수준

동시성 문제(경쟁조건)는 트랜잭션이 다른 트랙잭션에서 동시에 변경한 데이터를 읽거나 두 트랜잭션이 동시에 같은 데이터를 변경하려고 할 때만 나타난다.
떄문에 테스트로 발견,재현 및 추론이 어렵고, 데이터베이스는 오랫동안 트랜잭션 격리를 제공함으로써 애플리케이션 개발자들에게 동시성 문제를 감추려고 했다.

직렬성 격리는 여러 트랜잭션이 직렬적으로 실행되어 동일한 결과를 얻음을 보장하지만, 현실에서는 성능 비용이 있고 많은 데이터베이스들은 어떤 동시성 이슈로부터는 보호해주지만 모든 이슈로부터 보호해주지는 않는, 완화된 격리 수준을 사용한다.

#### 커밋 후 읽기

- 더티읽기(dirty reads)
  - 다른 트랜잭션에서 커밋되지 않은 데이터를 볼 수 있으면 이를 더티 읽기라고 부른다.
  - 문제점
    - 부분적으로 갱신된 상태를 보는 것은 사용자에게 혼란을 주며 다른 트랜잭션들이 잘못된 결정을 하는 원인이 될 수도 있다.
    - 트랜잭션이 abort되면 그때까지 쓴 내용은 모두 rollback 돼야 한다.
- 더티쓰기(dirty writes)
  - 먼저 쓴 트랜잭션이 commit/abort 될 때까지 두번째 쓰기를 지연시키는 방법을 사용한다.
  - 트랜잭션이 다중객체를 갱신하면 나쁜결과를 유발할 수 있는데, 커밋 후 읽기는 이러한 사고를 막아준다.
  - 하지만, 커밋 후 읽기는 카운터 증가 사이의 경쟁조건은 막지못한다.


커밋 후 읽기는 오라클 11g, 포스트그레스큐엘, SQL 서버 2012, 멤SQL(MemSQL) 등 많은 데이터베이스에서 기본 설정이다.

- DB에서 읽을 때 커밋된 데이터만 보게 된다 (no dirty read)
- DB에 쓸 때 커밋된 데이터만 덮어쓰게 된다 (no dirty write)

  
가장 흔한 방법으로 데이터베이스는 row lock 을 사용해 더티 쓰기를 방지한다. 트랜잭션에서 특정 객체(로우나 문서)를 변경하고 싶다면 잠금을 획득해야 하고 트랜잭션이 커밋되거나 어보트될 때까지 잠금을 보유하고 있어야 한다. 오직 한 트랜잭션만 어떤 주어진 객체에 대한 잠금을 보유할 수 있다.

쓰여진 모든 객체에 대해 데이터베이스는 과거에 커밋된 값과 현재 쓰기 잠금을 갖고 있는 트랜잭션에서 쓴 새로운 값을 기억하여 더티 읽기를 방지한다. 해당 트랜잭션이 실행 중인 동안 그 객체를 읽는 다른 트랜잭션들은 과거의 값을, 새 값이 커밋된 후에는 새 값을 읽을 수 있게 된다. 읽기 잠금은 읽기만 실행하는 여러 트랜잭션들이 오랫동안 실행되는 쓰기 트랜잭션 하나가 완료될 떄까지 기다려야 하기 떄문에 운용성이 나빠 현실에서는 잘 동작하지 않는다.


#### 스냅숏 격리와 반복 읽기

> 비반복읽기(nonrepeatable read) or 읽기 스큐(read skew)
![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/b714a10d-2e7c-48ad-acff-ee360dcb2260)

100달러를 계좌1에서 계좌2로 이체하는 트랜잭션이 처리되고 있는 순간에 앨리스가 계좌잔고를 보게되면 일시적으로 100달러가 사라진 것 처럼 보인다.

이런 일시적인 비일관성은 nonrepeatable read(비반복읽기) 혹은 read skew(읽기 스큐)라고 하며, 감내할 수 있는 정도의 문제이다.<br>
그런데 이러한 일시적인 관성을 감내하기 어려운 경우가 있다.(data freeze가 필요)

- 백업
- 분석 질의와 무결성 확인(데이터 무결성 검증 또는 오염 모니터링)


이를 위해 `스냅숏 격리`를 사용한다. 각 트랜잭션은 일관된 스냅숏으로 부터 읽는다.

#### 갱신 손실 방지
#### 쓰기 스큐와 팬텀
