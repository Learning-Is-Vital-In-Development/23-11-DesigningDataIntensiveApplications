# 7. 트랜잭션

트랜잭션의 필요성
- 현실 세계의 문제들
```text
- 1.데이터베이스 소프트웨어나 하드웨어는 언제라도 실패할 수 있음
- 2.애플리케이션은 언제라도 죽을 수 있음
- 3.네트워크가 끊키면 애플리케이션와 데이터베이스의 연결이 끊킬 수 있음
- 4.여러 클라이언트가 동시에 데이터베이스에 쓰기를 실행해서 다른 클라이언트가 쓴 내용을 덮어쓸 수 있음
- 5.데이터가 부분적으로 갱신될 수 있음 
- ...
```

- 트랜잭션은 애플리케이션에서 **몇 개의 읽기와 쓰기를 하나의 논리적 단위로 묶는 방법**이다. 개념적으로 한 트랜잭션 내의 모든 읽기와 쓰기는 한 연산으로 실행된다.
- 트랜잭션은 **전체가 성공 하거나 실패**한다 따라서 **트랜잭션이 실패하면 애플리케이션에서 안전하게 재시**도 할 수 있다.
- 트랜잭션을 몇 년동안 사용해 봤다면 트랜잭션이 뻔해 보일지 모르지만 이를 당연한 것으로 여기면 안 된다. 트랜잭션은 자연 법칙이 아니다. **데이터베이스에 접속하는 애플리케이션에서 프로그래밍 모델을 단순화하려는 목적**으로 만든 것이다.

트랜잭션의 애매함
트랜잭션의 여러형태와 각 형태별 제한 사항

트랜잭션의 여러형태 
- 커밋 후 읽기: 커밋 이 완료된 데이터만 읽을 수 있도록 한다.
- 스냅숏 격리
- 직렬성 보장: 엄밀한 의미에서의 트랜잭션


제한 사항들
- 더티 읽기
- 더티 쓰기
- 갱신 이상: 어떻게 극복하는가? FOR UPDATE로 격리해준다.
- 쓰기 스큐


## 7.1. 애매모호한 트랜잭션의 개념

현대의 거의 모든 관계형 데이터베이스와 일부 비관계형 데이터베이스는 트랜잭션을 지원. 이 들은 대부분 1975년에 첫 번째 SQL 데이터베이스인 IBM 시스템 R에 소개된 스타일을 따른다. 
**MySQL, PostgreSQL, Oracle, SQL Server 등에서 지원되는 트랜잭션은 놀라울 정도로 R의 트랜잭션과** 유사하다.

- 2000년대 후반에 복제, 파티셔닝 기능을 제공하는 NoSQL 데이터베이스가 인기를 얻기 시작하고 분산 데이터베이스가 홍보되면서 트랜잭션은 확장성의 안티테제이며 어떤 **대규모 시스템이라도 높은 성능과 고가용성을 유지하려면 트랜잭션을 포기해야한다는 믿음**이 퍼지기 시작했음
- 반대로 기존 RDB 벤더는 **트랜잭션 보장은 "값진 데이터가" 있는 "중대한 애플리케이션"에 필수적인 요구사항**이라고 주장함
- 두 관점 모두 완전한 과장으로 진실은 간단하지 않음 (**다른 모든 기술적 설계 선택과 마찬가지로 트랜잭션은 이점과 한계가 있음**)


## 7.1.1. ACID의 의미 
- 원자성(Atomicity)
	- 시스템은 연산을 **실행하기 전**이나 **실행한 후**의 상태에만 있을 수 있으며 그 중간 상태에는 머물 수 없다.
	- **여러 쓰기 작업이 하나의 원자적인 트랜잭션으로 묶여** 있는데 결함 때문에 **완료(커밋)될 수 없다면** **어보트 되고 데이터베이스는 이 트랜잭션에서 지금까지 실행한 쓰기를 무시하거나 취소**해야 한다.
	<원자성이 가지는 의미>
	- 원자성 없이는 여러 변경을 적용하는 도중 오류가 발생하면 어떤 변경이 일어났는지 찾기 어려움
	- 애플리케이션에서 재시도할 수 있지만 동일한 변경이 두 번 실행돼어 중복되거나 잘못된 데이터가 만들어질 수 있음
	- 원자성은 트랜잭션이 어보트됐다면 애플리케이션이 이 트랜잭션이 어떤 것도 변경하지 않았음을 알 수 있으므로 안전하게 재시도 할 수 있음

- 일관성(Consistency)
	- 데이터베이스가 "좋은 상태"에 있어야 한다는 것의 애플리케이션에 특화된 개념을 가리킴: 이는 애플리케이션의 책임 
- 격리성(ISolation)
	- 대부분 동시에 여러 클라이언트에서 데이터베이스에 접속하고, 클라이언트들이 데이터베이스의 다른 부분을 읽고 쓰면 아무 문제가 없겠지만 **동일한 데이터베이스 레코드에 접근하면 동시성 문제가 발생함**
		![7-1.동시에 카운터를 증가시키는 두 클라이언트의 사이의 경쟁 조건](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fba383863-486f-4ed8-90d7-88cda9a55121%2FScreen_Shot_2021-02-24_at_3.34.18.png&blockId=77b61993-dd3d-404c-bafd-3f67f5e10c0d)
	- 격리성은 **동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미**한다. 
	- 데이터베이스는 여러 트랜잭션이 동시에 실행됐더라도 트랜잭션이 커밋됐을 때의 결과가 트랜잭션이 순차적(직렬성)으로 실행됐을 때의 결과와 동일하도록 보장한다.
	- 그러나 직렬성 격리는 성능 손해를 동반하므로 현실에서는 거의 사용되지 않고 직렬성 격리보다 보장이 약한 "스냅숏 격리"등을 사용함

- 지속성(Durability)
	- 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에 기록한 모든 데이터는 손실되지 않는다는 보장이다.
	- 완벽한 지속성은 존재할 수 없다: 모든 하드디스크와 백업이 동시에 파괴돼 버리면 당연히 데이터베이스가 해줄 수 있는 것은 아무것도 없음.


## 7.1.2.  단일 객체 연산과 다중 객체 연산

- 원자성: 데이터베이스 쓰기는 전부 반영되거나 아무것도 반영되지 않은 것을 보장
- 격리성: 동시에 실행되는 트랜잭션들은 서로를 방해하지 말아야함, 예를 들어, 한 트랜잭션이 여러 번 쓴다면 다른 트랜잭션은 그 내용을 전부 볼 수 있든지 아무것도 볼 수 없든지 둘중 하나여야 하고 일부부만 볼 수 있어서는 안됨
	<사용자 1에 의해 신규 이메일이 추가 되었지만, 읽지않은 이메일 개수는 추가되지 않은 상태에서 사용자 2가 이메일 목록, 읽지 않은 이메일 개수를 가져온 예시>
	- 두 사용자의 트랜잭션이 격리되지 않았음
	![7-2. 격리성 위반, 더티 읽기](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ffbaaeea1-8365-45d3-8bf9-8818a7d45ec5%2FUntitled.png&blockId=8c3a5734-7751-445f-8302-c752883e2d05)

**트랜잭션의 핵심 기능은 오류가 생기면 어보트되고** 안전하게 **재시도**할 수 있다는 것이다. ACID 데이터베이스는 이 철학을 바탕으로 한다.
 
어보트된 트랜잭션을 재시도하는 것은 간단하고 효과적인 오류 처리 메커니즘 이지만 완벽하지는 않음
- 트랜잭션이 실제로는 성공했지만 서버가 클라이언트에게 커밋 성공을 알려주는 도중 네트워크가 끊켰을 때
- 오류가 과부하 때문이라면 트랜잭션 재시도가 문제를 개선하는 게 아니라 악화 시킬 수 있음 (재시도 횟수 제한, 지수적 백오프, 과부화와 관련된 오류를 별도로 처리해서 해결 할 수 있음)
- 일시적인 오류(네트워크 문제, 교착 상태, 격리성 위반, 장애 복구 등)만 재시도할 가치가 있으며 영구적인 오류(제약 조건 위반)는 재시도해도 소용이 없음
- 트랜잭션이 데이터베이스 외부에도 부수 효과가 있다면 트랜잭션이 어보트될 때도 재시도하며 부수 효과가 실행될 수 있음 (트랜잭션을 재시도할 때마다 이메일 발송)
- 클라이언트 프로세스가 재시도 중에 죽어버리면 그 클라이언트에서 데이터베이스에 쓰려고 했던 데이터가 모두 손실됨


# 7.2. 완화된 격리 수준

두 트랜잭션이 동일한 데이터에 접근하지 않으면 서로 의존하지 않으므로 안전하게 병렬 실행될 수 있다.
동시성 문제(경쟁 조건)는 **트랜잭션이 다른 트랜잭션에서 동시에 변경한 데이터를 읽거나 두 트랜잭션이 동시에 같은 데이터를 변경하려고 할 때만** 나타난다.

동시성 버그는 타이밍에 운이 없을 때만 촉발되기 때문에 테스트로 발견하기 어렵다. 게다가 타이밍 문제는 매우 드물게 발생할 수도 있으며 일반적으로 재현하기 어렵고 동시성 추론도 어렵다.

따라서 데이터베이스는 오랫동안 트랜잭션 격리를 제공함으로써 애플리케이션 개발자들에게 동시성 문제를 감추려고 했다. 

직렬성 격리로 **여러 트랜잭션이 실제로 직렬적으로 실행되도록 하면 좋겠지만** **직렬성 격리는 성능 비용이 커 많은 데이터베이스들은 직렬성 격리를 사용하지 않는다**. 따라서 어떤 동시성 이슈로부터는 보호해주지만 모든 이슈로부터는 보호해주지 않는 **완화된 격리 수준을 사용하는 시스템**들이 흔하다. 이런 완화된 격리성 수준들은 이해하기 어렵고 미묘한 버그를 유발할 수 있음에도 현장에서 사용된다.


### 7.2.1. 커밋 후 읽기

가장 기본적인 수준의 트랜잭션 격리는 커밋 후 읽기(read committed)다. 이 수준에서는 두가지를 보장해준다.
1. 데이터베이스에서 읽을 때 커밋된 데이터만 보게 된다 (더티 읽기가 없음).
2. 데이터베이스에서 쓸 때 커밋된 데이터만 덮어쓰게 된다 (더티 쓰기가 없음).

#### 7.2.1. 더티 읽기 방지

트랜잭션이 쓴 내용은 커밋이 된 후에 다른 트랜잭션에 보이도록 한다.

![7-4. 더티 읽기 방지](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F31d012f6-abbb-4fe8-b32f-3dbe56f196c2%2FUntitled.png&blockId=57cb10ed-8cf5-4b56-bf2c-988b621edfe3)


#### 7.2.1.2. 더티 쓰기 방지

더티 쓰기로 인한 문제를 위해 먼저 쓴 트랜잭션이 커밋되거나 어보트될 때까지 두 번째 쓰기를 지연시킨다.

![7-5. 더티 쓰기 예시](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2dc4c3dd-ab23-4cde-9eda-93ab96dacd22%2FUntitled.png&blockId=44905ddf-f8a7-44e7-b28c-ee8c56446bf2)


#### 7.2.1.3. 커밋 후 읽기 구현

##### <더티 쓰기 방지>
가장 흔한 방법으로 Row 수준 잠금을 사용해 더티 쓰기를 방지한다.
1. 트랜잭션에서 특정 객체를 변경하고 싶다면 먼저 객체에 대한 잠금을 획득해야한다.
2. 그리고 트랜잭션이 커밋되거나 어보트될 때까지 잠금을 보유하고 있어야 한다.
3. 오직 한 트랙잰션만 어떤 주어진 객체에 대한 잠금을 보유할 수 있다.

따라서 다른 트랜잭션에서 동일한 객체에 쓰기를 원한다면 첫 번째 트랜잭션이 커밋되거나 어보트된 후에야 잠금을 얻어 진행할 수 있다.

##### <더티 읽기 방지>
데이터를 읽을 때도 잠금을 사용해서 더티 읽기를 방지할 수 있다. 
하지만 읽기 잠금을 요구하는 경우는 현실에서는 잘 동작하지 않는다. 읽기만 실행하는 여러 트랜잭션들이 **오랫동안 실행되는 트랜잭션 하나가 완료될 때까지 기다려야 할 수 있기 때문**이다.
- 응답 시간을 느리게하고, 잠금 대기 때문에 애플리케이션 일부에서 발생한 지연이 애플리케이션의 완전히 다른 부분에 연쇄 효과를 만들 수 있음

대부분의 데이터베이스는 쓰여진 모든 객체에 대해 과거에 커밋된 값과 현재 쓰기 잠금을 갖고 있는 트랜잭션에서 쓴 새로운 값을 모두 기억해서 더티 읽기를 방지한다.
- 트랜잭션이 실행 중인 동안 그 객체를 읽는 다른 트랜잭션들은 과거의 값을 읽고, 새 값이 커밋돼야만 다른 트랜잭션들이 새 값을 일 수 있게 함

### 7.2.2. 스냅숏 격리와 반복 읽기

커밋 후 읽기 격리를 피상적으로 보면 트랜잭션이 해야 하는 모든 일을 해 주는 것으로 생각하는 것도 무리가 아니다. **어보트를 허용**하고 **트랜잭션의 미완료된 결과를 읽는 것을 방지**하며 **동시에 실행되는 쓰기가 섞이는 것을 막아준다.**

그러나 이 격리 수준을 사용하더라도 동시성 버그가 생길 수 있는 경우가 아직 많이 있다. 

비반복 읽기(non-repeatable read), 읽기 스큐(read skew)
- 여기서 스큐(skew)는 시간적인 이상 현상을 뜻한다.

![7-6. 읽기 스큐 예시](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Feed51b47-6404-4b00-a28f-132d9dbf9eca%2FUntitled.png&blockId=b2ad3c3c-28c5-41c8-94d7-4923f5a1c309)

송금 커밋이 완료된 상태이기 때문에 앨리스는 2번 계좌의 잔고를 400원으로 읽게된다.
- 읽기 스큐는 커밋 후 읽기 격리에서는 받아들일 수 있는 것으로 여겨진다. 앨리스가 봤던 계좌 잔고들은 읽은 시점에 실제로 커밋된 상태였다.

**몇 초 후 은행 웹사이트를 새로고침하면 거의 일관성 있는 계좌 잔고를 볼 수 있기**에, 위의 경우는 지속적인 문제가 되지는 않는다. 그러나 **백업, 분석질의와 무결성 확인 케이스에서는 이런 일시적인 비일관성을 감내할 수 없을 수** 있다.

- 백업: 백업 시 데이터베이스의 복사본을 만들기에 보통 오랜 시간이 소요된다. 백업 프로세스가 실행되는 동안계속 데이터베이스 쓰기가 발생하고 백업데이터의 일부는 과거 버전을, 다른 일부는 새 버전을 갖고 있다면 문제가 발생한다.
- 분석 질의와 무결성 확인: 분석 질의, 무결성 확인 시 대량의 데이터를 읽어오는 경우가 있다. 이 때 읽어오는 데이터의 버전이 다르다면 곤란한다.


스냅숏 격리로 **각 트랜잭션은 트랜잭션 시작 시 데이터베이스에 커밋된 상태였던 데이터만을 보도록** 함으로써 이 문제를 해결할 수 있다. 

스냅숏 격리는 백업이나 분석처럼 실행하는 데 오래 걸리며 읽기만 실행하는 질의에 요긴하고 PostgreSQL, MySQL, Oracle, SQL Server 등 다양한 RDB에 널리 쓰이는 기능이다.

스냅숏 격리 구현은 커밋 후 읽기 격리처럼 전형적으로 더티 쓰기를 방지하기 위해 쓰기 잠금을 사용한다.
쓰기를 실행하는 트랜잭션은 같은 객체에 쓰는 다른 트랜잭션의 진행을 차단할 수 있다. 그러나 읽을 때는 아무 잠금도 필요 없다.

스냅숏 격리 구현을 위해 데이터베이스는 객체마다 커밋된 버전 여러개를 유지할 수 있어야 한다. 진행 중인 여러 트랜잭션에서 서로 다른 시점의 데이터베이스 상태를 봐야 할 수도 있기 때문이다. 데이터베이스가 객체의 여러 버전을 함께 유지하므로 이 기법은 다중 버전 동시성 제어(multi-version concurrency control, MVCC)라고 한다.

데이터베이스가 스냅숏 격리가 아니라 커밋 후 읽기 격리만 제공할 필요가 있다면 객체마다 버전 두개씩만 유지하면 충분하다. 커밋된 버전과 덮어 쓰여졌지만 아직 커밋되지 않은 버전이다. 

MVCC 기반 스냅숏 격리 예시
- txid = 12 트랜잭션은 12보다 큰 txid를 가진 데이터는 읽지 않는다. (12번 트랜잭션은 txid= 13, created by = 13인 버전의 데이터는 12보다 크기 때문에 무시한다)
- 추가로 현재 txid = 12 기준으로 삭제되지 않은 데이터만 읽는다 (deleted by = 13은 읽고)

![7-7. 다중 버전 객체를 이용한 스냅숏 격리 구현](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F42a56daa-ca2f-4864-b507-07f1c7244354%2FUntitled.png&blockId=ecb4cb53-5cda-475f-a794-5af9822543e4)

스냅숏 격리는 유용한 격리 수준이며 읽기 전용 트랜잭션에 유용하다.
- 하지만 이를 구현한 많은 데이터베이스에서 다른 이름을 사용한다
- 오라클에서는 직렬성, PostgreSQL, MySQL에서는 반복 읽기(repeatable read) 라고 한다.


### 7.2.3. 갱신 손실 방지

애플리케이션이 데이터베이스에서 값을 읽고 변경한 후 변경된 값을 다시 쓸 때 발생할 수 있다.
만약 두 트랜잭션이 이 작업을 이 작업을 동시에 하면 두 번째 쓰기 작업이 첫 번째 변경을 포함하지 않으므로 변경 중 하나는 손실될 수 있다.

- 카운터를 증가시키거나 계좌 잔고를 갱신한다 (현재 값을 읽어서 새 값을 계산하고 갱신된 값을 다시 써야 한다)
- 복잡한 값을 지역적으로 변경한다.
- 사용자가 편집한 내용을 저장할 때 전체 페이지 내용을 서버에 보내서 현재 데이터베이스에 저장된 내용을 덮어 쓰드로 만들어진 위키에서 두 명의 사용자가 동시에 같은 페이지를 편집한다.

#### 7.2.3.1. 원자적 쓰기 연산

데이터베이스에서 제공하는 원자적 갱신 연산 사용하기

```sql
UPDATE counters SET value = value + 1 WHERE key = 'foo';
```

#### 7.2.3.2. 명시적인 잠금

```sql
BEGIN TRANSACTION;

SELECT * FROM figures
WHERE name = 'robot' AND game_id = 222
FOR UPDATE; -- FOR UPDATE: 데이터베이이스가 이 질의에 의해 반환된 모든 로루에 잠금을 획득

-- 이동이 유효한지 확인 후
-- 이전의 SELECT 에서 반환된 것의 위치를 갱신한다.
UPDATE figures SET position = 'c4' WHERE id = 1234;

COMMIT;
```

- 명시적인 잠금을 추가하는 것은 경쟁 조건을 유발하기 쉽기 때문에 주의해서 사용해야한다.

#### 7.2.3.3. 갱신 손실 자동 감지

원자적 쓰기 연산과 명시적인 잠금은 read-modify-write 주기가 순차적으로 실행되도록 강제함으로써 갱신 손신을 방지하는 방법이다.
대안으로 이들의 병렬 실행을 허용하고 트랜잭션 관리자가 갱신 손실을 발견하면 트랜잭션을 어보트시키고 read-modify-write 주기를 재시도하도록 강제하는 방법이 있다.
- 장점: 스냅숏 격리와 결합해 효율적으로 수행할 수 있다
- PostgreSQL, Oracle, SQL Server는 갱신 손실이 발생하면 자동으로 발경해서 문제가 되는 트랜잭션을 어보트 시킨다. 그러나 MySQL은 갱신 손실을 감지하지 않는다.

#### 7.2.3.4. Compare-and-set

마지막으로 읽은 후로 값이 변경되지 않았을 때만 갱신을 허용함으로써 갱신 손실을 회피

```sql
-- DB 구현에 따라 안전할 수도 안전하지 않을 수도 있다.
UPDATE wiki_pages SET content = 'new_content'
WHERE id = 1234 AND content = 'old_content'
```


### 7.2.4. 쓰기 스큐와 팬텀

다른 트랜잭션들이 동시에 같은 객체에 쓰려고 할 때 발생할 수 있는 두 가지 경쟁조건을 살펴봤음
- 더티 쓰기: 먼저 발생한 트랜잭션이 커밋하거나 어보트 될 때까지 다음 트랜잭션을 지연
- 갱신 손실: 원자적 쓰기 연산, 명시적 잠금 등으로 해결


최소 1명의 의사는 on_call로 대기해야하는 경우
- 현재 on_call이 2명 이상이면 on_call = false 상태로 바꿀 수 있음

![7-8. 애플리케이션 버그를 유발하는 쓰기 스큐의 예](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd7bab1d4-3052-4804-bf96-3a026a0f48aa%2FUntitled.png&blockId=4db564bc-fe24-421c-8921-f9a8216a47ad)

- 위와 같은 이상 현상을 쓰기 스큐라고 한다. 두 트랜잭션이 두 개의 다른 객체를 갱신하므로(앨리스와 밥이 각자 자신의 호출 대기 레코드를 갱신) 더티 쓰기도 갱신 손실도 아니다.
- 여기서는 충돌이 발생했다는 것이 덜 명확해 보이지만 분명히 경쟁 조건이다. 만약 두 트랜잭션이 한 번에 하나씩 실행됐다면 두 번째 의사는 호출 대기를 끄는게 방지됐을 것이다. 트랜잭션이 동시에 실행됐기 때문에 이상 동작이 나타날 수 있었다. 


<트랜잭션이 의존하는 로우를 명시적으로 잠그는 방법>
```sql
BEGIN TRANSACTION;

SELECT * FROM doctors
WHERE on_call = true
AND shift_id = 1234 FOR UPDATE;  -- FOR UPDATE로 이 질의가 반환하는 모든 로우를 잠근다.

UPDATE doctors
SET on_call = false
WHERE name = 'Alice'
AND shift_id = 1234;

COMMIT;
```


추가적인 쓰기 스큐의 예
- 회의실 예약 시스템: 동시에 같은 회의실을 중복 예약할 수 없음
```sql
BEGIN TRANSACTION;

-- 정오에서 오후 1시까지의 시간과 겹치는 예약이 존재하는지 확인
SELECT COUNT(*) FROM bookings
WHERE room_id = 123 
AND end_time > '2023-01-01 12:00' AND start_time < '2023-01-01 13:00';

-- 이전 질의가 0을 반환했다면
INSERT INTO bookings (room_id ,start_time, end_time, user_id)
VALUES(123, '2023-01-01 12:00', '2023-01-01 13:00', 666);

COMMIT;
```

- 다중 플레이어 게임: 두명의 플레이어가 동시에 같은 물체를 옮김
- 사용자명 획득: 계정 생성 시 각 사용자가 유일한 사용자명을 가져야함 (사용자명 Unique 제약조건)
- 이중 사용 방지: 돈이나 포인트를 사용자가 갖고 있는 것보다 더 많이 지불하지 않도록 하기

#### 7.2.4.1. 쓰기 스큐를 유발하는 팬텀

위의 모든 예는 비슷한 패턴을 따른다.
1. Select 질의가 어떤 검색 조건에 부합하는 로우를 검색함으로써 어떤 요구사항을 만족하는지 확인
2. 첫 번째 질의의 결과에 따라 애플리케이션 코드는 어떻게 진행할지 결정한다.
3. 애플리케이션이 계속 처리하기로 결정했다면 데이터베이스에 쓰고 트랜잭션을 커밋한다.
	- 이 쓰기의 효과로 2단계를 결정한 전제 조건이 바뀐다. 1단계의 Select를 재실행하면 다른 결과를 얻게 된다. Ex) 의사의 수가 2명에서 1명이 되었다.

위 과정은 다른 순서로 일어날 수도 있다. 예를 들어 먼저 쓰기(Insert, Update, Delete)를 실행한 후 SELECT 질의를 실행하고 마지막으로 그 질의 결과에 따라 어보트할지 커밋할지 결정할 수 있다.

의사 호출 대기 예시의 경우 3단계에서 변경될 로우가 1단계에서 반환된 로우 중 하나였기에 FOR UPDATE로 로우를 잠금으로써 쓰기 스큐를 회피할 수 있다. 하지만 나머지 예시들은 1단계의 질의가 아무 로우도 반환하지 않기에 FOR UPDATE로 아무것도 잠글 수 없다.

팬텀(Phantom): 어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과
- 스냅숏 격리는 읽기 전용 질의에서는 팬텀을 회피하지만 설명한 예시 처럼 쓰기 트랜잭션에서는 팬텀이 쓰기 스큐의 특히 까다로운 경우를 유발할 수 있음

#### 7.2.4.2. 충돌 구체화
팬텀의 문제가 잠글 수 없는 객체가 없다는 것이라면 인위적으로 데이터베이스에 잠금 객체를 추가할 수 있지 않을까?
예를 들어 회의실 예약의 경우 시간 슬롯과 회의실에 대한 테이블을 만들어 충돌을 구체화할 수 있다.
하지만 충돌을 구체화하는 방법은 알아내기 어렵고 오류가 발생하기 쉽다. 또한 동시성 제어 메커니즘이 애플리케이션에서 데이터모델로 새어 나오는 것도 보기 좋지 않다. 이런 까닭으로 충돌 구체화는 다른 대안이 불가능할 때 최후의 수단으로 고려해야 한다. 대부분의 경우에 직렬성 격리 수준이 훨씬 더 선호된다.
