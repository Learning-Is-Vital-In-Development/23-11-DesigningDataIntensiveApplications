# 07장. 트랜잭션

## Overview

트랜잭션은 데이터베이스에 접속하는 애플리케이션에서 프로그래밍 모델을 단순화하려는 목적으로 만든 것으로, 애플리케이션에서의 어느 정도의 잠재적인 오류 시나리오와 동시성 문제를 무시할 수 있다.

트랜잭션이 필요한지 어떻게 알 수 있을까? 이 질문에 답하려면 먼저 트랜잭션이 제공하는 안정성 보장과 관련된 비용에 대해 정확히 이해해야 한다. 언뜻 보기에는 간단해 보이지만 실제로는 여러 가지 미묘하면서도 중요한 세부 사항이 적용한다.

## 애매모호한 트랜잭션의 개념

비관계형(NoSQL) 데이터베이스가 인기를 얻기 시작하며, 기존의 관계형 데이터베이스의 현 상황을 개선하는 것을 목표로 했고, 트랜잭션은 이 움직임의 주요 피해자였다.

트랜잭션은 확장성의 안티테제이며 어떤 대규모 시스템이라도 높은 성능과 고가용성을 유지하려면 트랜잭션을 포기해야 한다는 믿음이 널리 퍼졌다. 데이터베이스 벤더 진영에선 중대한 애플리케이션에 필수적인 요구사항임을 주장하곤 한다.

### ACID의 의미

트랜잭션이 제공하는 안전성 보장은 흔히 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability)을 의미하는 약어인 ACID로 잘 알려져 있다. 하지만 각 데이터베이스 마다 ACID 구현이 제각각이며 모호함이 많이 있다.

ACID를 따르지 않는 시스템을 때로 `BASE` 라고 부르며, 기본적으로 가용성을 제공하고, 유연한 상태를 가지며, 최종적 일관성을 지닌다는 뜻이다.

### 원자성

일반적으로 원자적이란 더 작은 부분으로 쪼갤 수 없는 뭔가를 가리킨다. 이 단어는 컴퓨터의 여러 분야에서 비슷하지만 미묘하게 다르게 사용된다.

ACID의 원자성은 클라이언트가 쓰기 작업 몇 개를 실행하려 하는데 그중 일부만 처리된 후 결함이 생겨 완료(커밋)될 수 없다면 무슨 일이 생겼는지 설명하며, 지금까지 실행한 쓰기를 무시하거나 취소해야 한다. 이는 여러 쓰기 작업이 하나의 원자적인 트랜잭션으로 묶여있기 때문이다.

### 일관성

일관성이란 단어는 굉장히 여러 의미로 쓰인다.

- 5장에서의 `복제 일관성`과 비동기식으로 복제되는 시스템에서 발생하는 `최종적 일관성` 문제에 대해 이야기 했다.
- `일관성 해싱` 은 어떤 시스템들에서 재균형화를 위해 사용하는 파티셔닝 방법이다.
- CAP 정리에서 일관성이란 단어는 `선형성` 을 의미한다.
- ACID 맥락에서의 일관성은 데이터베이스가 `좋은 상태` 에 있어야 한다는 것의 애플리케이션에 특화된 개념을 가리킨다.

ACID 일관성의 아이디어는 항상 진실이어야 하는, 데이터에 관한 어떤 선언(`불변식` )이 있는 것이다.

그러나 일관성의 아이디어는 `애플리케이션` 의 불변식 개념에 의존하고, 일관성을 유지하도록 트랜잭션을 올바르게 정의하는 것은 애플리케이션의 책임이다.(일반적으로 애플리케이션에서 데이터가 유효한지 아닌지를 정의하고 데이터베이스는 데이터를 저장할 뿐이다.)

애플리케이션에서 일관성을 달성하기 위해 데이터베이스의 원자성과 격리성 속성에 기댈 수는 있지만 데이터베이스만으로 되는 것은 아니기 때문에 **C는 실제로 ACID에 속하지 않는다.**

### 격리성

대부분 동시에 여러 클라이언트에서 데이터베이스에 접속하며, 동일한 데이터베이스 레코드에 접근시 동시성 문제(경쟁 조건)에 맞닥뜨리게 된다.

ACID에서 격리성은 동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미한다. 즉 트랜잭션은 다른 트랜잭션을 방해할 수 없다.

고전적인 데이터베이스 교과서에서는 격리성을 `직렬성` 이라는 용어로 공식화하며, 이는 각 트랜잭션이 전체 데이터베이스에서 실행되는 유일한 트랜잭션인 것처럼 동작할 수 있다는 것을 의미한다.

즉, 동시에 실행됐더라도, 커밋됐을 때의 결과가 `순차적` 으로 실행했을 때와 동일하도록 보장한다.

그러나, 직렬성 격리(`Serializable isolation` )는 성능 손해를 동반하기 때문에 현실에서는 거의 사용되지 않으며, 오라클의 경우 구현조차 하지 않고 `직렬성` 이라는 격리 수준이 있지만 실제로는 `스냅숏 격리` 를 통해 구현한다.

### 지속성

지속성은 트랜잭션이 성공적으로 커밋됐다면 하드웨어 결함이 발생하거나 데이터베이스가 죽더라도 트랜잭션에서 기록한 모든 데이터는 손실되지 않는다는 보장이다.

단일 노드 데이터베이스에서 지속성은 일반적으로 비휘발성 저장소에 기록됐다는 뜻이며, `쓰기 전 로그` 나 비슷한 수단을 동반한다. 복제 기능이 있는 데이터베이스에서 지속성은 데이터가 성공적으로 다른 노드 몇 개에 복사 됐다는 것을 의미할 수 있다.

지속성을 보장하려면 데이터베이스는 트랜잭션이 성공적으로 커밋됐다고 보고하기 전에 쓰기나 복제가 완료될 때까지 기다려야 한다.

모든 하드디스크와 백업이 동시에 파괴돼 버리면 데이터베이스가 해줄 수 있는 일은 아무것도 없듯이, 완벽한 지속성은 존재하지 않는다. 과거에는 지속성이 아카이브 테이브에 기록하는 것을 의미했으며, 그 후로는 디스크나 SSD에 기록하는 것으로 생각됐다. 더 최근에는 복제를 의미하기도 한다.

현실에서 절대적 보장을 제공하는 한 가지 방법은 없으며, 여러 기법들을 함께 쓸 수 있고 그래야만 한다.

### 단일 객체 연산과 다중 객체 연산

ACID에서 원자성과 격리성은 클라이언트가 한 트랜잭션 내에서 여러 번의 쓰기를 하면 데이터베이스가 어떻게 해야 하는지를 서술한다.

- 원자성 : 전부 반영되거나 아무것도 반영되지 않는 것을 보장함으로써 부분 실패 걱정이 없다.
- 격리성 : 동시에 실행되는 트랜잭션들은 서로를 방해하지 말아야 한다.

이 정의는 한 번에 여러 객체(로우, 문서, 레코드)를 변경할 수 있다고 가정한다. `다중 객체 트랜잭션` 은 흔히 데이터의 여러 조각이 동기화된 상태로 유지돼야 할 때 필요하다.

격리성은 사용자가 삽입된 데이터에 대한 갱신 데이터를 모두 보거나 모두 보지 못하게 하고 일관성이 깨진 중간 지점을 보는 일은 없게 해준다.(격리성이 깨질 경우 트랜잭션이 다른 트랜잭션에서 썼지만 커밋되지 않은 데이터를 읽는 `더티리드` 가 발생할 수 있다.)

원자성은 오류가 발생하면 트랜잭션에서 이전에 실행한 쓰기를 취소해서 일관성이 깨진 상태가 되지 않도록 한다.

- 관계형 데이터베이스
  기본적으로 TCP 연결을 기반으로 하며, 어떤 특정 연결 내에서 `BEGIN TRANSACTION` 문과 `COMMIT` 문 사이의 모든 것은 같은 트랜잭션에 속하는 것으로 여겨진다.
- 비관계형 데이터베이스
  연산을 묶는 방법이 없는 경우가 많다. 다중 객체 API가 있더라도 다중 연산을 제공할 순 있으나, 반드시 트랜잭션 시맨틱을 뜻하지 않으며, 일부에 대한 연산만 갱신된 상태가 될 수 있다.

### 단일 객체 쓰기

원자성과 격리성은 단일 객체를 변경하는 경우에도 적용된다. 예를 들어 20KB의 JSON 문서를 데이터베이스에 쓴다고 해보자.

- 첫 10KB를 보낸 후에 네트워크 연결이 끊기면 남은 10KB의 JSON 조각을 저장할 것인가?
- 데이터베이스가 디스크에 기존 값을 덮어쓰다 전원이 나가면 기존 값과 새 값이 붙어 있을까?
- 문서를 쓰고 있을 때 다른 클라이언트에서 그문서를 읽으면 부분적 갱신된 값을 읽을까?

단일 객체 수준에서의 원자성은 장애 복구용 로그를 써서 구현이 가능하며, 격리성은 각 객체에 잠금을 사용해(동시에 한 스레드만 객체에 접근하도록) 구현할 수 있다.

어떤 데이터베이스는 증가 연산처럼 더 복잡한 원자적 연산을 제공하기도 하며, 증가 연산은 read-modify-write 주기를 반복할 필요를 없앤다. 비슷하게 유명한 것으로 compare-and-set연산이 있으며, 이 연산은 변경하려는 값이 누군가에 의해 동시에 바뀌지 않았을 때만 쓰기가 허용된다.

이러한 단일 객체 연산은 여러 클라이언트에서 동시에 같은 객체에 쓰기 연산을 할 때 갱신 손실(lost update)을 방지하므로 유용하다. 또 다른 단일 객체 연산은 ‘경량 트랜잭션(light-weight transaction)으로 불린다. 그러나 **트랜잭션은 보통 다중 객체에 대한 다중 연산을 하나의 실행 단위로 묶는 메커니즘으로 이해된다.**

### 다중 객체 트랜잭션의 필요성

다중 객체 트랜잭션은 여러 파티션에 걸쳐서 구현하기가 우렵고 매우 높은 가용성과 성능이 필요한 곳에서 방해가 되는 시나리오도 있기 때문에 많은 분산 데이터스토어는 다중 객체 트랜잭션 지원을 포기했다. 하지만 분산 데이터베이스에서 근본적으로 트랜잭션을 막는 것은 아무것도 없다.

단일 객체 삽입, 갱신, 삭제만으로 충분한 사용 사례도 있지만, 많은 다른 경우에는 여러 개의 다른 객체에 실행되는 쓰기 작업은 코디네이션돼야 한다.

- RDB 모델에서 로우는 종종 외래 키를 가진다. 다중 객체 트랜잭션은 참조가 유효한 상태로 유지되도록 보장해준다. 서로 참조하는 여러 레코드를 삽입할 때 참조키는 올바르게 입력되어야 하며 최신 정보를 반영해야 한다.
- 문서 데이터 모델에서 함께 갱신돼야 하는 필드들이 단일 객체로 다뤄지는 동일한 문서 내에 존재하는 경우가 흔하기 때문에 단일 문서 갱신시에는 다중 객체 트랜잭션이 필요 없다. 그러나, 조인 기능이 없는 문서 데이터베이스는 비정규화를 장려하기도 하며, 이는 여러 문서를 한번에 갱신해야 한다. 트랜잭션은 이런 상항에서 비정규화된 데이터가 동기화가 깨지는 것을 방지하는데 유용하다.
- 보조 색인이 잆는 데이터베이스에서는 값이 변경될 때마다 Index도 갱신돼어야 한다. 트랜잭션 관점에서 INDEX는 서로 다른 데이터베이스 객체이다. 예를 들어 격리성이 없을 경우 어떤 INDEX에서는 레코드가 보이지만 다른 INDEX에선 갱신되지 않아 보이지 않을 수 있다.

트랜잭션이 없더라도 이런 애플리케이션들을 구현할 순 있지만, 원자성이 없으면 오류 처리가 훨씬 더 복잡해지고 격리성이 없으면 동시성 문제가 생길 수 있다.

### 오류와 어보트 처리

트랜잭션의 핵심 기능은 오류가 생기면 어보트되고 안전하게 재시도할 수 있다는 것이다. ACID 데이터베이스는 이 철학을 바탕으로 한다. 하지만 모든 시스템이 이 철학을 따르진 않으며, 특히 리더 없는 복제를 사용하는 경우 `최선을 다하는` 원칙을 기반으로 가능한 모든 것을 하며, 그 때문에 오류가 발생하면 이미 한 일은 취소하지 않는다. 따라서 오류 복구는 애플리케이션에게 책임이 있다. 이를테면 ORM프레임워크들은 어보트된  트랜잭션을 재시도 하지 않는다.

어보트된 트랜잭션을 재시도 하는 것은 간단하고 효과적인 오류 처리 메커니즘이지만 완벽하지는 않다.

- 트랜잭션이 성공했지만 서버가 클라이언트에게 알리는 도중 네트워크가 끊어졌을때 클라이언트가 재시도 하면 트랜잭션이 두 번 실행된다.(애플리케이션에 중복 제거 메커니즘이 없을경우)
- 오류가 과부화 때문이라면 재시도는 오히려 문제를 악화시킬 수 있다.
- 일시적인 오류만 재시도할 가치가 있으며, 영구적인 오류는 재시도해도 아무 소용이 없다.
- 여러 개의 다른 시스템들이 반드시 함께 커밋되거나 어보트되게 만드려면 2PC(two-phase commit)을 사용할 수 있다.
- 클라이언트 프로세스가 재시도중 죽어버리면 그 클라이언트에서 쓰려고 했던 데이터가 모두 손실된다.

## 완화된 격리수준

두 트랜잭션이 동일한 데이터에 접근하지 않으면 서로 의존하지 않으므로 안전하게 병렬 실행될 수 있다. 동시성 문제의 경우 동시에 변경한 데이터를 읽거나 변경하려 할 때만 나타난다.

동시성 버그는 타이밍적 문제와 재현하기도 어려우며, 추론하기도 어려운 까닭에 데이터베이스는 오랫동안 `트랜잭션 격리` 를 제공함으로써 문제를 감추려 해다. 이론상 격리성은 동시성이 없는 것처럼 해동할 수 잇으므로 개발자들의 부담을 줄여줘야 한다.

현실에선 유감스럽게도 간단하지 않으며, 직렬성 격리의 경우 성능 비용이 있다. 즉 어떤 동시성 이슈로부터는 보호해 주지만 모든 이슈로부터 보호해주지 않는, 완화된 격리 수준을 사용하는 시스템들이 흔하다.

완화된 트랜잭션 격리가 유발하는 동시성 버그는 단순 이론적 문제만이 아닌 금전적 손실까지 일으킨다. 이런 문제에 대한 유명한 견해로 굼융 데이터를 다룬다면 ACID 데이터베이스를 사용하라가 있지만 핵심을 벗어난다. 인기 있는 관계형 데이터베이스 시스템조차 완화된 격리성을 사용하는 경우가 많아 이런 버그가 발생하는 것을 반드시 막아주지는 못한다.

### 커밋 후 읽기

가장 기본적인 수준의 트랜잭션 격리는 `커밋 후 읽기(read commited)` 다. 이 수준에서는 두 가지를 보장해 준다.

- 커밋된 데이터만 보게 된다.(더티리드가 없음)
- 데이터베이스에 쓸 때 커밋된 데이터만 덮어쓰게 된다.(더티 쓰기가 없음)

### 더티 읽기 방지

트랜잭션이 데이터베이스에 데이터를 섰지만 아직 커밋되거나 어보트 되지 않은 상태에서 다른 트랜잭션이 해당 데이터를 볼 수 있다면 이를 `더티리드` 라고 부른다.

커밋 후 읽기 격리 수준에서 실행되는 트랜잭션은 더티리드를 막아야 한다. 트랜잭션이 쓴 내용은 커밋된 후에야 다른 트랜잭션에게 보인다는 뜻이다.

더티리드를 막는 게 유용한 이유가 몇 가지 있다.

- 트랜잭션이 여러 객체를 갱신하는데 더티 읽기가 생기면 다른 트랜잭션이 일부는 갱신된 값을 일부는 갱신되지 않은 값을 볼 수 있다. 부분적으로 갱신된 상태에 있는 데이터베이스를 보는 것은 사용자에게 혼란스러우며, 다른 트랜잭션들이 잘못된 결정을 하는 원인 될 수 있다.
- 트랜잭션이 어보트되면 그때까지 쓴 내용은 모두 롤백돼야 한다. 만일 더티리드를 허용한다면 롤백될 데이터를 볼 수 있다.

### 더티 쓰기 방지

먼저 쓴 내용이 아직 커밋되지 않은 트랜잭션에서 쓴 것이고 나중에 실행된 쓰기 작업이 커밋되지 않은 값을 덮어써버리는 것을 더티쓰기라고 부른다. 커밋 후 읽기 격리 수준에서 실행되는 트랜잭션은 보통 먼저 쓴 트랜잭션이 커밋되거나 어보트될 떄까지 두 번째 쓰기를 지연시키는 방법을 사용하여 더티 쓰기를 방지한다.

### 커밋 후 읽기 구현

커밋 후 읽기는 매우 널리 쓰이는 격리 수준이다. 오라클 11g, 포스트그레스큐엘, SQL 서버 2012 등의 데이터베이스에서는 기본 설정이다.

가장 흔한 방법으로 로우 수준의 잠금을 사용해 더티 쓰기를 방지한다. 트랜잭션에서 특정 객체를 변경하고 싶다면 먼저 해당 객체에 대한 잠금을 획득해야 한다. 그리고 커밋되거나 어보트될 때까지 잠금을 보유하고 있어야 한다.

더티리드는 어떻게 막을 수 있을까? 한 가지 선택은 동일한 잠금을 써서 객체를 읽기 원하는 트랜잭션이 잠시 잠금을 획득한 후 읽기가 끝난 후 바로 해제하는 것이다. 그러나 읽기 잠금ㅇ르 요구하는 방법은 현실에서 잘 동작하지 않는다. 여러 트랜잭션들이 오랫동안 실행되는 쓰기 트랜잭션 하나가 완료될 때까지 기다려야 할 수 있기 때문이다. 이런 이유로 대부분의 데이터베이스는 트랜잭션이 커밋된 후에야 트랜잭션을 읽는 방법을 선택한다.

쓰여진 모든 객체에 대해 데이터베이스는 과거에 커밋된 값과 현재 쓰기 잠금을 갖고 있는 트랜잭션에서 쓴 값을 모두 기억한다. 해당 트랜잭션에 실행 중인 동안 그 객체를 읽는 다른 트랜잭션들은 과거의 값을 읽게 된다.

### 스냅숏 격리와 반복 읽기

커밋 후 읽기 격리를 사용하더라도 동시성 버그가 생길 수 있는 경우가 아직 많이 있다.

![image](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/71249347/cc99caa6-0b10-4c29-94bb-a060f840d7d3)

위의 그림에서 엘리스는 1000만원을 2계좌로 나누려 한다. 그러나 엘리스의 트랜잭션에선 총 금액이 900으로 100만원이 사라진 것처럼 보인다. 이런 이상 현상을 `비반복 읽기` 나 `읽기 스큐` 라고 한다. 물론 지속적인 문제는 아니지만 어떤 상황에서는 이런 일시적인 비일관성을 감내할 수 없는 경우도 있다.

스냅숏 격리는 이런 문제의 가장 흔한 해결책이다. 각 트랜잭션은 데이터베이스의 일관된 스냅숏 으로 부터 읽는다. 즉 커밓된 상태였던 모든 데이터를 본다. 데이터가 나중에 다른 트랜잭션에 의해 바뀌더라도 각 트랜잭션은 특정한 시점의 과거 데이터를 볼 뿐이다.

스냅숏 격리는 백업이나 분석처럼 실행하는 데 오래 걸리며 읽기만 실행하는 질의에 요긴하다. 질의가 실행 중일 때 동시에 대상 데이터가 변경된다면 그 질의의 의미에 대해 추론하기 매우 어렵다. 트랜잭션이 특정 시점에 고정된 데이터베이스의 일관된 스냅숏만 볼 수 있다면 이해하기가 훨씬 쉬워진다.

### 스냅숏 격리 구현

스냅숏 격리 구현은 커밋 후 읽기 격리처럼 전형적으로 더티쓰기를 방지하기 위해 쓰기 잠금을 사용한다. 쓰기를 실행하는 트랜잭션은 같은 객체에 쓰는 다른 트랜잭션의 진행을 차단할 수 있다는 뜻이다.

그러나 읽을 때는 아무 잠금도 필요 없다. 성능 관점에서 스냅숏 격리의 핵심 원리는 읽는 쪽에서 쓰는 쪽을 결코 차단하지 않고 쓰는 쪽에서 읽는 쪽을 결코 차단하지 않는다는 것이다. 따라서 데이터베이스는 잠금 경쟁 없이 쓰기 작업이 일상적으로 처리되는 것과 동시에 일관성 있는 스냅숏에 대해 오래 실행되는 읽기 작업의 처리가 가능하다.

스냅숏 격리를 구현하기 위해 데이터베이스는 더티리드를 막는 데 쓰는 메커니즘을 일반화한 방법을 사용한다. 데이터베이스는 객체마다 커밋된 버전 여러 개를 유지할 수 있으며, 이 기법은 `다중 버전 동시성 제어(MVCC)` 라고 한다.

스냅숏 격리를 지원하는 저장소 엔진은 보통 커밋 후 읽기 격리를 위해서도 MVCC를 사용한다. 전형적인 방법은 커밋 후 읽기는 질의마다 독립된 스냅숏을 사용하고 스냅숏 격리는 전체 트랜잭션에 대해 동일한 스냅숏을 사용하는 것이다.

### 일관된 스냅숏을 보는 가시성 규칙

트랜잭션은 데이터베이스에서 객체를 읽을 때 트랜잭션 ID를 사용해 어떤 것을 볼 수 있고 어떤 것을 볼 수 없는지 결정한다.

- 데이터베이스는 각 트랜잭션을 시작할 때 그 시점에 진행 중인 모든 트랜잭션의 목록을 만든다.
- 어보트된 트랜잭션이 쓴 데이터는 모두 무시된다.
- 트랜잭션 ID가 더 큰 트랜잭션이 쓴 데이터는 커밋 여부에 관계없이 모두 무시된다.
- 그 박의 모든 데이터는 애플리케이션의 질읠 볼 수 있다.

바꿔 말하면 아래 두 조건이 모두 참이면 객체를 볼 수 있다.

- 읽기를 실행하는 트랜잭션이 시작한 시점에 읽기 대상 객체를 생성한 트랜잭션이 이미 커밋된 상태였다.
- 읽기 대상 객체가 삭제된 것으로 표시되지 않았다. 또는 삭제된 것으로 표시됐지만 읽기를 실행한 트랜잭션이 시작한 시점에 삭제 요청 트랜잭션이 아직 커밋되지 않았다.

### 색인과 스냅숏 격리

다중 버전 데이터베이스에서 색인은 어떻게 동작할까? 하나의 선택지는 인덱스가 객체의 모든 버전을 가리키게 하고 인덱스 질의가 현재 트랜잭션에서 볼 수 없는 버전을 걸러내게 하는 것이다.

현실에서는 각 데이터베이스 마다 여러 방식으로 구현하여 사용하고 있다.

- 포스트그레스큐엘 : 도일한 객체의 다른 버전들이 같은 페이지에 저장될 수 있다면 색인 갱신을 회피하는 최적화를 한다.
- 카우치DB, 데이토믹, LMDB : B트리를 사용하지만 추가 전용이며 쓸 때 복사되는 방식을 사용한다. 트리의 페이지가 갱신될 때 덮어쓰는 방식 대신 각 변경된 페이지의 새로운 복사본을 생성한다.

### 반복 읽기와 혼란스러운 이름

스냅숏 격리는 유용한 격리 수준이며 특히 읽기 전용 트랜잭션에서 유용하다. 그러나 이를 구현한 각 데이터베이스 마다 다른 이름을 사용한다. 오라클 에서는 `직렬성`, PostgresQL, MySQL 에서는 `반복 읽기(repeatable read)` 라고 한다.

이렇게 혼란스러운 이유는 SQL 표준에 스냅숏 격리의 개념이 없기 때문이다. SQL 표준의 격리 수준은 모호하고 부정확하며 표준이 그래야 하는 것만큼 구현 독립적이지 않다. 여러 데이터베이스가 반복 읽기를 구현하지만 이것들이 실제로 제공하는 보장에는 커다란 차이가 있다.

결과적으로 반복 읽기가 무슨 뜻이진 실제로 아는 사람은 아무도 없다.

### 갱신 손실 방지

동시에 실행되는 쓰기 트랜잭션 사이에 발생할 수 있는 흥미로운 종류의 충돌중 하나로 가장 널리 알려진 것은 `갱신손실(lost update)` 이며, 갱신 손실 문제는 애플리케이션이 데이터베이스에서 값을 읽고 변경한 후 변경된 값을 다시 쓸 때 발생할 수 있다.

만약 두 트랜잭션이  이작업을 도잇에 하면 두 번째 쓰기 작업이 첫 번째 변경을 포함하지 않으므로 변경 중 하나는 손실 될 수 있다.

- 카운터를 증가시키거나 계좌 잔고를 갱신
- 복잡한 값을 지역적으로 변경
- 사용자가 편집한 내용을 저장할 때 전체 페이지 내용을 서버에 보내서 현재 데이터베이스에 저장된 내용을 덮어 쓰도록 만들어진 위키에서 두 명의 사용자가 동시에 같은 페이지를 편집하는 경우

### 원자적 쓰기 연산

여러 데이터베이스에서 원자적 갱신 연산을 제공한다. 이 연산은 애플리케이션 코드에서 read-modify-wirte 주기를 구현할 필요를 없애준다. 예를 들어 다음 명령은 대부분의 관계형 데이버에스에서 동시성 안전(concurrency-safe) 하다.

```sql
UPDATE counters SET value = value + 1 WHERE key = 'foo';
```

마찬가지로 몽고  DB 같은 문서 데이터베이스는 JSON 문서의 일부를 지역적으로 변경하는 원자적 연산을 제공하고 레디스는 우선순위 큐 같은 데이터 구조를 변경하는 원자적 연산을 제공한다.

원자적 연산은 보통 객체를 읽을 때 그 객체에 독점적인 잠금을 획득해서 구현한다. 그래서 갱신이 적용될 때까지 다른 트랜잭션에서 그 객체를 읽지 못하게 한다. 이 기법을 `커서 안정성` 이라고 부리기도 한다.

ORM 프레임워크를 사용하면 뜻하지 않게 데이터베이스가 제공하는 원자적 연산을 사용하는 대신 불안전한 read-modify-write 주기를 실행하는 코드를 작성하기 쉽다. 이는 잠재적으로는 테스트로 발견하기 어려운 미묘한 버그의 원인이 될 수 있다.

### 명시적 잠금

데이터베이스에 내장된 원자적 연산이 필요한 기능을 제공하지 않을 때 갱신 손실을 막는 또 다른 선택지는 애플리케이션에서 갱신할 객체를 명시적으로 잠그는 것이다. 그러면 애플리케이션이 read-modify-write 주기를 수행할 수 있고 다른 트랜잭션이 동시에 같은 객체를 읽으려고 하면 첫 번째 read-modify-write 주기가 완료될 때까지 기다리도록 강제 된다.

```sql
SELECT * FROM figures
	WHERE name = 'robot' AND game_id = 222
	FOR UPDATE;
```

FOR UPDATE 절은 데이터베이스가 이 질의에 읳 ㅐ반환된 모든 로우에 잠금을 획득해야 함을 가리킨다.

### 갱신 손실 자동 감지

원자적 연산과 명시적 잠금의 대안으로 병렬 실행을 허용하고 트랜잭션 관리자가 갱신 손실을 발견하면 트랜잭션을 어보트시키고 read-modify-write 주기를 재시도하도록 강제하는 방법이 있다.

이 방법의 이점은 데이터베이스가 이 확인을 스냅숏 격리와 결합해 효율적으로 수행할 수 있다는 것이며, 실제 퐆스트그레스큐엘의 반복읽기, 오라클의 직렬성 SQL 서버의 스냅숏 격리 수준은 갱신 손실이 발생하면 자동으로 발견해서 문제가 되는 트랜잭션을 어보트 시킨다.

그러나 **MySQL/InnoDB의 반복 읽기는 갱신 손실을 감지하지 않는다**. 따라서 MySQL은 이 정의에 따르면 스냅숏 격리를 제공하지 않는다고 주장한다.

### Compare-and-set

트랜잭션을 제공하지 않는 데이터베이스 중에는 원자적 compare-and-set 연산을 제공하는 것도 있다. 이 연산의 목적은 값을 마지막으로 읽은 후로 변경 되지 않았을 때만 갱신을 허용함으로써 갱신 손실을 회피하는 것이다. 현재 값이 이전에 읽은 값과 일치하지 않으면 갱신은 반영되지 않고 read-modify-write 주기를 재시도 해야한다.

그러나 데이터베이스가 WHERE 절이 오래된 스냅숏으로부터 읽는 것을 허용한다면 이 구문은 갱신 손실을 막지 못할 수도 있다. 동시에 다른 쓰기 작업이 실행되고 있더라도 조건이 참이 될 수 있기 떄문이다. 데이터베이스의 compare-and-set 연산에 의존하기 전에 먼저 안전한지 확인이 필요하다.

### 충돌 해소와 복제

여러 노드에 데이터의 복사본이 있어서 데이터가 다른 노드들에서 동시에 변경될 수 있으므로 갱신 손실을 방지하려면 추가 단계가 필요하다.

다중리더 또는 리더 없는 복제를 사용하는 데이터베이스의 경우 일반적으로 여러 쓰기가 동시에 실행되고 비동기식으로 복제되는 것을 허용하므로 데이터의 최신 복사본이 하나만 있다고 보장할 수 었고 이런 상황에선 잠금과 compare-and-set을 기반으로 한 기법을 적용할 수 없다.

대신 이렇게 복제가 적용된 데이터베이스에서 흔히 쓰는 방법은 쓰기가 동시에 실행될 때 한 값에 대해 여러 개의 충돌된 버전을 생성하는 것을 허용하고 사후에 애플리케이션 코드나 특별한 데이터 구조를 사용해 충돌을 해소하고 이 버전들을 병합하는 것이다.

원자적 연산은 복제 상황에서도 잘 동작한다. 반면 최종 쓰기 승리(last write wins, LWW) 충돌 해소 방법은 갱신 손실이 발생하기 쉽다. 많은 복제 데이터베이스는 LWW가 기본설정이다.
### 쓰기 스큐와 팬텀

### 쓰기 스큐를 특징 짓기

### 쓰기 스큐를 유발하는 팬텀

### 충돌 구체화