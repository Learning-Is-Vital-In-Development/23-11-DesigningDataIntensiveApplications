## 부호화와 발전

### 데이터 부호화 형식

데이터는 보통 두 가지 형태로 표현된다.

- **메모리에서** - Object, Struct, List, Array, Tree, Hash Table 등 (CPU에서 효율적으로 접근, 조작 가능)
- **파일 혹은 네트워크 전송에서** - 스스로를 포함한 일련의 바이트열 (JSON 등)의 형태로 부호화


이처럼 두 가지 표현 사이에 데이터 전환이 필요하고, 이 때 사용되는 방식이 부호화이다.

> **부호화란?**
<br>인메모리 표현에서 바이트열로의 전환. 다른 말로는 직렬화, 마샬링이라고도 한다.


### 언어별 형식

자바, 루비, 파이썬 같은 언어들은 인메모리 객체를 바이트열로 부호화하는 기능을 내장한다.<br>
이는 최소한의 추가 코드로 인메모리 객체를 저장하고 복원할 수 있어 편리하지만 다음과 같은 문제점들이 있다.

1. 특정 프로그래밍 언어와 묶여 있어 다른 언어에서 데이터를 읽기가 어렵다. 이는 다른 언어를 사용하는 다른 시스템과의 통합을 어렵게 만든다.

2. 동일한 객체 유형의 데이터를 복원하려면 복호화 과정에서 임의의 클래스를 인스턴스화할 수 있어야 하고, 이는 보안 문제의 원인이 된다. 공격자가 임의의 바이트열을 복호화할 수 있는 어플리케이션을 얻어 임의의 클래스를 인스턴스화할 수 있고 공격자가 원격으로 임의 코드를 실행할 수도 있다.

3. 데이터 버전 관리는 부호화 라이브러리에서는 우선순위가 떨어져 상위, 하위 호환성의 문제가 등한시되곤 한다.

4. 복/부호화에 소요되는 CPU, 부호화된 구조체 크기 등 효율성이 고려되지 않을 수 있다.


### JSON과 XML, 이진 변형

JSON, XML, CSV는 텍스트 형식이므로 어느정도 사람이 읽을 수 있다.<br>
그러나 이들의 문법적 문제 외에도 일부 미묘한 문제가 있다.

**1. Number 부호화의 애매함**

XML과 CSV에서는 number와 digit으로 구성된 문자열을 구분할 수 없다.<br>
JSON은 string과 number를 구분하지만 정수와 부동소수점은 구별하지 않고 정밀도가 떨어진다.<br>
특히 이 문제는 큰 수를 다룰 때 문제가 되는데, 2^53과 같은 큰 정수는 부동소수점 수에서는 정확하게 표현할 수 없기 때문에 JS같은 언어에서는 파싱할 때 부정확해질 수 있다.

**2. 이진 문자열 미지원**

JSON과 XML은 유니코드 문자열(사람이 읽을 수 있는 텍스트)을 잘 지원하지만 이진 문자열(문자 부호화가 없는 바이트열)은 지원하지 않는다.<br>
이런 제한을 피하는 방법으로 Base64 인코딩 형식을 사용해 텍스트로 부호화한 다음 Base64로 부호화되었다는 사실을 스키마를 통해 명시하고 있으나, 이 방법은 정공법과는 거리가 있으며 데이터 크기가 33% 증가한다는 단점이 있다.

**3. 스키마 지원이 취약함**

XML, JSON 은 스키마를 지원하지만 구현하기가 상당히 난해하다.<br>
또한 데이터의 올바른 해석은 스키마의 정보에 따라 달라지므로 XML/JSON 스키마를 사용하지 않는 어플리케이션은 별도의 부호화/복호화 로직을 작성해야 한다.

**4. CSV의 스키마 미지원**

CSV는 스키마를 미지원하기 때문에 각 row, column의 의미 정의는 어플리케이션에서 작업해야 한다.<br>
따라서 변경에 유연하지 못하고 CSV 자체가 매우 모호한 형식이기 때문에 모든 Parser가 규칙을 정확하게 구현하지는 않는다.


이러한 결점들에도 불구하고 JSON, XML, CSV는 앞으로도 인기를 유지할 것이다.<br>
특히 데이터 교환 형식으로 사용하기에 매우 좋다.

**무엇이든 다른 조직의 동의를 얻는 것**이 대부분의 다른 문제들(가독성,효율성 등)보다 더 크다.


