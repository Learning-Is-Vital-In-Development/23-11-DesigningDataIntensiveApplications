## 부호화와 발전

### 데이터 부호화 형식

데이터는 보통 두 가지 형태로 표현된다.

- **메모리에서** - Object, Struct, List, Array, Tree, Hash Table 등 (CPU에서 효율적으로 접근, 조작 가능)
- **파일 혹은 네트워크 전송에서** - 스스로를 포함한 일련의 바이트열 (JSON 등)의 형태로 부호화


이처럼 두 가지 표현 사이에 데이터 전환이 필요하고, 이 때 사용되는 방식이 부호화이다.

> **부호화란?**
<br>인메모리 표현에서 바이트열로의 전환. 다른 말로는 직렬화, 마샬링이라고도 한다.


### 언어별 형식

자바, 루비, 파이썬 같은 언어들은 인메모리 객체를 바이트열로 부호화하는 기능을 내장한다.<br>
이는 최소한의 추가 코드로 인메모리 객체를 저장하고 복원할 수 있어 편리하지만 다음과 같은 문제점들이 있다.

1. 특정 프로그래밍 언어와 묶여 있어 다른 언어에서 데이터를 읽기가 어렵다. 이는 다른 언어를 사용하는 다른 시스템과의 통합을 어렵게 만든다.

2. 동일한 객체 유형의 데이터를 복원하려면 복호화 과정에서 임의의 클래스를 인스턴스화할 수 있어야 하고, 이는 보안 문제의 원인이 된다. 공격자가 임의의 바이트열을 복호화할 수 있는 어플리케이션을 얻어 임의의 클래스를 인스턴스화할 수 있고 공격자가 원격으로 임의 코드를 실행할 수도 있다.

3. 데이터 버전 관리는 부호화 라이브러리에서는 우선순위가 떨어져 상위, 하위 호환성의 문제가 등한시되곤 한다.

4. 복/부호화에 소요되는 CPU, 부호화된 구조체 크기 등 효율성이 고려되지 않을 수 있다.

<details>
<summary>직렬화 후 바이트 크기 비교</summary>
  
![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/2be4dc22-25e1-44af-86da-45c6ac3ad617)

</details>

<details>
<summary>직렬화 소요 시간 비교</summary>
  
![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/671eff79-cc59-485a-a2d5-f66b7d1fabc1)


</details>

### JSON과 XML, 이진 변형

JSON, XML, CSV는 텍스트 형식이므로 어느정도 사람이 읽을 수 있다.<br>
그러나 이들의 문법적 문제 외에도 일부 미묘한 문제가 있다.

**1. Number 부호화의 애매함**

XML과 CSV에서는 number와 digit으로 구성된 문자열을 구분할 수 없다.<br>
JSON은 string과 number를 구분하지만 정수와 부동소수점은 구별하지 않고 정밀도가 떨어진다.<br>
특히 이 문제는 큰 수를 다룰 때 문제가 되는데, 2^53과 같은 큰 정수는 부동소수점 수에서는 정확하게 표현할 수 없기 때문에 JS같은 언어에서는 파싱할 때 부정확해질 수 있다.

**2. 이진 문자열 미지원**

JSON과 XML은 유니코드 문자열(사람이 읽을 수 있는 텍스트)을 잘 지원하지만 이진 문자열(문자 부호화가 없는 바이트열)은 지원하지 않는다.<br>
이런 제한을 피하는 방법으로 Base64 인코딩 형식을 사용해 텍스트로 부호화한 다음 Base64로 부호화되었다는 사실을 스키마를 통해 명시하고 있으나, 이 방법은 정공법과는 거리가 있으며 데이터 크기가 33% 증가한다는 단점이 있다.

**3. 스키마 지원이 취약함**

XML, JSON 은 스키마를 지원하지만 구현하기가 상당히 난해하다.<br>
또한 데이터의 올바른 해석은 스키마의 정보에 따라 달라지므로 XML/JSON 스키마를 사용하지 않는 어플리케이션은 별도의 부호화/복호화 로직을 작성해야 한다.

**4. CSV의 스키마 미지원**

CSV는 스키마를 미지원하기 때문에 각 row, column의 의미 정의는 어플리케이션에서 작업해야 한다.<br>
따라서 변경에 유연하지 못하고 CSV 자체가 매우 모호한 형식이기 때문에 모든 Parser가 규칙을 정확하게 구현하지는 않는다.


이러한 결점들에도 불구하고 JSON, XML, CSV는 앞으로도 인기를 유지할 것이다.<br>
특히 데이터 교환 형식으로 사용하기에 매우 좋다.

**무엇이든 다른 조직의 동의를 얻는 것**이 대부분의 다른 문제들(가독성,효율성 등)보다 더 크다.

### 이진 부호화

작은 데이터 셋의 경우에는 부호화 형식 선택으로 얻는 이득이 매우 작지만 테라바이트 정도가 되면 데이터 타입의 선택이 큰 영향을 미친다.

데이터타입 셋을 확장하지만 JSON/XML 모델은 유지하는 형식의 다양한 이진 부호화의 개발로 이어졋다.

```java
{
  userName: 'Martin',
  favoriteNumber: 1339,
  interests: ['daydreaming', 'hacking']
}
```

to MessagePack

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/67f0ec6f-7704-4723-952f-265a237780f7)

- 첫 번째 byte(0x83)는 이어지는 내용이 세 개의 필드(하위 4bit = 0x03)을 가진 객체(상위 4bit = 0x80)라는 뜻

만약 객체가 15개가 넘는 필드를 가지고 있어 4bit에 맞지 않다면 필드 수를 2 혹은 4바이트로 부호화한다.

- 두 번째 byte(0xa8)은 이어지는 내용이 8byte 길이(하위 4bit = 0x08)의 문자열(상위 4bit = 0xa0)이라는 뜻
- 다음 8byte는 필드 이름인 `userName`의 아스키 코드, 길이는 이전에 8byte로 표시됐기 때문에 EOF 표기할 필요 없음
- 다음 7byte는 앞에 0xa6(하위 4bit = 0x06 = 6byte길이, 상위 4bit = 0xa0 = 문자열)이므로 `Martin`이라는 6글자 문자열 값을 부호화함


메시지팩으로 이진 부호화한 이후의 크기는 66byte로 JSON(81byte)보다 작다.

이진부호화를 통해 JSON의 용량문제를 어느정도 해소 할 수 있지만 이 작은 공간의 절약(어쩌면 파싱속도의 향상)이 가독성을 해칠 만큼 가치가 있는지는 확실하지 않다.

### Thrift와 프로토콜 버퍼(propuf)

Apache Thrift와 Protocol Buffer(protobuf)는 같은 원리를 기반으로 한 이진 부호화 라이브러리이며, 둘 다 모두 부호화할 데이터를 위한 스키마가 필요하다.

```c
# Thrift
struct Person {
	1: required string userName,
	2: optional i64 favoriteNumber,
	3: optional list<string> interests
}
```

```c
# protobuf 
message Person {
	required string user_name = 1;
	optional int64 favorite_number = 2;
	repeated string interests = 3;
}
```

Thrift와 protobuf 둘다 스키마 정의를 사용해 코드를 생성하는 도구가 있다.<br>
이 도구는 다양한 언어로 스키마를 구현한 클래스를 생성하고 어플리케이션은 생성된 코드를 호출하면 스키마의 레코드를 부호화하고 복호화한다.


이 스키마로 부호화된 데이터는 그럼 어떤 모습일까?

Thrift는 두 가지 프로토콜이 존재한다.

1. 바이너리 프로토콜

각 필드에는 메시지팩처럼 타입 주석(annotation)이 있고 필요한 경우 길이 표시가 있다.<br>
데이터에 나타난 문자열도 유사하게 Ascii로 부호화한다.<br>
메시지팩과 다른 점은 필드이름(usernme, favoriteNumber, interests)이 없고 ”필드태그” 로 이를 대체한다. 

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/b7ee3de1-da65-4cb5-b1bc-fa0db9d7359d)

2. 컴팩트 프로토콜

의미상으로는 바이너리 프로토콜과 유사하지만 동일한 정보를 단지 34byte로 줄여 부호화한다.<br>
필드 타입과 태그 숫자를 1byte로 줄이고 가변 길이 정수를 사용하여 부호화한다.<br>

ex) 숫자 1337같은 경우 8byte가 아닌 2byte만을 사용하여 부호화한다.<br>
각 byte의 상위 bit는 앞으로 더 많은 byte가 있는지 나타내는데 이것은 `-64~63` (`-2^6 ~ 2^6-1`)은 1byte로 부호화하고 `-8192~8191`(`-2^13 ~ 2^13-1`) 사이의 숫자는 2byte로 부호화한다. 숫자가 클수록 더 많은 byte를 사용한다.

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/8a439db5-a310-4967-81b4-b8cc4f21144c)


 프로토콜 버퍼는 이진 부호화 형식이 하나뿐이고, 비트를 줄여 저장하는 처리 방식이 약간 다르지만 스리프트의 컴팩트프로토콜과 매우 비슷하다. <br>
스키마에서 각 필드에는 required나 optional 를 통해 필드가 설정되지 않은 경우를 실행 시에 확인할 수 있고, 이는 버그를 잡을 때 유용하다.

 ![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/1d908cf3-f2d4-474f-a5db-655ef1d3b92e)



### 필드 태그와 스키마의 발전

스키마는 필연적으로 시간이 지나면서 변한다고 설명했다. 이를 **스키마 발전**이라고 한다.

그렇다면 Thrift와 프로토콜 버퍼는 어떻게 하위 호환성과 상위 호환성을 유지하면서 스키마를 변경할까?

부호화된 레코드는 부호화된 필드의 연결일 뿐이다. 각 필드는 태그로 식별하고 데이터 타입을 주석으로 단다.

필드 값을 설정하지 않은 경우엔 단순히 부호화 레코드에서 생략한다.

이처럼 필드 태그는 부호화된 데이터를 해석하기 위해 중요한데, 부호화된 데이터는 필드 이름을 참조하지 않기 때문에 필드 이름을 쉽게 변경할 수 있다.

> 단, **태그**는 부호화된 데이터를 식별하기 때문에 변경할 수 없다.

필드 추가는 필드에 새로운 태그 번호를 부여하여 스키마에 새 필드를 추가할 수 있다.

따라서 상위 호환성을 지킬 때 예전 코드에서 새로운 코드로 기록한 데이터를 읽을 때 해당 필드를 간단히 무시할 수 있다.

또한 데이터타입 주석은 Parser가 몇 byte를 건너뛸 수 있는지 알려주어 상위 호환성을 유지한다.

하위 호환성은 각 필드에 고유 태그 번호가 있는 동안 태그 번호가 계속 같은 의미를 갖고 있으므로 새로운 코드가 예전 데이터를 항상 읽을 수 있다.

> 필드를 추가할 경우, 반드시 optional로 추가해야 한다.
새 필드를 required로 추가하게 되면 새로운 코드가 예전 코드로 기록된 데이터를 읽는 작업이 실패한다.
따라서 하위 호환성을 유지하려면 스키마의 초기 배포 이후 추가되는 모든 필드는 optional로 하거나 default 값이 있어야 한다.

