# ch04. 부호화와 발전(part 1)

다양한 데이터 부호화를 위한 형식들을 알아보고 어떻게 스키마를 변경하고 하위 호환성과 상위 호환성을 지원하는 지 설명한다. 그 다음 REST, RPC, Actor와 MessageQueue 같은 메세지 전달 시스템에서 다양한 데이터 부호화 형식이 데이터 저장과 통신에 어떻게 사용되는 지 살펴본다.

# 데이터 부호화 형식

프로그램에서 데이터는 다양한 형태로 유지되면 CPU에서 효율적으로 접근, 조작하기 위해 포인터와 같은 것들로 구성되어 있다. 하지만 네트워크 전송 및 파일에 쓰기 위해서는 일련의 바이트배열의 형태로 부호화 해야 한다. 이 두 데이터의 형태가 상당히 다르다. 이를 상호 전환하는 과정을 부호화와 복호화라고 한다. 부호화는 다른 말로 직렬화(Serialize)라고 하며 프로그램의 데이터 형태에서 전송 및 쓰기를 위한 데이터의 형태로 변환한다. 복호화는 반대로 전송된 혹은 저장된 데이터를 프로그램에서 사용하는 데이터의 형태로 변환하는 과정이며 역직렬화(Deserialize)라고도 한다. 데이터 베이스에서 직렬화는 전혀 다른 의미를 가진다.

## 언어별 형식

언어는 내부적으로 직렬화와 역직렬화를 위한 기능을 가지고 있지만 이는 성능이 별로 좋지않다. 또한 보안이나 향후 언어의 변경 등에서 자유롭지 않다.

## JSON과 XML, 이진 변형

많은 언어에서 읽고 쓸 수 있는 JSON과 XML은 표준화된 부호화다. CSV도 많진 않지만 인기 있는 언어에서 독립적인 형식이다. 이들은 대게 사람이 읽을 수 있도록 되어 있다.

- 숫자와 수를 가진 문자의 구분이 애매하고 부동소수점과 정확도를 명확하게 지원하지 않는다.
- 유니코드 문자열은 잘 지원하지만 이진 문자열은 지원하지 않는다. 이를 해결하기 위해서 Base64 인코딩 등을 이용하고 이는 데이터의 크기를 증가시킨다.
- 스키마를 지원하지만 실제로 스키마를 잘 사용하지 않는다.
- CSV는 매우 모호한 표현형식이라 구분자가 문자에 포함될 경우 파서가 이를 정확하게 지원하지 않을 수도 있다.

### 이진 부호화

조직 내에서만 사용한다면 이진 부호화를 고려해볼 수 있다. 아주 작은 데이터라면 큰 차이가 없지만 데이터가 커지면 그 차이도 커지게 된다. JSON의 이진부호화 방식으로 메세지팩(MessagePack)이 있다.

## 스리프트와 프로토콜 버퍼

아파치 스리프트(Apache Thrift)와 프로토콜 버퍼(Protocol Buffers, protobuf)는 같은 원리를 기반으로 한 이진 부호화 라이브러리다. 두 언어 모두 부호화할 데이터를 위한 스키마가 필요하다. 스리프트 같은 경우는 스리프트 인터페이스 정의 언어(Interface Definition Language, IDL)로 스키마를 기술해야한다. 프로토콜 버퍼로 정의한 동등한 스키마는 스리프트 스키마와 매우 비슷하다.

```
// Thrift
struct Person {
    1: required string        userName,
    2: optional i64.          favoriteNumber,
    3: optional list<string>  interests
}
```

```protobuf
message Person {
    required string user_name      = 1;
    optional int64 favorite_number = 2;
    repeated string interests      = 3;
}
```

스리프트는 부호화하면 바이너리 프로토콜과 컴팩트 프로토콜이라는 다른 두 가지 형태의 이진 부호화 형식이 있다. 특이한 점은 필드의 이름은 데이터가 없고 필드 태그(1,2,3)만 포함한다는 것이다. 또한 컴팩트 프로토콜은 가변 길이 정수를 사용해 바이트를 줄여서 데이터 크기를 감소시킨다.

프로토콜 버퍼는 스리프트의 컴팩트 프로토콜과 유사하게 표현된다. required나 optional 같은 이진 부호화 데이터에는 포함되지 않는다.

### 필드 태그와 스키마 발전

스키마는 필연적으로 변화하고 이를 스키마 발전이라고 부른다. 스리프트와 프로토콜 버퍼는 어떻게 이러한 스키마 발전 속에서 상위호환성과 하위호환성을 보장할까?

새로운 필드가 추가될 때는 required를 사용할 수 없으며, 새로운 태그 번호를 부여 받아야 한다. 이럴 경우 새로운 스키마는 새로운 태그 번호까지 읽고 이전 버전은 새로운 태그 번호를 읽기 않으므로서 새로운 데이터의 하위 호환성이 보장된다. 또한 기존의 데이터에서 새로운 스키마에 새로운 필드는 optional이기 때문에 없어도 읽을 수 있어 상위 호환성을 보장한다. 또한 필요에 따라 기본값을 부여할 수 있다.

반대로 기존 필드를 제거할 때는 optional 필드만 제거할 수 있다. 이렇게 제거될 경우 새로운 데이터는 해당 필드가 없지만 기존 스키마가 읽을 수 있어 하위 호환성이 유지된다. 기존 데이터들은 새로운 스키마에서는 해당 데이터를 읽지 않으므로 상위 호환성이 보장될 수 있다.

### 데이터 타입과 스키마 발전

데이터 타입 변경은 불가능 하진 않지만 값이 정확하지 않거나 잘릴 위험이 있다. 가령 예를 들어 int32 → int64로 바꿀 경우 이전 스키마를 사용하는 데이터는 32비트만큼만 읽고 뒤에 데이터를 읽지 못할 수 있다.

프로토 버퍼에서는 목록이나 배열 데이터 타입이 없고 repeated라는 표시자가 있다. required, optional과 함께 3번째 표시자이다. 따라서 optional을 repeated로 변경할 수 있다.

## 아브로

아브로는 하둡 프로젝트에서 사용하기 위해 만든 하위 이진 부호화 프로젝트이다. 아브로는 총 2개의 스키마를 사용하는데 하나는 사람이 편집할 수 있는 Avro IDL이고 하나는 기ㄱ계가 더 쉽게 읽을 수 있는 JSON 기반 언어다.

```
// Avro
record Person {
    string               userName;
    union { null, long } favoriteNumber = null;
    array<string>        interests;
}
```

우선 앞선 이진부호화 형식과 다르게 태그 번호가 없다는 걸 알 수 있다. 별도의 태그 번호 없이 데이터를 나열하고 있기 때문에 읽기와 쓰기 스키마가 모두 같아야지만 데이터를 읽을 수 있다.

### 읽기 스키마와 쓰기 스키마

아브로는 읽기 시점에 필드 이름을 기반으로 읽기 스키마와 쓰기 스키마의 차이를 해소하고 부족하거나 넘치는 필드들은 무시하거나 기본 값으로 대체하여 호환성을 유지한다.

### 스키마 발전 규칙

아브로의 호환성을 유지하기 위해서는 기본값이 있는 필드만 추가하거나 삭제할 수 있다. null을 표기하기 위해서는 union 타입을 이용하여 명확하게 nullable을 표현해야 한다. 이를 통해서 명확하게 nullable을 표현하고 버그를 방지한다.

### 그러면 쓰기 스키마는 무엇인가?

쓰기 스키마를 알 수 있는 3가지 방법

1. 하둡 환경에서는 여러 개의 동일한 형태의 데이터를 가지기 때문에 데이터 앞에 스키마 정보를 표기한다.
2. 데이터 베이스를 사용하는 경우 버전 정보를 포함하고 버전에 대한 스키마 정보를 보관한다.
3. 네트워크가 연결된 경우 스키마를 합의 한다.

### 동적 생성 스키마

프로토콜 버퍼와 스리프트에 비해 아브로 방식의 장점은 태그 번호가 없다는 것이다. 이것은 스키마 생성 시에 순서를 고려하지 않고 바로 생성할 수 있도록 해주기 때문에 동적으로 생성할 수 있다.

이에 반해 태그 번호가 있다면 태그 번호를 준수하기 위해서 정보가 필요하기 때문에 이를 매번 주입해주지 않는다면 스키마를 동적 생성하도록 할 수 없다.

### 코드 생성과 동적 타입 언어

정적 타입 언어일 경우 컴파일 시점에 적절한 형태의 역직렬화된 데이터타입의 타입 확인과 자동완성을 위해 코드 생성을 적절하게 이용할 수 있다. 스리프트와 프로토콜 버퍼는 이를 지원한다. 이와 다르게 동적 타입 언어는 만족시킬 컴파일 시점 검사기가 없기 때문에 코드 생성은 불필요하다. 아브로 같은 경우 자기 설명을 통해서 별도의 코드 생성이 없이 데이터를 볼 수 있다.

## 스키마의 장점

이진 부호화에는 좋은 속성이 많다.

- 데이터 크기가 작다.
- 스키마는 유용한 문서 형태로 복호화 시점에 스키마를 사용하기 때문에 최신 상태인지 확인할 수 있다.
- 스키마 데이터 베이스를 유지하면 스키마 변경 적용이 되기 전에 상위 호환성과 하위호환성을 모두 제공할 수 있다.
- 정적 타입 프로그래밍 언어 사용자는 자동으로 코드를 생성하고 타입 체크를 할 수 있다.

이를 통해서 스키마 리스 혹은 읽기 스키마와 같은 유연성을 제공하면서도 더욱 다양한 도구 지원도 보장된다.
