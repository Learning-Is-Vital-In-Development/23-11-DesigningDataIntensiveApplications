# 4장: 부호화와 발전


애플리케이션은 **지속적으로 변화**하기때문에 **변경 사항을 쉽게 적용할 수 있도록 시스템을 구축**해야 함
애플리케이션의 **기능을 변경할 때 대부분의 경우 데이터도 변경**됨
- 새로운 필드를 추가하거나 기존 데이터를 새로운 방법으로 제공

쓰기 스키마, 읽기 스키마

데이터 타입이나 스키마가 변경 시 애플리케이션 코드 변경도 함께 발생
대부분의 경우 하위/상위 호환성을 보장해야함
- 예전 코드, 새로운 코드
- 예전 데이터, 새로운 데이터

하위 호환성 (하위 데이터 호환성)
- **새로운 코드**는 **예전 데이터**를 읽을 수 있어야 함
상위 호환성 (상위 데이터 호환성))
- **예전 코드**는 **새로운 데이터**를 읽을 수 있어야함

- 이번 장에서는 **JSON, XML, 프로토콜 버퍼, 스리프트, 아브로 등 다양한 데이터 부호화 방법**을 살펴봄
- 특히 어떻게 스키마를 변경하고 **예전, 새로운 버전의 코드와 데이터가 공존**하는지 설명함
- 다음으로 **웹 서비스에서 대표 상태 전달(Representational State Transfer, REST), 원격 프로시저 호출(Remote Procedure Call, RPC), 액터(Actor), 메시지 큐 같은 메시지 전달 시스템**에서 다양한 데이터 부호화 형식이 데이터 저장과 통신에 어떻게 사용되는지를 살펴봄 (데이터 플로우 부분)

## 4.1. 데이터 부호화 형식

프로그램은 보통 **2가지 형태로 표현된 데이터**를 사용해 동작

1. **메모리**에 객체, 구조체, 목록, 배열, 해시테이블, 트리 등으로 유지된 데이터
2. 파일에 쓰거나 네트워크 전송을 위한 **바이트열 데이터**
(**메모리를 공유하지 않는 다른 프로세스**로 일부 데이터를 보내고 싶을때는 **바이트열로 부호화**해야함)

위 2가지는 상당히 다르고 두가지 표현 사이에 전환이 필요함
- 메모리 -> 바이트열: 부호화, 마샬링
- 바이트열 -> 메모리: 복호화, 파일, 역직렬화, 언마샬링

**데이터 전환은 공통적인 문제**이기 때문에 선택할 수 있는 **무수히 많은 라이브러리와 부호화 형식**이 있음

### 4.1.1. 언어별 형식

- 프로그래밍 언어는 **인메모리 객체를 바이트열로 부호화하는 기능을 내장**
- 프로그래밍 언어에 내장된 부호화 라이브러리는 **최소한의 코드로 인메모리 객체를 저장하고 복원할 수 있어 편리**하지만 문제점이 있음

문제점들
1. 부호화는 보통 **프로그래밍 언어에 의존적**이라 다른 언어에서 데이터를 읽기 어려움
2. 동일한 객체 유형의 데이터를 복원하려면 복호화 과정이 임의의 클래스를 인스턴스화 해야함 (이 과정에서 **임의 코드 실행**이 발생할 수 있음)
3. **데이터 버전 관리**에 약함
4. 내장 부호화 라이브러리 **성능 문제**

### 4.1.2. JSON과 XML, 이진 변형

JSON, XML, CSV는 **사람이 읽을 수 있는 텍스트 형식으로 부호화를 지원**함

몇가지 결점

1. 숫자를 부호화할 때 애매한 부분이 있음
2. 이진 문자열을 지원하지 않아 **Base64로 부호화** 해야함 (데이터 크기 33% 증가)
3. JSON, XML로 스키마를 지정하면 **부호화 / 복호화 로직을 애플리케이션에서 하드코딩** 해야할 수도 있음
- 스리프트, 프로토콜 버퍼는 스키마를 정의 하면 스키마를 구현한 클래스를 자동 생성할 수 있음
4. CSV는 모호한 형식 (**쉼표나 개행문자를 포함한 경우 파서가 오동**작 할 수 있음)

위와 같은 결점에도 JSON, XML, CSV는 다양한 용도에 사용하기 충분함
특히 서로 다른 조직의 구성원들이 동의만 한다면 조직간의 데이터 전송에 사용하기 매우 좋음


#### 4.1.2.1. 이진 부호화

- JSON, XML도 이진부호화를 지원함
- 81 Bytes 가 66 Bytes 로 변환되어 **공간 절약, 파싱 속도 향상**을 기대할 수 있지만 **가독성을 포기할 정도인지는 확실치 않음**

### 4.1.3. 스리프트와 프로토콜 버퍼

- Apache Trift, Protocol Buffers(Protobuf): 이진 부호화 라이브러리
- 프로토콜 버퍼는 구글에서 개발했고 스리프트는 페이스북에서 개발
- 스피프트와 프로토콜 버퍼 **모두 부호화활 데이터를 위한 스미카가 필요함**

- 스리프트와 프로토콜 버퍼는 **스키마 정의를 사용해 코드를 생성하는 도구가** 있음
	- **다양한 프로그래밍 언어로 스키마를 구현한 클래스를 생성**해줌
	- 애플리케이션 레벨에서 **생성된 코드를 호출해 스미카의 레코드를 부호화, 복호**화 할 수 있음
- 스리프트
	- 스리프트 바이너리 프로토콜: 81 Bytes -> 59 Bytes
	- 스리프트 컴팩트 프로토콜: 81 Bytes -> 34 Bytes
- 프로토콜 버퍼: 81 Bytes -> 33 Bytes

#### 4.1.3.1. 필드 태그와 스키마 발전

- 스키마 발전: **스키마는 시간이 지남**에 따라 필연적으로 **변함**
- 스리프트와 프로토콜 버퍼는 **하위, 상위 호환성을 유지하면서 어떻게 스키마**를 변경?

- 부호화된 레코드는 부호화된 필드의 연결
- **각 필드는 태그 숫자로 식별하고 데이터 타입이 주석**으로 있음
- **부호화된 데이터에는 필드 이름이 저장되지 않기에 스키마에서 필드 이름은 변경**할 수 있음
- 하지만 **필드 태그는 기존의 부호화된 데이터에 영향을 주기에 변경할 수 없음**

상위 호환성, 하위 호환성 문제
- 스키마의 **초기 배포 후에 추가되는 모든 필드는 Optional로 하거나 기본값**을 가져야함
- 필드 **삭제 시에는 Optional 필드만 삭제**할 수 있음
- **같은 태그 번호는 절대 다시 사용할 수 없음** 

#### 4.1.3.2. 데이터타입과 스키마 발전

- 데이터 **타입을 변경할 수 있지만 값이 정확해지지 않거나 잘릴 위험**이 있음
	- 예) 64비트 값을 32비트로 읽으면 잘릴 수 있음
- 프로토콜 버퍼의 필드 타입 (Required, Optional, **Repeated**)

### 4.1.4. 아브로

- Apache Avro는 **프로토콜 버퍼, 스리프트와 다르지만 이들과 대적할 만한 또하나의 이진 부호화 형식**
- 아브로는 스리프트가 **하둡의 사용 사례에 적합하지 않아 2009년 하둡의 하위 프로젝트로 시작**함
	- 하둡(Haddop)
		- **대규모 데이터를 저장하고 처리**하기 위한 오픈소스 프레임워크
		- 주로 **분산 환경에서 동작하며 빅데이터를 다루르는 데 사용**되는 기술

아브로에는 2개의 스키마 언어가 있음
1. 사람이 편집할 수 있는 아브로 IDL
2. 기계가 쉽게 읽을 수 있는 JSON 기반 언어

- **아브로는 스키마에 태그번호가 없고** 81 Bytes -> 32 Bytes 로 지금까지 살펴본 부호화 중 가장 길이가 짧게 부호화함
- 아브로를 이용해 이진 데이터를 파싱하려면 스키마에 나타난 순서대로 필드를 살펴보고 스키마를 이용해 각 필들의 데이터타입을 미리 파악해야함
- 이것은 데이터를 읽는 코드가 데이터를 기록한 코드와 정확히 같은 스키마를 사용하는 경우에만 이진 데이터를 올바르게 복호화할 수 있음을 의미함

#### 4.1.4.1. 쓰기 스키마와 읽기 스키마

- 쓰기 스키마: **애플리케이션이 파일이나 데이터베이스에 쓰기 위한 목적으로 아브로로 데이터를 부호화**하기 원한다면 알고 있는 스키마 버전을 이용해 데이터를 부호화함
- 읽기 스키마: 애플리케이션이 파일이나 데이터베이스 또는 네트워크로 **수신한 데이터를 복호화하기 원한다면 특정 스키마로 복호화**
	- 복호화 코드는 애플리케이션을 빌드하는 동안 스키마로부터 생성

아브로의 핵심 아이디어
	- 쓰**기 스키마와 읽기 스키마가 동일하지 않아도 되면 단지 호환**가능하면 됨
	- 데이터를 **복호화 할 때 (읽을 때) 아브로 라이브러리는 쓰기 스키마와 읽기 스키마를 함께** 살펴봄

1. 쓰기 스키마와 읽기 스키마의 **필드 순서가 달라도 상관 없음**: 스키마 해석에서는 이름으로 필드를 일치 시킴
2. 데이터를 읽을 때 읽기 스키마에는 없고 쓰기 스키마에만 있는 필드를 만나면 무시함 (읽을 필요 없음)
3. 데이터를 읽을 때 읽기 스키마에는 있는데 쓰기 스키마에는 없는 필드를 만나면 기본 값으로 채워서 읽음

#### 4.1.4.2. 스키마 발전 규칙

- 새로운 읽기 스키마로 예전 쓰기 스키마(예전 데이터)를 읽을 수 있어야함: 하위 호환성
	- **쓰기 스키마에 없는 데이터를 기본 값으**로 채움
- 예전 읽기 스키마로 새로운 쓰기 스키마(새로운 데이터)를 읽을 수 있어야함: 상위 호환성
	- **읽기 스키마에 없는 필드를 무시**함

- **호환성을 유지하기 위해서 기본값이 있는 필드만 추가하거나 삭제**할 수 있음
- 필드 이름 변경은 하위 호환성이 있지만 상위 호환성은 없음
	- 새로운 읽기 스키마로 예전 쓰기 스키마를 읽을 수는 있지만
	- **예전 읽기 스키마로 새로운 쓰기 스키마를 읽을 수 없음**

#### 4.1.4.3. 그러면 쓰기 스키마는 무엇인가?

- **읽기는 특정 데이터를 부호화한 쓰기 스키마를 어떻게** 알 수 있을까?
	- 단순한 방법: **모든 레코드마다 스키마 정의를 저장**
		- 스키마가 부호화환 데이터보다 더 클 수 있고, 이진 부호화로 절약한 공간이 의미없어짐

1. 아브로의 일반적인 용도: **모두 동일한 스키마로 부호화된 수백만개의 레코드를 저장**
	- 이 경우 **파일의 쓰기는 파일의 시작 부분에 한 번만 쓰기 스키마를 정의**하면 됨
	- 아브로: 대용량 데이터의 효율적인 저장과 전송을 위해 설계되었음
2. 개별적으로 기록된 레코드를 가진 데이터 베이스
	- 데이터베이스의 **다양한 레코드들은 다양한 스키마를 사용해 서로 다른 시점에 쓰여질 수 있음**
	- **부호화된 레코드의 시작 부분에 버전 번호를 포함하고 데이터베이스는 스키마 버전 목록**을 유지
	- 읽기는 레코드를 가져와 **버전 번호를 추출한 다음 데이터베이스에서 버전 번호에 해당하는 쓰기 스키마**를 가져옴
3. 네트워크 연결을 통해 레코드 보내기
	- 두 프로세스가 양방향 네트워크 연결을 통해 통신할 때 연결 설정에서 **스키마 버전을 합의**함

#### 4.1.4.4. 동적 생성 스키마

프로토콜 버퍼, 스리프트 vs. 아브로
- **아브로 스키마는 태그 번호가 포함되지 않음**

**태그 번호가 없어 아브로가 동적 생성 스키마에 더 친숙함**
- 예를 들어 관계형 스키마로 아브로 스키마를 생성할 때 간단히 **관계형 스키마의 컬럼명과 아브로 스키마의 필드명을 매핑**시키면 됨
- 프로토콜 버퍼나 스리프트의 경우 태그번호를 매핑시켜야 함

#### 4.1.4.5. 코드 생성과 동적 타입 언어

프로토콜 버퍼, 스리프트는 코드 생성에 의존
- **스키마를 정의한 후 선택한 프로그래밍 언어로 스키마를 구현한 코드를 생성**할 수 있음
- 자바, C++, C# 같은 **정적 타입 언어**에서 유용함
	- **IDE에서 타입 확인과 자동 완성**이 가능

- **쓰기 스키마를 포함한 아브로 객체 파일**은 아브로 라이브러리를 사용해 JSON 파일을 보는 것과 같이 데이터를 볼 수 있음
- 위와 같은 객체 파일은 **필요한 메타데이터를 모두 포함기 때문에 자기 기술적(self-describing)**임
- 이 특성은 아파치 피그 같은 동적 타입 데이터 처리 언어와 함께 사용할 때 특히 유용함


### 4.1.5. 스키마의 장점

- 프로토콜 버퍼, 스리프트, 아브로는 **스키마를 이용해 이진 부호화 형식을 기술**함
- 스키마 언어는 **XML, JSON 스키마보다 간단하며 더 자세한 유효성 검사 규칙을 지원함**


- 이진 부호화의 좋은 점
	- 부호화된 데이터에서 필드 이름을 생략해 이진 JSON 변형보다 **데이터 크기가 작음**
	- **스키마 자체가 문서**가 되고 데이터 복호화 시 스키마가 반드시 필요하기 때문에 **최신성을 자연스럽게 보장**
	- 스키마 데이터베이스를 유지하면 **스키마 변경 전/후의 상위 호환성과 하위 호환성**을 알수 있음 
	- 정적 타입 프로그래밍 언어를 사용할 경우 **스키마로부터 코드를 생성하는 기능을 유용하게 사용**할 수 있고 **컴파일 시점에 타입 체크**가 가능함


## 4.2. 데이터플로 모드


- 호환성은 데이터를 부호화하는 하나의 프로세스와 그것을 복호화하는 다른 프로세스간의 관계
- 데이터플로는 매우 추상적인 개념으로서 하나의 프로세스에서 다른 프로세스로 데이터를 전달하는 방법은 아주 많음

- 프로세스 간 데이터를 전달하는 가장 보편적인 방법들 
	- 1. 데이터베이스 사용: 데이터베이스를 통한 데이터플로 (131 Page)
	- 2. 서비스 호출: 서비스를 통한 데이터플로 (REST와 RPC, 134 Page)
	- 3. 비동시 메시지 전달: 메시지 전달 데이터플로 (139 Page)
### 4.2.1. 데이터베이스를 통한 데이터플로

- 데이터베이스를 통한 데이터플로에서는 하위 호환성이 분명히 필요
	- 새로운 코드가 예전 데이터를 읽을 수 있어야함
	- 그렇지 못하면 이전에 기록한 내용이 모두 쓸모없어져 버림

- 예전 코드가 새로운 데이터를 읽을 경우 예전 코드에 존재하는 컬럼의 데이터만 읽어 온 후 덮어씌워 새로운 데이터가 유실되는 경우가 있으므로 주의가 필요함


#### 4.2.1.1. 다양한 시점에 기록된 다양한 값

- 데이터 베이스는 언제나 값을 갱신할 수 있음
- 따라서 단일 데이터베이스에는 1초 전 5년 전 데이터가 동시에 존재할 수 있음 (데이터가 코드 보다 더 오래산다)

- 데이터를 새로운 스키마로 마이그레이션 하는 작업도 가능하지만 값비싼 작업임
- 따라서 대부분의 데이터베이스에서는 이런 상황을 피함






#### 4.2.1.2. 보관 저장소


### 4.2.2. 서비스를 통한 데이터플로: REST와 RPC


- 대용량 애플리케이션 기능 영역을 소규모 서비스로 나눠 하나의 서비스가 다른 서비스의 일부 기능이나 데이터가 필요하다면 해당 서비으세 요청을 보냄
	- 서비스 지향 설계, 마이크로서비스 설계

- 서비스는 서비스의 비즈니스 로직(애플리케이션 코드)로 미리 정해진 입력과 출력만 허용한 API를 공개함
	- 서비스의 자유도가 높음
	- 서비스는 클라이언트가 할 수 있는 일과 없는 일에 대한 제약을 세분화

#### 4.2.2.1. 웹 서비스

#### 4.2.2.2. 원격 프로시저 호출(RPC) 문제 

- RPC 모델: 원격 네트워크 서비스 요청을 같은 프로세스 안에서 특정 프로그래밍 언어의 함수나 메서드를 호출하는 것처럼 사용하게 해줌
	- 이런 추상화를 위치 투명성(location transparency)이라고 함

#### 4.2.2.3. RPC의 현재 방향


#### 4.2.2.4. 데이터 부호와와 RPC의 발전


### 4.2.3. 메시지 전달 데이터플로

- REST와 RPC는 하나의 프로세스가 네트워크를 통해 다른 프로세스로 요청을 전송하고 가능한 빠른 응답을 기대하는 방식
- 데이터베이스는 하나의 프로세스가 부호화한 데이터를 기록하고 다른 프로세스가 언젠가 그 데이터를 다시 읽는 방식

- RPC와 데이터베이스 간 비동시 메시지 전달 시스템
	- 클라이언트 요청을 낮은 지연 시간으로 다른 프로세스에 전달한다는 점에서 RPC와 비슷
	- 메시지를 직접 네트워크로 전송하지 않고 임시로 메시지를 저장하는 메시지 브로커, 메시지 큐나 메시지 지향 미들웨어라는 중간 단계를 거쳐 전송한다는 점은 데이터베이스와 유사함

- 메시지 브로커의 장점
	- 1. 수신자가 사용 불가능하거나 과부화 상태라면 

#### 4.2.3.1. 메시지 브로커

#### 4.2.3.2. 분산 액터 프레임워크

- https://blog.rajephon.dev/2018/12/02/akka-01/



## 정리

- 데이터 구조를 네트워크나 디스크 상의 바이트열이나 텍스트로 변환하는 다양한 방법을 살펴봤음
- 서비스를 운영하다보면 새로운 버전의 서비스를 일부 노드에만 서서히 배포하는 순회식 업그레이드를 하게됨
	- 장점
		- 정지 시간 없이 새로운 서비스를 배포 가능
		- 배포가 덜 위험해짐 (일부 노드에만 배포해서 확인 가능)
		- 결론적으로 애플리케이션 변경을 쉽게 할 수 있는 **발전성** 도움이됨
			- 발전성: 한 번에 모든 것을 변경할 필요 없이 **시스템의 다양한 부분을 독릭접으로 업그레이드해 변경 사항을 쉽게 반영**하는 능력 (131 Page)

- 위처럼 순회식 업그레이드를 하거나 다른 이유로 다양한 노드에 다른 버전의 애플리케이션 코드를 배포하는 경우가 생김
	- **이 때 시스템을 흐르는 데이터는 상위, 하위 호환성을 보장해야함**
		- 상위 데이터 호환성: 예전 코드가 새로운 데이터를 읽을 수 있음
		- 하위 데이터 호환성: 새로운 코드가 예전 데이터를 읽을 수 있음

### 부호화 
- 프로그래밍 언어에 내장된 부호화
	- 프로그래밍 언어에서 적은 코드로 구현 가능
	- 단일 프로그래밍언어에 제한될 수 있음
	- 성능이 떨어질 수 있음

- JSON, XML, CSV 같은 텍스트 형식
	- 사람이 알아보기 쉬움
	- 호환성을 보장하려면 유의해서 사용해야함
	- 데이터타입에 대해 모호한 점이 있음 (ex. Double, Long double)

- 스리프트, 프로토콜 버퍼, 아브로 같은 이진 스키마 기반 형식
	- 짧은 길이로 부호화 됨
	- 명확하게 정의된 상위 호환성과 하위 호환성의 맥락에서 효율적인 부호화 지원
	- 사람이 읽기 위해서는 복호화 해야함

### 데이터플로 모드

- 데이터베이스: 데이터베이스에 기록하는 프로세스가 부호화하고 데이터베이스에서 읽는 프로세스가 복호화
- RPC와 REST API: 클라이언트가 요청을 부호화하고 서버는 요청을 복호화하고 응답을 부호화하고 최종적으로 클라이언트가 응답을 복호화
- 메시지 전달: 송신자가 부호화하고 수신자가 복호호하는 메시지를 서로 전송해서 노드 간 통신하는 비동기 메시지 전달 (메시지 브로커나 액터를 이용)