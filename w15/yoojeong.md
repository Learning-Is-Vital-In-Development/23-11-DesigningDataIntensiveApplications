
## 일관성과 합의 (일관성 보장, 선형성, 순서화 보장)

### 일관성 보장

복제된 데이터베이스는 최소한 최종적 일관성을 제공한다.<br>
DB에 쓰기를 멈추고 불특정 시간 동안 기다리면 결국 모든 읽기 요청이 같은 값을 반환한다.<br>
그러나 매우 약한 보장으로, 언제 복제본의 결과가 수렴될 지 알 수 없다.

이번 장에서는 데이터 시스템이 선택적으로 제공할 수 있는 더욱 강한 일관성 모델을 살펴본다.

### 선형성

> 시스템에 데이터 복사본이 하나만 있고 그 데이터를 대상으로 수행하는 모든 연산을 원자적인 것처럼 보이게 하는 것


![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/8a34d823-5d68-45cd-a1a5-03906d48d917)

- 비선형성 시스템의 예제
  - 앨리스에게 결과를 들은 후 새로고침했음에도 오래된 질의 결과를 반환받아 혼란스러운 밥
- 선형성 = 최신성 보장
  - 클라이언트가 쓰기를 성공적으로 완료하자마자 그 DB를 읽는 모든 클라이언트는 최신 값을 볼 수 있어야함


#### 시스템에 선형성을 부여하는 것은 무엇인가?

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/76e181a8-ff1d-4a76-8648-64c9c32fa717)


과연 클라이언트 C가 작성하는 동안은 조회를 요청한 클라이언트 A와 B에게는 0을 반환해야하나, 아니면 1을 반환해야할까?

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/89432f6a-6bd1-4dbf-aa34-da43e60c2d68)


선형적으로는 최신성을 보장해야 함으로 0을 반환했다고 하면 1을 반환하는것은 선택이지만, 최신값인 1을 반환했던 이력이 있으면 항상 1을 반환하는 것은 필수이다.

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/5ca4879f-232d-400a-8a90-902a9b49d85b)


선형성의 요구사항은 연산 표시를 모은 선들이 항상 시간순으로 진행돼야 하고 결코 뒤로 가서는 안 된다는 것이다.

> 직렬성이 보장된다고 선형성이 반드시 보장되진 않는다.

| | |
|:--:|:--|
|선형성	| 레지스터(개별 객체)에 실행되는 읽기와 쓰기에 대한 최신성 보장	연산을 트랜잭션으로 묶지 않아서 충돌 구체화 같은 부가적인 수단을 사용하지 않으면 쓰기 스큐 같은 문제를 막지 못한다.|
|직렬성|	모든 트랜잭션이 여러 객체를 읽고 쓸 수 있는 상황에서의 트랜잭션의 격리 속성	트랜잭션들이 어떤 순서에 따라 실행되는 것처럼 동작하도록 보장해줄 뿐 그 순서가 트랜잭션들이 실제로 실행되는 순서와 달라도 상관 없다.|


#### 선형성에 기대기

- 잠금과 리더 선출
  - 단일 리더 복제를 사용하는 시스템은 리더가 여러개가 아니라 진짜로 하나만 존재하도록 보장해야 한다.
  - 리더를 선출하는 한가지 방법은 잠금을 사용해 모든 노드가 시작할 때 잠금 흭득을 시도하고 성공한 노드가 리더가 되는 것
  - 이 잠금을 어떻게 구현하든 선형적이어야 한다.
- 제약 조건과 유일성 보장
  - RDB 에서 흔하게 사용되는 유일성 제약 조건도 잠금과 비슷하게 선형성을 필요로 한다.
- 채널간 타이밍 의존성
  - 앨리스와 밥사례에서는 앨리스가 밥에게 알려주지 않았다면 밥은 결코 본인이 늦은 결과를 조회하고 있다는 사실을 모른다.
  - 선형성 위반을 알릴 수 있는 채널이 있어야 하고,선형성을 구현하는 시스템들은 이런 채널에 의존한다.


#### 선형성 시스템 구현하기

> 선형성과 정족수

다이나모 스타일 모델에서 엄격한 정족수를 사용한 읽기, 쓰기는 선형적인 것처럼 보인다.<br>
그러나 아래와 같이 네트워크 지연의 변동이 심하면 경쟁조건이 생길 수 있다.

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/4179ca3e-4b41-4321-992b-3c776c0317f6)


- x 초기값 = 0
- 쓰기 클라이언트가 세 복제본에 모두 쓰기 요청을 보내서 x = 1로 갱신한다. ( n = 3, w = 3 )
- `클라이언트 A` : 2개의 노드로 부터 정족수를 읽음 → 새로운 값 1을 본다 (r = 2)
- `클라이언트 B` : 2개의 노드로 부터 정족수를 읽음 → 예전 값 0을 본다 (r = 2)
- 정족수 조건 ( w+r > n )을 만족함에도 이 실행은 선형적이지 않다.
  - B의 요청은 A의 요청이 완료된 후 시작하지만 A는 새 값을 반환하고 B는 예전 값을 반환한다.
 
    
성능이 떨어지는 비용을 지불한다면 다이나모 스타일의 정족수를 선형적으로 만드는게 가능하지만 제한 사항이 많다.<br>
따라서 다이나모 스타일 복제를 하는 리더 없는 시스템은 선형성을 제공하지 않는다고 보는게 가장 안전하다.

#### 선형성의 비용

> 네트워크가 끊기면 각 데이터센터의 내부 네트워크는 동작하고 클라이언트들은 데이터센터에 접근할 수 있지만 데이터센터끼리는 서로 연결할 수 없다

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/a9c79efc-e092-431f-9e30-fe1d1bdf9228)



- 다중 리더 데이터베이스를 사용하면 각 데이터센터는 계속 정상 동작하다, 네트워크 연결이 복구되면 복제 된다.
- 단일 리더 복제를 사용하면 모든 쓰기와 선형성 읽기는 리더로 보내져야 한다. 따라서 팔로워 데이터센터로 접속한 클라이언트들은 리더로 연결할 수 없으므로 아무것도 쓸 수 없고 선형성 읽기도 할 수 없다
  - 팔로워로부터 읽을 수는 있지만 데이터가 뒤처졌을 수 있고, 애플리케이션에서 선형성 읽기와 쓰기를 요구한다면 그 애플리케이션은 사용할 수 없다.
  - 클라이언트가 리더 데이터센터로 직접 접속할 수 있다면 계속 정상 동작할 수 있으므로 문제가 되지 않지만, 팔로워 데이터센터로만 접속할 수 있는 클라이언트는 네트워크 링크가 복구될 때까지 중단을 경험한다.

> CAP 정리

흔히 CAP 정리는 일관성(Consistency), 가용성(Availability), 분단 내성(Partition tolerance) 중 두 개를 고를 수 있다고 표현되지만 이는 오해의 소지가 있다.<br>
네트워크 분단은 결함이므로 선택할 수 있는 것이 아니고 반드시 발생하기 때문에 분단 내성은 반드시 고려되어야 한다.<br>
즉 CAP 정리는 네트워크 분단(P)이 생겼을 때 일관성(C)과 가용성(A) 중 하나를 선택할 수 있다고 보는게 좋다. 여기서 일관성은 선형성(Strong Consistency)로 보는 것이 옳다.

- 만약 애플리케이션에서 선형성이 요구된다면 네트워크 분단 시 가용성을 보장할 수 없게 된다.
- 반대로 애플리케이션에서 선형성을 요구하지 않는다면 네트워크 분단 시 선형적이지 않지만 가용한 상태를 제공할 수 있다.
- 선형성이 필요 없는 애플리케이션은 네트워크 문제에 더 강인하다.

> 선형성과 네트워크 지연

선형성 보장을 제공하지 않기를 선택한 여러 시스템의 이유는 내결함성이 아니라 성능이다.

### 순서화 보장

#### 순서화와 인과성

순서화는 인과성을 보존하는 데 도움을 준다.<br>
인과성은 이벤트에 순서를 부과한다. 결과가 나타나기 전에 원인이 발생한다.

- 메시지를 받기 전에 메시지를 보낸다.
- 답변하기 전에 질문을 한다.
- DB를 읽어 어떤 데이터를 봤다면 그보다 인과적으로 먼저 발생한 데이터도 볼 수 있어야한다.

| | |
|:--:|:--|
|선형성|	선형성 시스템에서는 연산의 전체 순서를 정할 수 있다.<br>시스템이 데이터 복사본이 하나만 있는 것처럼 동작하고 모든 연산이 원자적이라 어떤 두 연산에 대해 항상 둘 중 하나가 먼저 실행됐다고 말할 수 있다.|
|인과성|	두 연산 중 어떤 것도 다른 것보다 먼저 실행되지 않았다면 두 연산은 동시적이다.<br>즉 두 이벤트에 인과적인 관계가 있으면 이들은 순서가 있지만 이들이 동시에 실행되면 비교할 수 없다.즉 인과성은 전체 순서가 아닌 부분 순서를 정의한다. <br>어떤 연산들은 서로에 대해 순서를 정할 수 있지만 어떤 연산들은 비교할 수 없다.|


이 정의에 따르면 선형성 데이터스토어엔 동시적 연산이 없다. 하나의 타임라인이 있고 모든 연산은 그 타임라인을 따라 전체 순서가 정해져야 한다.

일련번호 순서화
전체 순서 브로드캐스트
