
![image](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/60343930/a83a055c-8f5e-40f3-a9f4-e287b348209c)

## 선형성
데이터 복사본이 하나만 있고 데이터 대상으로 수행하는 모든 연산은 원자적인 것처럼 보이게 만드는 것.
### 선형성 시스템
-> 클라이언트가 쓰기를 성공적으로 완료하자마자 
   그 데이터베이스를 읽는 모든 클라이언트는 방금 쓰여진 값 확인 가능
-> 최근 갱신 된 값, 캐시나 복제본 X 
-> 최신성 보장(recency guarantee)

### 비선형 시스탬
-> 스포츠 웹사이트 예시 
    - 한명은 최신 한명은 db복제본 전달돼서 아직 경기 진행중
    - 오랜된 결과를 반환한 건 선형선 위반

###그렇다면 선형성 부여는 어떻게?
-> 시스템에 데이터 복사본이 하나뿐인 것처럼 보이게 만들기
1) 2) 3) 4)

### 선형성/직렬성
- 직렬성 : 모든 트랜잭션이 여러 객체(로우,문서,레코드)를 읽고 쓸 수 있는 상황에서 트랜잭션의 격리 속성
- 선형성 : 레지스터에 실행되는 읽기와 쓰기에 대한 최신성 보장
-> DB는 모두 제공 가능 (엄격한 직렬성 strict serializability, 강한 단일 복사본 직렬성 strong one-copy serializability,)

![image](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/60343930/876987a6-d5a1-4943-bd8e-4b9784e38057)
![image](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/60343930/4e44222a-e2fe-473f-950c-aac550d3c6c4)

### 잠금과 리더 선출 
-> 단일 리더 복제의 리더 split brain X -> 진짜로 1개만
    -> 리더 선출 방법 : 잠금 
        - 모든 노드 시작시 잠금 획득 시도 -> 성공한 노드가 리더
        - 잠금을 어떻게 구현하든지 선형적이어야함.
        - 모든 노드는 어느 노드가 잠금을 소유하는지 동의해야됨.

### 분산 잠금과 리더 선출 구현 => 코디네이션 서비스 [아파치 주키퍼(apache zookeeper) / etcd ].
-> 코디네이션 서비스는 합의 알고리즘을 사용해 선형성 연산을 내결함성이 있는 방식으로 구현 


### 제약조건과 유일성 보장
-> 이메일/사용자명 : 유일한 식별조건 , 제약 조건 강제는 선형성으로 이루어짐
-> 사용자명이 "잠금"을 획득 하는 것, 이는 원자적 compare-and-set과 매우 비슷
-> 모든 노드가 동의하는 하나의 최신값이 있기를 요구 
    ex) 은행 계좌 잔고(음수x), 창고에 있는 재고보다 더 팔리지 않게, 동시에 같은 좌석 예약x
    - 실제 애플리케이션은 때때로 이런 제약 조건을 느슨하게 다뤄도 됨(항공편 오버부킹 시 다른 항공편 옮기고 보상)
-> 그러나 관계형 디비에서 전형적으로 볼 수 있는 엄격한 유일성 제약 조건은 선형성이 필요!
    - 외래키, 속성 제약조건 같은 다른 종류의 제약 조건은 선형성 요구x 구현 가능

###채널간 타이밍 의존성
-> 파일저장 서비스가 선형적이면 이 시스템은 잘 동작함 (비선형일시 경쟁 조건 위험 발생)
-> 웹서버와 크기 변경 모듈 사이에 두가지 다른 통신 채널 (경쟁 조건 비교) 
    - 파일 저장소 / 메세지 큐 , 데이터베이스 복제 / 앨리스 입과 밥의 귀(현실 오디오 채널)
-> 선형성이 경쟁조건을 회피하는 유일한 방법은 아니지만 이해하기에 가장 단순함.
-> (그림) 파일 저장 서비스가 선형적이면 이 시스템을 잘 동작한다. 선형적이지 않으면 경쟁 조건의 위험이 있다.

![image](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/60343930/2dd2357e-15d5-42fb-8915-7cc657e82907)

### 선형성 시스템 구현하기
선형성 시맨틱 제공하는 시스템은 어떻게 구현?
-> 데이터 복사본 하나만 사용하기 : 결함을 이겨낼 수 없음, 하나의 복사본을 저장한 노드에 장애가 나면 
                            데이터가 손실되거나 적어도 노드가 살아날 때까지 접근할 수 없기 때문에
-> 내결함성을 지니도록 만드는 가장 흔한 방법
단일 리더 복제(선형적일 수 있음)
합의 알고리즘(선형적)
다중 리더 복제(비선형적)
리더 없는 복제(아마도 비선형적)

###선형성과 정족수
다이나모 스타일 모델에서 엄격한 정족수를 사용한 읽기 쓰기는 선형적인 것 처럼 보인다.

### 선형성 시스템 구현하기
선형성 시맨틱 제공하는 시스템은 어떻게 구현?
-> 데이터 복사본 하나만 사용하기 : 결함을 이겨낼 수 없음, 하나의 복사본을 저장한 노드에 장애가 나면 
                            데이터가 손실되거나 적어도 노드가 살아날 때까지 접근할 수 없기 때문에
-> 내결함성을 지니도록 만드는 가장 흔한 방법
단일 리더 복제(선형적일 수 있음)
합의 알고리즘(선형적)
다중 리더 복제(비선형적)
리더 없는 복제(아마도 비선형적)

###선형성과 정족수
다이나모 스타일 모델에서 엄격한 정족수를 사용한 읽기 쓰기는 선형적인 것 처럼 보인다.
n(복제 서버) = 3, w(쓰기 노드) = 3, r(읽기 노드) = 2 → 정족수 조건 만족 (w + r > n) 
이지만 선형적이지 않음 성능상 불이익이나 선형성을 만족시킬 수 없기 떄문에 
다이나모 스타일의 복제를 하는 리더 없는 시스템은 비선형적임
![image](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/60343930/430fb1c7-a22c-4b3e-baca-b40383ff1ce9)


### 선형성의 비용
네트워크가 끊겼을 때 
-> 다중 리더 데이터 베이스 : 각 데이터센터는 정상 동작, 한 DC에 쓰인 내용이 비동기로 다른 DC에 복제되므로
                          쓰기는 큐에 쌓였다가 네트워크 연결이 복구되면 전달된다.
-> 단일 리더 설정 데이터 베이스 : 네트워크가 끊기면 팔로워 데이터센터로 접속한 클라이언트 들은 리더로 연결할 수 없으므로
                              아무것도 쓸 수 없고 선형성 읽기도 못함.
###CAP 정리
-> Consistency(일관성), Availability(가용성), Partition tolerance(분단 내성)
선형성 데이터베이스라면 이러한 선형성과 가용성의 트레이드오프 문제가 있음
오직 하나의 일관성 모델(=선형성) 과 한 종류의 결함(네트워크 분단 or 연결이 끊긴 살아있는 노드) 만 고려함
다른 부분인 네트워크 지연, 트레이드 오프 등에 대해 고려하지 않으므로 시스템 설계 시 고려할 실용적인 가치가 없음

-> 선형성을 제거하는 이유는 내결함성이 아니라 성능이다. (내결함성과 성능은 트레이드오프)
-> 최신 다중코어 CPU의 RAM조차 선형적이지 않을 정도로 선형적인 시스템은 드물다.
    - 모든 CPU코어가 저마다 메모리 캐시와 저장 버퍼를 갖기 때문이다. 메모리 접근은 기본적으로 캐시로 가고 변경은 메모리에 비동기 기록
    - 캐시에서 데이터 접근하는게 메인 메모리보다 훨씬 빠르다. 그러나 이렇게 캐시에 데이터복사본이 다양하게 생기면, 
     이러한 복사본은 비동기 갱신이므로 선형성이 손실된다.
