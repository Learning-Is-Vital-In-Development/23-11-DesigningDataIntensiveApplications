

# 09장 일관성과 합의

## 키워드

- 선형성: 최신성과 동일하게 생각해도됨
	- 가장 최근 값을 읽을 수 있다
	- 먼저 진행되어야하는 쓰기 작업들이 모두 완료 된 후 쓰기를 진행한다.
- CAP 정리
	- 네트워크 장애가 없다면 일관성, 가용성은 항상 보장할 수 있다.
	- 결국 네트워크 장애가 있을 때 일관성을 보장할지, 가용성을 보장할지의 문제이다.
	- 단일 리더, 단일 리더 다중 데이터센터 예시
	- 일관성(Consistency)
	- 가용성(Availability)
	- 분단 내성(Partition tolerence)


## 도입부

```plain
 살아 있지만 틀린게 나은가, 올바르지만 죽은 게 나은가? (책 319페이지)
 - 제이 크렙스, 카프카와 젭슨에 대한 몇 가지 기록 (2013)
```

1. 살아 있지만 틀린 경우: 네트워크에 장애가 생겼을 때 일관성은 포기하고 가용성 보장
2. 올바르지만 죽은 경우: 네트워크가 장애가 생겼을 때 가용성은 포기하고 데이터의 일관성은 보장

내결함을 지닌 시스템을 구축하는 가장 좋은 방법은 유용한 보장을 해주는 범용 추상화를 찾아 이를 구현하고 애플리케이션이 이 보장에 의존하게 하는 것이다.
- 7장에서 트랜잭션의 추상화가 데이터의 원자성, 격리성, 지속성을 보장해줬다.

### 9. 1. 일관성 보장


복제 데이터베이스는 대부분 최소한 최종적 일관성을 제공한다.
최종적 일관성은 결국 모든 복제본의 데이터가 같은 값에 수렴할 것이라는 것을 보장하지만, 언제 복제본의 데이터가 같아질지는 보장하지 않는다.

3가지 방법
- 가장 강한 일관성 모델: 선형성 보장 (최신성 보장)
- 순서화 보장
- 분산 트랜잭션과 합의

### 9.2. 선형성

기본 아이디어는 시스템에 데이터 복사본이 하나만 있고 그 데이터를 대상으로 수행하는 모든 연산은 원자적인 것처럼 보이게 만드는 것이다.
데이터의 복사본이 하나만 있다는 것은 읽은 값이 최근에 갱신된 값이며 뒤처진 캐시나 복제본에서 나온 값이 아니라고 보장해준다는 뜻이다.
(다시 말해 선형성은 최신성 보장이다)

#### 9.2.1. 시스템에 선형성을 부여하는 것은 무엇인가?

선형성을 뒷받침하는 기본 아이디어는 간단하다. 시스템에 데이터 복사본이 하나뿐인 것처럼 보이게 만드는 것이다.

Compare-and-set(cas) 연산

#### 9.2.2. 선형성에 기대기

어떤 환경에서 선형성이 유용할까?

##### 9.2.2.1. 잠금과 리더 선출

##### 9.2.2.2. 제약 조건과 유일성 보장

회원가입 시 사용자 ID나 이메일주소는 유일해야한다.
계좌 잔고와 재고는 음수가 되어서는 안된다.
동시에 같은 비행기나 영화 좌석에 예약할 수 없다.

관계형 데이터베이스의 외래 키나 속성 제약 조건 같은 다른 종류의 제약 조건은 선형성 없이도 구현할 수 있다.
##### 9.2.2.3. 채널 간 타이밍 의존성

예시:
파일을 웹서버에 올리면 1.원본 이미지를 파일 저장소에 저장하는 작업과
2.메시지큐에 원본 이미지 변경을 Call하는 메시지를 넣는 작업이 동시 진행
여기서 원본 이미지가 파일 저장소에 저장되기 전에 이미지 변경 Call 메시지가 이미지 크기 변경 모듈에 먼저 도착한다면?

#### 9.2.3. 선형성 시스템 구현하기

#### 9.2.3.1. 선형성과 정족수

정족수: 최종 결정을 내리기 위해 필요한 최소 인원수를 사전에 정해둔 것.

#### 9.2.3.2. 선형성의 비용

#### 9.2.3.3. CAP 정리

#### 9.2.3.4. 선형성과 네트워크 지연

- 선형성을 제거하는 이유는 보통 내결함성 보다는 성능 때문이다.

### 9.3. 순서화 보장

5장: 단일 리더 복제에서 리더의 주 목적은 복제로그에서 쓰기 순서 결정
7장 직렬성: 트랜잭션들이 마치 어떤 일련 순서에 따라 실행되는 것처럼 보장
8장: 분산 시스템에서 타임 스탬프와 시계 사용

순서화, 선형성, 합의의 개념은 시스템이 무엇을 할 수 있고 무엇을 할 수 없는지에 대한 이해에 도움을 준다.

#### 9.3.1. 순서화와 인과성

##### 9.3.1.2. 인과적 순서가 전체 순서는 아니다

선형성 시스템: 전체 순서를 정할 수 있다.
인과성: 전체 순서가 아닌 부분 순서를 정할 수 있다.

##### 9.3.1.3. 선형성은 인과적 일관성보다 강하다

##### 9.3.1.4. 인과적 의존성 담기

#### 9.3.2.  일련번호 순서화

##### 9.3.2.1. 비인과적 일련번호 생성기

##### 9.3.1.7. 램포트 타임스탬프

램포트 타임스탬프로 인과성에 일관적인 일련번호를 생성할 수 있다.

##### 9.3.1.8. 타임스탬프 순서화로는 충분하지 않다

두 사용자가 동시에 동일한 사용자 ID로 계정을 생성하려고 하면 둘 중 한 명은 성공하고 다른 사람은 실패해야하는 상황
- 타임스탬프 순서화는 두사람 모두에게서 타임스탬프 정보를 받은 후에야 비교할 수 있다.
- 사용자로부터 사용자명 생성 요청을 받고 그 요청의 성공/실패 여부를 당장 결정해야할때 이 방법은 부족하다.

문제점: 전체 순서는 모든 연산을 모은 후에야 드러난다.


타임스탬프 순서화는 사후에 성공하는 쪽을 결정할 수는 있지만 

#### 9.3.3. 전체 순서 브로드 캐스트

##### 9.3.3.1. 전체 순서 브로드캐스트 사용하기
##### 9.3.3.2. 전체 순서 브로드캐스트를 사용해 선형성 저장소 구현하기

선형성 쓰기를 보장하지만, 선형성 읽기는 모장하지 않는다.
로그로부터 비동기로 갱신되는 저장소를 읽으면 오래된 값이 읽힐 수 있다.
- 순차적 일관성, 타임라인 일관성은 보장한다.

##### 9.3.3.3. 선형성 저장소를 사용해 전체 순서 브로드캐스트 구현하기


### 9.4. 분산 트랜잭션과 합의


