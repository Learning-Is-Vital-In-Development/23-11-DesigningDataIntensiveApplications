# 09. 일관성과 합의

- 결함을 다루는 가장 간단한 방법은 전체 서비스가 실패하도록 두고 사용자에게 오류 메시지를 보여주는 것이다.
- 이 외에는 내부 구성 요소 중 뭔가에 결함이 있더라도 서비스가 올바르게 동작하게할 견뎌낼(tolerating) 방법을 구축하는 것이다.
- 내결함성을 지닌 시스템
    - 유용한 보장 범용 추상화를 찾아 이를 구현하고 애플리케이션에게 이 보장에 의존
        - 트랜잭션을 사용하면 원자성, 격리성, 지속성의 문제에 대한 걱정을 하지 않게 해준다.
    - 노드들의 합의를 통해 새 리더를 뽑는 방법
        - 스플릿 브레인(split brain)등의 문제를 피할 수 있다.

## 일관성 보장

동시에 데이터베이스 노드 2개 이상을 보면 다른 데이터를 볼 수 있다. 각 노드들에게 쓰기 요청이 도착하는 시간이 다르기 때문이다.

**최종적 일관성**

- 복제 데이터베이스
    - 결국 모든 읽기 요청이 같은 값을 반환하게 되는 것
    - 언제 복제본의 값이 같은 값으로 수렴할지 보장하지 않는다.
- 애플리케이션 개발자에게 어려움
    - 에지케이스를 발견하기 어렵다.
        - 동시성이 높거나 시스템 결함(네트워크 끊김 등)이 있을 때 분명히 드러난다.

분산 일관성 모델은 트랜잭션 격리 수준 계층과 비슷한 점이 있다.

- 트랜잭션 격리는 동시에 실행되는 트랜잭션 때문에 발생하는 경쟁 조건을 회피하는 것에 관한 이야기이다.
- 분산 일관성은 대개 지연과 결함이 이썯라도 복제본의 상태를 코디네이션하는 것에 관한 이야기이다.

앞으로 볼 내용

- 공통적으로 사용하는 강한 일관성 모델 중 하나인 **선형성(linearizability)**을 살펴보고 장점과 단점을 검토
- 분산 시스템에서 이벤트 순서화 문제, 특히 인과성과 전체 순서화와 관련된 문제를 검토

## 선형성

데이터베이스가 하나의 복제본만 있다는 개념으로 클라이언트가 똑같은 데이터를 보고 복제 지연을 걱정할 필요가 없도록 만들어주는 것이 선형성을 뒷받침 하는 아이디어이다. 이와 똑같은 개념이 아래와 같다.

- 원자적 일관성(atomic consistency)
- 강한 일관성(strong consistency)
- 즉각 일관성(immediate consistency)
- 외부 일관성(external consistency)

선형성은 또한 클라이언트가 쓰기를 완료하자마자 볼 수 있어야하기 때문에 **최신성 보장(recency gurantee)**가 이뤄져야 한다.

비선형 시스템
![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/dc556267-3f16-4972-a6a3-3576c20e8793)
- Follwer2가 오래된 결과를 반환했다는 사실은 선형성 위반이다.

### 시스템에 선형성을 부여하는 것은 무엇인가?

시스템 데이터 복사본이 하나뿐인 것처럼 보이게 만듦

선형성 데이터베이스는 동시에 같은 키 x를 읽고 쓰는 새 클라이언트를 보여준다.

분산 시스템 분야에서 x는 **레지스터(register)**라고 불린다.
![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/c7343a95-edb8-431c-90bd-60fec45191c1)

- read(x) ⇒ v는 클라이언트가 레지스터 x의 값을 읽기를 요청했고 데이터베이스가 값 v를 반환했다는 것을 의미
- write(x, y) ⇒ r은 클라이언트가 레지스터 x의 값을 v로 설정하라고 요청했고 데이터베이스가 응답 r(ok일 수도 error 일 수도 있다)을 반환했다는 것을 의미

write연산 앞뒤의 값은 명확하다. write 연산과 동시에 실행된 읽기 연산은 쓰기의 영향을 받을 수 있을수도 있고 안받을 수도 있다. 다만, 이는 선형성 시스템을 설명하기는 역부족이다. 쓰기가 진행되는 동안 오래된값과 새로운값이 바뀔 수 있기 때문이다.
![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/c3065d9c-de3c-4e65-a4ee-d0df3a8bda84)

선형성 시스템은 쓰기연산이 완료되지 않더라도 값이 일관적이어야 한다. 즉, 0에서 1로 바뀌는 어떤 시점이 있어야 한다.
![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/3eadbb3d-ddce-4112-8d6d-ff1ac7ad025c)

- cas(x, v(old), v(new)) ⇒ r은 클라이언트가 원자적 compare-and-set 연산을 요청했다는 뜻이다. 레지스터 x의 현재값이 v(old)와 같으면 원자적으로 v(new)로 설정돼야 한다. X ≠ v(old)라면 이 연산은 레지스터를 그대로 두고 오류를 반환해야 한다. r은 데이터베이스의 응답이다(ok나 error).

> 선형성 대 직렬성
> 
> **선형성**
> 레지스터에 실행되는 읽기와 쓰기에 대한 최신성 보장. 연산을 트랜잭션으로 묶지 않아 충돌 구체화 같은 부가적인 수단을 사용하지 않으면 쓰기 스큐 같은 문제를 막지 못한다.
> 
> **직렬성**
> 트랜잭션들이 어떤 순서에 따라 실행되는 것처럼 동작하도록 보장해준다. 그 순서가 트랜잭션들이 실제로 실행되는 순서와 달라도 상관없다.
> 
> 데이터베이스가 직렬성과 선형성을 모두 제공하려고 하는 경우 이를 엄격한 직렬성(strict serializability)이나 강한 단일 복사본 직렬성(strong one-copy serializability, strong-1SR)이라고 한다. 2단계 잠급이나 실제 직렬 실행을 기반으로 한 직렬성 구현이 보통 선형적이다. 하지만 직렬성 스냅숏 격리는 선형적이지 않다. 일관된 스냅숏의 요점은 스냅숏에 스냅숏보다 나중에 실행된 쓰기를 포함하지 않는다는 의미여서 스냅숏에서 읽으면 선형적이지 않다.

### 선형성에 기대기

#### 잠금과 리더 선출

- 단일 리더 복제를 사용하는 시스템은 리더가 하나만 존재하도록 보장해야 한다.
    - 잠금을 사용해야한다.
    - 모든 노드는 어느 노드가 잠금을 소유하고 리더가 되는지 동의해야한다.
- 분산 잠금과 리더 선출을 구현하기 위해 아파치 주키퍼(Apache ZooKeeper)나 etcd 같은 코디네이션 서비스가 종종 사용된다.

#### 제약 조건과 유일성 보장

- 유일성 제약 조건은 데이터베이스에서 흔하다. 데이터가 기록될 때 제약 조건을 강제하기 위해서는 선형성이 필요하다.
    - 사용자명에 ‘잠금’이나 cas와 비슷하게 사용자명이 점유되었는지를 확인하고 변경한다.
- 제약조건은 모든 노드가 동의하는 최신 값이 있기를 요구한다.
- 애플리케이션에서는 이런 제약 조건을 느슨하게 다뤄도 된다.
- 엄격한 유일성 제약 조건은 선형성이 필요하다. 외래 키나 속성 제약조건같은 다른 종류의 제약 조건은 선형성을 요구하지도 않고도 구현할 수 있다.

#### 채널 간 타이밍 의존성

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/b10334e5-fa4d-41f3-a816-a9e292949e68)

- 이미지 크기 변경 모듈은 크기 변경 작업을 하도록 명시적으로 지시받아야 하고 이 지시는 메시지 큐를 통해 크기 변경 모듈로 보내진다.

부가적인 통신 채널을 제어한다면 복잡성이 추가되는 대안이 될 수 있다.

#### 선형성 시스템 구현하기

선형성은 근본적으로 ‘데이터 복사본이 하나만 있는 것처럼 동작하고 그 데이터에 실행되는 모든 연산은 원자적’이다.

→ 하나의 복사본을 저장한 노드에 장애가 나면 데이터는 손실되거나 노드가 살아날 때까지 접근할 수 없다.

이 시스템이 내결함성을 지니기 위해서 가장 흔한 방법은 복제를 사용하는 것이다.

**단일 리더 복제(선형적이 될 가능성이 있음)**

- 리더는 쓰기에 사용되는 데이터의 주 복사본을 갖고 있고 팔로워는 백업 복사본을 보관한다.
- 리더나 동기식으로 갱신된 팔로워에서 실행된 읽기는 선형적이 될 가능성이 있다.
    - 실제로 선형적이지 않을 수 있다. 스냅숏 격리를 사용하면 동시성 버그가 발생할 수 있다.
- 리더가 아닌 노드가 자신이 리더라고 생각할 가능성이 있다. 따라사서 누가 리더인지 확실히 안다고 가정해야 한다.

**합의 알고리즘(선형적)**

- 합의 프로토콜에는 스플릿 브레인과 복제본이 뒤쳐지는 문제를 막을 수단이 포함된다(뒷장에서 설명)

**다중 리더 복제(비선형적)**

- 다중 리더 복제 시스템은 충돌 해소가 필요한 충돌 쓰기를 만들 수 있다. 이런 충돌은 데이터의 단일 복사본만 존재하는 게 아니라서 발생하는 부산물이다.

**리더 없는 복제(아마도 비선형적)**

- 정족수 읽기와 쓰기를 요구함으로써 ‘엄격한 일관성’을 달성할 수 있다.
- ‘최종 쓰기 승리’ 충돌 해소 방법은 거의 확실한 비선형적이다.
- 느슨한 정족수도 선형성의 가능성을 망친다.

#### 선형성과 정족수

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/8fd10761-f86a-4714-a0e1-c6e5057b05b7)

- 정족수 조건이 만족(w + r > n)이 됨에도 실행은 선형적이지 않다.
- B의 요청은 A의 요청이 완료된 후 시작하지만 A는 새 값을 반환하는 반면 B는 예전값을 반환한다.
- 다이나모 스타일을 선형적으로 만드는게 가능하다.
    - 읽기 복구를 동기식으로 수행
    - 쓰기를 실행하는 클라이언트는 쓰기 요청을 보내기 전에 노드들의 정족수로부터 최신 상태를 읽어야 한다.
    - 선형성 읽기와 쓰기 연산만 구현할 수 있다. 선형성 CAS 연산은 합의 알고리즘이 필요하므로 구현할 수 없다.

다이나모 스타일 복제를 하는 리더 없는 시스템은 선형성을 제공하지 않는다고 보는게 맞다.

### 선형성의 비용
![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/7e9a8f9c-f335-4437-ba65-43f95710912e)

- 네트워크가 끊기면 선형성과 가용성 사이에 선택해야한다.
    - 네트워크가 끊길 때 리더와 연결할 수 없는 데이터센터에서는 애플리케이션을 사용할 수 없다.

#### CAP 정리

트레이드오프

1. 애플리케이션에서 선형성을 요구하면 네트워크 문제 때문에 일부 복제서버가 다른 복제 서버와 연결이 끊기면 일부 복제서버는 연결이 끊긴 동안은 요청을 처리할 수 없다. → **선형적이지만 가용성이 없다.**
2. 애플리케이션에서 선형성을 요구하지 않는다면 각 복제서버가 다른 복제 서버와 연결이 끊기더라도 독립적으로 요청을 처리하는 방식으로 쓰기를 처리할 수 있다. → **가용한 상태를 유지하지만 선형적이지 않다.**

- 선형성이 필요없는 애플리케이션은 네트워크 문제에 강인하다.
- CAP 정리는 사실 실용적인 가치가 거의 없다.

> CAP 정리는 보통 일관성(Consistency), 가용성(Availability), 분단 내성(Partition tolerance)라는 세개 중 두개를 고르라는 것으로 표현된다.
> 
> 하지만 네트워크 분단은 일종의 결함이기 때문에 좋든 실든 발생한다. 따라서 네트워크 분단이 생겼을 때 일관성과 가용성 중 하나를 선택해야한다.

### 선형성과 네트워크 지연

- 최신 다중코어 CPU의 RAM조차 선형적이지 않을 정도로 선형적인 시스템은 드물다.
    - 메인 메모리에 저장하면서 캐시를 한다.
- 이러한 트레이드 오프는 내결함성 대신 성능을 선택했기 때문이다.
- 여러 분산 데이터 베이스도 마찬가지이다.

## 순서화 보장

### 순서화와 인과성

#### 인과적 순서가 전체 순서는 아니다

#### 선형성은 인과적 일관성보다 강하다

#### 인과적 의존성 담기

### 일련번호 순서화

#### 비인과적 일련번호 생성기

#### 램포트 타임스탬프

#### 타임스탬프 순서화로는 충분하지 않다

### 전체 순서 브로드캐스트

#### 전체 순서 브로드캐스트 사용하기

#### 전체 순서 브로드캐스트를 사용해 선형성 저장소 구현하기

#### 선형성 저장소를 사용해 전체 순서 브로드캐스트 구현하기

