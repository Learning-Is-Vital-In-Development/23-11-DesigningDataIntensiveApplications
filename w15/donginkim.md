# 09. 일관성과 합의

- 결함을 다루는 가장 간단한 방법은 전체 서비스가 실패하도록 두고 사용자에게 오류 메시지를 보여주는 것이다.
- 이 외에는 내부 구성 요소 중 뭔가에 결함이 있더라도 서비스가 올바르게 동작하게할 견뎌낼(tolerating) 방법을 구축하는 것이다.
- 내결함성을 지닌 시스템
    - 유용한 보장 범용 추상화를 찾아 이를 구현하고 애플리케이션에게 이 보장에 의존
        - 트랜잭션을 사용하면 원자성, 격리성, 지속성의 문제에 대한 걱정을 하지 않게 해준다.
    - 노드들의 합의를 통해 새 리더를 뽑는 방법
        - 스플릿 브레인(split brain)등의 문제를 피할 수 있다.

## 일관성 보장

동시에 데이터베이스 노드 2개 이상을 보면 다른 데이터를 볼 수 있다. 각 노드들에게 쓰기 요청이 도착하는 시간이 다르기 때문이다.

**최종적 일관성**

- 복제 데이터베이스
    - 결국 모든 읽기 요청이 같은 값을 반환하게 되는 것
    - 언제 복제본의 값이 같은 값으로 수렴할지 보장하지 않는다.
- 애플리케이션 개발자에게 어려움
    - 에지케이스를 발견하기 어렵다.
        - 동시성이 높거나 시스템 결함(네트워크 끊김 등)이 있을 때 분명히 드러난다.

분산 일관성 모델은 트랜잭션 격리 수준 계층과 비슷한 점이 있다.

- 트랜잭션 격리는 동시에 실행되는 트랜잭션 때문에 발생하는 경쟁 조건을 회피하는 것에 관한 이야기이다.
- 분산 일관성은 대개 지연과 결함이 이썯라도 복제본의 상태를 코디네이션하는 것에 관한 이야기이다.

앞으로 볼 내용

- 공통적으로 사용하는 강한 일관성 모델 중 하나인 **선형성(linearizability)**을 살펴보고 장점과 단점을 검토
- 분산 시스템에서 이벤트 순서화 문제, 특히 인과성과 전체 순서화와 관련된 문제를 검토

## 선형성

데이터베이스가 하나의 복제본만 있다는 개념으로 클라이언트가 똑같은 데이터를 보고 복제 지연을 걱정할 필요가 없도록 만들어주는 것이 선형성을 뒷받침 하는 아이디어이다. 이와 똑같은 개념이 아래와 같다.

- 원자적 일관성(atomic consistency)
- 강한 일관성(strong consistency)
- 즉각 일관성(immediate consistency)
- 외부 일관성(external consistency)

선형성은 또한 클라이언트가 쓰기를 완료하자마자 볼 수 있어야하기 때문에 **최신성 보장(recency gurantee)**가 이뤄져야 한다.

비선형 시스템
![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/dc556267-3f16-4972-a6a3-3576c20e8793)
- Follwer2가 오래된 결과를 반환했다는 사실은 선형성 위반이다.

### 시스템에 선형성을 부여하는 것은 무엇인가?

시스템 데이터 복사본이 하나뿐인 것처럼 보이게 만듦

선형성 데이터베이스는 동시에 같은 키 x를 읽고 쓰는 새 클라이언트를 보여준다.

분산 시스템 분야에서 x는 **레지스터(register)**라고 불린다.
![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/c7343a95-edb8-431c-90bd-60fec45191c1)

- read(x) ⇒ v는 클라이언트가 레지스터 x의 값을 읽기를 요청했고 데이터베이스가 값 v를 반환했다는 것을 의미
- write(x, y) ⇒ r은 클라이언트가 레지스터 x의 값을 v로 설정하라고 요청했고 데이터베이스가 응답 r(ok일 수도 error 일 수도 있다)을 반환했다는 것을 의미

write연산 앞뒤의 값은 명확하다. write 연산과 동시에 실행된 읽기 연산은 쓰기의 영향을 받을 수 있을수도 있고 안받을 수도 있다. 다만, 이는 선형성 시스템을 설명하기는 역부족이다. 쓰기가 진행되는 동안 오래된값과 새로운값이 바뀔 수 있기 때문이다.
![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/c3065d9c-de3c-4e65-a4ee-d0df3a8bda84)

선형성 시스템은 쓰기연산이 완료되지 않더라도 값이 일관적이어야 한다. 즉, 0에서 1로 바뀌는 어떤 시점이 있어야 한다.
![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/3eadbb3d-ddce-4112-8d6d-ff1ac7ad025c)

- cas(x, v(old), v(new)) ⇒ r은 클라이언트가 원자적 compare-and-set 연산을 요청했다는 뜻이다. 레지스터 x의 현재값이 v(old)와 같으면 원자적으로 v(new)로 설정돼야 한다. X ≠ v(old)라면 이 연산은 레지스터를 그대로 두고 오류를 반환해야 한다. r은 데이터베이스의 응답이다(ok나 error).

> 선형성 대 직렬성
> 
> **선형성**
> 레지스터에 실행되는 읽기와 쓰기에 대한 최신성 보장. 연산을 트랜잭션으로 묶지 않아 충돌 구체화 같은 부가적인 수단을 사용하지 않으면 쓰기 스큐 같은 문제를 막지 못한다.
> 
> **직렬성**
> 트랜잭션들이 어떤 순서에 따라 실행되는 것처럼 동작하도록 보장해준다. 그 순서가 트랜잭션들이 실제로 실행되는 순서와 달라도 상관없다.
> 
> 데이터베이스가 직렬성과 선형성을 모두 제공하려고 하는 경우 이를 엄격한 직렬성(strict serializability)이나 강한 단일 복사본 직렬성(strong one-copy serializability, strong-1SR)이라고 한다. 2단계 잠급이나 실제 직렬 실행을 기반으로 한 직렬성 구현이 보통 선형적이다. 하지만 직렬성 스냅숏 격리는 선형적이지 않다. 일관된 스냅숏의 요점은 스냅숏에 스냅숏보다 나중에 실행된 쓰기를 포함하지 않는다는 의미여서 스냅숏에서 읽으면 선형적이지 않다.

### 선형성에 기대기

#### 잠금과 리더 선출

- 단일 리더 복제를 사용하는 시스템은 리더가 하나만 존재하도록 보장해야 한다.
    - 잠금을 사용해야한다.
    - 모든 노드는 어느 노드가 잠금을 소유하고 리더가 되는지 동의해야한다.
- 분산 잠금과 리더 선출을 구현하기 위해 아파치 주키퍼(Apache ZooKeeper)나 etcd 같은 코디네이션 서비스가 종종 사용된다.

#### 제약 조건과 유일성 보장

- 유일성 제약 조건은 데이터베이스에서 흔하다. 데이터가 기록될 때 제약 조건을 강제하기 위해서는 선형성이 필요하다.
    - 사용자명에 ‘잠금’이나 cas와 비슷하게 사용자명이 점유되었는지를 확인하고 변경한다.
- 제약조건은 모든 노드가 동의하는 최신 값이 있기를 요구한다.
- 애플리케이션에서는 이런 제약 조건을 느슨하게 다뤄도 된다.
- 엄격한 유일성 제약 조건은 선형성이 필요하다. 외래 키나 속성 제약조건같은 다른 종류의 제약 조건은 선형성을 요구하지도 않고도 구현할 수 있다.

#### 채널 간 타이밍 의존성

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/b10334e5-fa4d-41f3-a816-a9e292949e68)

- 이미지 크기 변경 모듈은 크기 변경 작업을 하도록 명시적으로 지시받아야 하고 이 지시는 메시지 큐를 통해 크기 변경 모듈로 보내진다.

부가적인 통신 채널을 제어한다면 복잡성이 추가되는 대안이 될 수 있다.

#### 선형성 시스템 구현하기

선형성은 근본적으로 ‘데이터 복사본이 하나만 있는 것처럼 동작하고 그 데이터에 실행되는 모든 연산은 원자적’이다.

→ 하나의 복사본을 저장한 노드에 장애가 나면 데이터는 손실되거나 노드가 살아날 때까지 접근할 수 없다.

이 시스템이 내결함성을 지니기 위해서 가장 흔한 방법은 복제를 사용하는 것이다.

**단일 리더 복제(선형적이 될 가능성이 있음)**

- 리더는 쓰기에 사용되는 데이터의 주 복사본을 갖고 있고 팔로워는 백업 복사본을 보관한다.
- 리더나 동기식으로 갱신된 팔로워에서 실행된 읽기는 선형적이 될 가능성이 있다.
    - 실제로 선형적이지 않을 수 있다. 스냅숏 격리를 사용하면 동시성 버그가 발생할 수 있다.
- 리더가 아닌 노드가 자신이 리더라고 생각할 가능성이 있다. 따라사서 누가 리더인지 확실히 안다고 가정해야 한다.

**합의 알고리즘(선형적)**

- 합의 프로토콜에는 스플릿 브레인과 복제본이 뒤쳐지는 문제를 막을 수단이 포함된다(뒷장에서 설명)

**다중 리더 복제(비선형적)**

- 다중 리더 복제 시스템은 충돌 해소가 필요한 충돌 쓰기를 만들 수 있다. 이런 충돌은 데이터의 단일 복사본만 존재하는 게 아니라서 발생하는 부산물이다.

**리더 없는 복제(아마도 비선형적)**

- 정족수 읽기와 쓰기를 요구함으로써 ‘엄격한 일관성’을 달성할 수 있다.
- ‘최종 쓰기 승리’ 충돌 해소 방법은 거의 확실한 비선형적이다.
- 느슨한 정족수도 선형성의 가능성을 망친다.

#### 선형성과 정족수

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/8fd10761-f86a-4714-a0e1-c6e5057b05b7)

- 정족수 조건이 만족(w + r > n)이 됨에도 실행은 선형적이지 않다.
- B의 요청은 A의 요청이 완료된 후 시작하지만 A는 새 값을 반환하는 반면 B는 예전값을 반환한다.
- 다이나모 스타일을 선형적으로 만드는게 가능하다.
    - 읽기 복구를 동기식으로 수행
    - 쓰기를 실행하는 클라이언트는 쓰기 요청을 보내기 전에 노드들의 정족수로부터 최신 상태를 읽어야 한다.
    - 선형성 읽기와 쓰기 연산만 구현할 수 있다. 선형성 CAS 연산은 합의 알고리즘이 필요하므로 구현할 수 없다.

다이나모 스타일 복제를 하는 리더 없는 시스템은 선형성을 제공하지 않는다고 보는게 맞다.

### 선형성의 비용
![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/7e9a8f9c-f335-4437-ba65-43f95710912e)

- 네트워크가 끊기면 선형성과 가용성 사이에 선택해야한다.
    - 네트워크가 끊길 때 리더와 연결할 수 없는 데이터센터에서는 애플리케이션을 사용할 수 없다.

#### CAP 정리

트레이드오프

1. 애플리케이션에서 선형성을 요구하면 네트워크 문제 때문에 일부 복제서버가 다른 복제 서버와 연결이 끊기면 일부 복제서버는 연결이 끊긴 동안은 요청을 처리할 수 없다. → **선형적이지만 가용성이 없다.**
2. 애플리케이션에서 선형성을 요구하지 않는다면 각 복제서버가 다른 복제 서버와 연결이 끊기더라도 독립적으로 요청을 처리하는 방식으로 쓰기를 처리할 수 있다. → **가용한 상태를 유지하지만 선형적이지 않다.**

- 선형성이 필요없는 애플리케이션은 네트워크 문제에 강인하다.
- CAP 정리는 사실 실용적인 가치가 거의 없다.

> CAP 정리는 보통 일관성(Consistency), 가용성(Availability), 분단 내성(Partition tolerance)라는 세개 중 두개를 고르라는 것으로 표현된다.
> 
> 하지만 네트워크 분단은 일종의 결함이기 때문에 좋든 실든 발생한다. 따라서 네트워크 분단이 생겼을 때 일관성과 가용성 중 하나를 선택해야한다.

### 선형성과 네트워크 지연

- 최신 다중코어 CPU의 RAM조차 선형적이지 않을 정도로 선형적인 시스템은 드물다.
    - 메인 메모리에 저장하면서 캐시를 한다.
- 이러한 트레이드 오프는 내결함성 대신 성능을 선택했기 때문이다.
- 여러 분산 데이터 베이스도 마찬가지이다.

## 순서화 보장

순서화, 선형성, 합의 사이에는 깊은 연결 관계가 있다.

- 단일 리더 복제에서 리더의 주 목적은 복제 로그에서 **쓰기의 순서**를 결정하는 것.
- 직렬성은 트랜잭션들이 어떤 일련 **순서에 따라** 실행되는 것처럼 보장하는 것.
- 분산 시스템에서 타임스탬프와 시계 사용은 무질서한 세상에 질서를 부여하려는 시도이다.

### 순서화와 인과성
순서화가 인과성을 보존하는 데 도움을 준다.

- 인과성은 이벤트에 순서를 부과한다. 무엇이 무엇보다 먼저 일어났는가를 정의한다.
- 시스템이 인과성에 의해 부과된 순서를 지키면 **인과적으로 일관적(causally consistent)**이라고 한다.


#### 인과적 순서가 전체 순서는 아니다

- 전체 순서(total order)는 두 요소를 비교할 수 있게 하므로 두 요소가 있으면 항상 어떤 것이 크고 어떤 것이 작은지 말할 수 있다.
    - 자연수
- 수학적 집합은 항상 전체 순서를 정할 수 없다. 따라서 이들을 비교불가(incomparable)하고 따라서 수학적 집합은 부분적으로 순서가 정해진다(partially ordered)

**선형성**

선형성 시스템에서는 연산의 전체 순서를 정할 수 있다. 시스템이 데이터 복사본이 하나만 있는 것처럼 동작하고 모든 연산이 원자적이면 어떤 두 연산에 대해 항상 둘 중 하나가 먼저 실행됐다고 말할 수 있다.

**일관성**

두 연산 중 어떤 것도 다른 것보다 먼저 실행되지 않았다면 두 연산이 동시적이다. 두 이벤트에 인과적인 관계가 있으면 이들은 순서가 있지만 이들이 동시에 실행되면 비교할 수 없다. 인과성이 전체 순서가 아닌 부분 순서를 정의한다는 뜻이다. 어떤 연산들은 서로에 대해 순서를 정할 수 있지만 어떤 연사는 비교할 수 없다.

- 깃 분산 버전 관리 시스템과 같이 동시에 만들어진 커밋을 합쳐진다. 동시성은 이와 같이 타임라인이 갈라졌다가 다시 합쳐지는 것을 의미하며 다른 가지에 있는 연산은 비교 불가하다.

#### 선형성은 인과적 일관성보다 강하다

- 선형성은 인과성을 내포한다.
    - 선형성은 인과성을 보존하는 유일한 방법은 아니다.
    - 많은 경우에 선형성이 필요한것처럼 보이는 시스템은 사실 인과적 일관성을 필요로 한다.
    - 최종적 일관성 시스템과 서능 및 가용성 특성이 비슷하면서 인과성을 보존하는 데이터베이스를 연구하고 있다.
- 시스템에 여러 통신 채널이 있을 때 선형성은 시스템에서 인과성이 자동으로 보존되도록 보장해준다.


#### 인과적 의존성 담기

- 인과성을 유지하기 위해서는 어떤 연산이 다른 연산보다 먼저 실행됐는지 알아야 한다. 이것은 부분 순서다.
- 인과적 순서를 결정하기 위해 데이터베이스는 데이터의 어떤 버전을 읽었는지 알아야 한다.
    - 트랜잭션이 커밋을 원할 때 읽은 데이터의 버전이 여전히 최신인지 확인한다.

### 일련번호 순서화

- 모든 인과적 의존성을 추적하는 것은 실용성이 떨어진다.
- 더 좋은 방법으로는 **일련번호**나 **타임스탬프**를 써서 이벤트의 순서를 정할 수 있다.
    - 물리적 시계에서 얻을 필요 없이 논리적 시계에서 얻으면 된다.
- 이러한 일련번호나 타임스탬프는 크기가 작고 **전체 순서**를 제공한다.
- 특히 **인과성에 일관적인** 전체 순서대로 일련번호를 생성할 수 있다.
    - 연산 A가 연산 B보다 인과적으로 먼저 실행되었다면 A는 전체 순서에서도 B보다 먼저다.
- 단일 리더 복제를 쓰는 데이터베이스에서는 복제 로그가 인과성에 일관적인 쓰기 연산의 전체 순서를 정의한다.
    - 리더는 연산마다 카운터를 증가시키고 복제 로그의 연산에 단조 증가하는 일련번호를 할당하기만 하면 된다.

#### 비인과적 일련번호 생성기

- 단일 리더가 없다면 연산에 사용할 일련번호를 생성하는 방법이 명확해 보이지 않다.
    - 각 노드가 자신만의 독립적인 일련번호 집합을 생성할 수 있다. (몇 비트를 예약해서 고유 노드 식별자를 포함하는 방법입니다.)
    - 각 연산에 일 기준 시계에서 얻은 타임스탬프를 붙일 수 있다.
    - 일련번호 블록을 미리 할당할 수 있다.
- 위의 세가지 선택지는 카운터를 증가하는 단일 리더에 모든 연산보다는 확장성이 좋으나, 생성된 일련번호가 인과성에 **일관적이지 않다.** (근사적)
- 아래의 인과성 문제점이 발생할 수 있다.
    - 각 노드는 초당 연산수가 다를 수 있다.
    - 물리적 시계에서 얻은 타임스탬프는 시계 스큐에 종속적이다.
    - 블록 할당자의 경우, 한 연산이 1001과 2000사이의 구간에서 일련번호를 받고 인과적으로 나중에 실행되는 연산이 1과 1000사이의 구간에서 일련번호를 받을 수 있다.

#### 램포트 타임스탬프

- 인과성에 일관적인 일련번호를 생성하는 간단한 방법이 있으며 이를 **램포트 타임스탬프(Lamport timestamp)** 라고 부른다.
- 램포트 타임스탬프는 **(카운터, 노드ID)** 의 쌍이다.
![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/b789e56e-48ed-4aeb-b7a2-40a22802a0c9)
- 램포트 타임스탬프는 물리적 일 기준 시계와 아무 관련이 없으나 전체 순서화를 제공한다.
    - 두 타임 스탬프가 있으면 카운터가 큰 것이 타임스탬프가 크며, 카운터 값이 같으면 노드 ID가 큰 것이 타임 스탬프가 크다.
- 핵심 아이디어는 모든 노드와 모든 클라이언트가 본 카운터 값 중 **최댓값**을 추적하고 모든 요청에 그 최댓값을 포함한다.
- 램포트 타임스탬프는 버전 벡터와 혼동될 수 있지만 목적이 다르다.
    - 버전 벡터는 두 연산이 동시적인지 또는 어떤 연산이 다른 연산에 인과적으로 의존하는지 구별할 수 있지만 램포트 타임스탬프는 항상 전체 순서화를 강제한다.


#### 타임스탬프 순서화로는 충분하지 않다

- 램포트 타임스탬프가 인과성에 일관적인 연산의 전체 순서를 정의하지만 분산 시스템의 공통 문제를 해결하는 데 충분하지는 않다.
- 램포트 타임스탬프는 사후에 성공하는 쪽을 결정하는 데는 효과적이다. 시스템에서 사용자명 생성 연산을 모두 모으면 그들의 타임스탬프를 비교할 수 있다.
- 그러나 노드가 사용자로부터 사용자명 생성 요청을 막받고 그 요청이 성공해야 하는지 실패해야 하는지 **당장** 결정해야 할 때는 이 방법으로 부족하다.
- 다른 어떤 노드도 동시에 더 낮은 타임스탬프를 가지고 동일한 사용자명으로 계정 생성을 처리하는 중이 아니라고 확신하려면 다른 노드가 무엇을 하고 있는지 확인해야 하며, 다른 노드 중 하나에 장애가 생기거나 네트워크 문제 때문에 연결할 수 없다면 시스템이 멈추게 된다.
    - 즉, 연산의 전체 순서는 모든 연산은 모은 후에야 드러난다.
- 결론적으로, 사용자명에 대해 유일성 제약 조건 같은 것을 구현하려면 연산의 전체 순서가 있는 것으로는 충분하지 않다.
    - 이를 해결하는 아이디어로 **전체 순서 브로드캐스트**가 등장했다.


### 전체 순서 브로드캐스트

단일 리더 복제는 한 노드를 리더로 선택하고 리더의 단일 CPU 코어에서 모든 연산을 차례대로 배열함으로써 연산의 전체 순서를 정한다. 분산 시스템 분야에서 이 문제는 **전체 순서 브로드캐스트(total order broadcast)** 나 **원자적 브로드 캐스트(atomic broadcast)** 로 알려져 있다.

전체 순서 브로드캐스트는 보통 노드 사이에 메시지를 교환하는 프로토콜로 기술되며 아래의 두 가지 안전성 속성을 항상 만족해야 합니다.

- 신뢰성 있는 전달(reliable delivery)
    - 어떤 메시지도 손실되지 않습니다. 메시지가 한 노드에 전달되면 모든 노드에도 전달됩니다.
- 전체 순서가 정해진 전달(Totally ordered delivery)
    - 메시지는 모든 노드에 같은 순서로 전달됩니다.

전체 순서 브로드캐스트를 구현하는 올바른 알고리즘은 노드나 네트워크에 결함이 있다라도 신뢰성과 순서화 속성이 항상 만족되도록 보장해야 한다.

#### 전체 순서 브로드캐스트 사용하기


- 주키퍼나 etcd 같은 합의 서비스는 전체 순서 브로드캐스트를 실제로 구현한다.
- 모든 메시지가 데이터베이스의 쓰기를 나타내고 모든 복제 서버가 같은 쓰기 연산을 같은 순서로 처리하면 복제 서버들은 서로 일관성 있는상태를 유지합니다. 이 원리를 **상태 기계 복제(state machine replication)** 이라고 합니다.
- 전체 순서 브로드캐스트는 직렬성 트랜잭션을 구현하는데도 쓸 수 있습니다.
    - 모든 노드가 메시지들을 같은 순서로 처리한다면 데이터베이스의 파티션과 복제본은 서로 일관적인 상태를 유지한다.
- 전체 순서 브로드캐스트의 중요한 특면은 메시지가 전달되는 시점에 그 순서가 고정된다.
    - 이 때문에 전체 순서 브로드캐스트가 타임스탬프 순서화보다 강하다.
- 전체 순서 브로드캐스트를 보는 또 다른 관점은 **로그**를 만드는 방법 중 하나다.
    - 전체 순서 브로드캐스트는 펜싱 토큰을 구현하는데도 유용하다.

#### 전체 순서 브로드캐스트를 사용해 선형성 저장소 구현하기

- 전체 순서 브로드캐스트는 비동기식이다.
    - 메시지는 고정된 순서로 신뢰성 있게 전달되도록 보장되지만 언제 메시지가 전달될지는 보장되지 않는다.
- 전체 순서 브로드캐스트 구현을 기반으로 선형성 저장소를 만들 수 있다.
    - compare-and-set 연산을 다음과 같이 구현할 수 있다.
        1. 메시지를 로그에 추가해서 점유하기 원하는 사용자명을 시험적으로 가리킨다.
        2. 로그를 읽고, 추가한 메시지가 되돌아오기를 기다린다.
        3. 원하는 사용자명을 점유하려고 하는 메시지가 있는지 확인한다.
- 위 절차는 선형성 쓰기를 보장하지만 선형성 읽기는 보장하지 않는다. 즉, 비동기로 갱신되는 저장소를 읽으면 오래된 값이 읽힐 수 있다. (**타임라인 일관성** 이라 부른다.)
- 읽기를 선형적으로 만들려면 아래의 선택지가 있다.
    - 로그를 통해 순차 읽기를 할 수 있습니다. 고르에 메시지를 추가하고 로그를 읽어서 메시지가 되돌아왔을 때 실제 읽기를 수행하면 된다.
    - 로그에서 최신 로그 메시지의 위치를 선형적 방법으로 얻을 수 있다면 그 위치를 질의하고 그 위치까지의 모든 항목이 전달되기를 기다린 후 읽기를 수행할 수 있다.
    - 쓰기를 실행할 때 동기식으로 갱신돼서 최신이 보장되는 복제 서버에서 읽을 수 있다.

#### 선형성 저장소를 사용해 전체 순서 브로드캐스트 구현하기

- 위에서는 전체 순서 브로드캐스트로부터 선형성 compare-and-set 연산을 구현하는 방법이었으나 이 반대도 가능하다.
- 가장 쉬운 방법은 정수를 저장하고, 원자적 increment-and-get 연산이 지원되는 선형성 레지스터가 있다고 가정하는 것이다.
    - 이 연산을 통해 레지스터에서 얻은 값을 일련번호로 메시지에 붙인다.
    - 메시지를 모든 노드에 보낼 수 있고 수신자들은 일련번호 순서대로 메시지를 전달한다.
- 핵심은 선형성 compare-and-set(혹은 increment-and-get) 레지스터와 전체 순서 브로드캐스트는 둘 다 **합의와 동등하다고(equivalent to consensus)** 증명할 수 있다.
