# 일관성과 합의

분산 시스템은 잘못될 수 있다. 이런 결함을 다루는 가장 쉬운 방법은 실패하도록 두고 에러 메세지를 사용자에게 보여주는 것이다. 이러한 해결책이 받아들여지기 어렵다면 내결함성(tolerating)을 지니도록 해야 한다.

해당 챕터에서는 분산 시스템 구축에 쓰이는 알고리즘과 프로토콜의 몇가지 예를 다룬다. 앞서 이야기된 모든 문제가 발생할 수 있다고 가정한다.

유용한 보장을 해주는 추상화를 찾아서 이를 구현하고 애플리케이션이 이 보장을 의존하도록 하는 것이 가장 좋은 방법이다. 그 예로 트랜잭션이 있을 수 있다.

이 과정에서 어떤 것을 할 수 있고 없는 지에 대한 범위를 이해해야 한다. 어떤 상황은 견딜 수 있으며, 어떤 상황을 견딜 수 없다.

# 일관성 보장

복제가 적용된 데이터베이스는 쓰기 요청의 시차로 인해 DB의 상태가 불일치하는 타이밍이 발생한다. 이러한 문제는 복제 방식과는 무관하게 어떤 경우라도 발생할 수 있다.

복제 데이터베이스는 일반적으로 **최종적 일관성**을 제공한다. 하지만 이것은 매우 약한 보장이다. 최종적 일관성을 언제 도달하는 지 알 수 없기 때문이다.

분산 일관성의 관심사는 대개 지연과 결함이 있더라도 복제본의 상태를 코디네이션하는 것이다.

- 공통적으로 사용되는 가장 강한 일관성 모델 중 하나인 선형성(linearizablility)
- 이벤트 순서화. 특히, 인과성과 전체 순서화
- 분산 트랜잭션을 원자적으로 커밋하는 방법

# 선형성

최종적 일관성 지닌 데이터 베이스의 복제본이 2개라면 클라이언트는 다른 응답을 받을 수도 있다. 1개만 있다고 가정하면 모든 클라이언트는 같은 데이터를 보고 있기 때문에 복제 지연을 걱정할 필요가 없다.

이것이 선형성을 뒷받침하는 아이디어이다. 즉, 시스템에 대한 복제본은 1개이며 이 데이터에 대한 모든 연산이 원자적인 것처럼 보이도록 한다.

## 시스템에 선형성을 부여하는 것은 무엇인가?

선형성 데이터베이스에서 동시에 같은 키 x에 여러 클라이언트가 읽을 수 있다. x는 키-값 저장소의 키, 관계형 데이터베이스의 로우, 문서 데이터베이스의 문서가 될 수 있다. 분산 시스템에서 이러한 x를 레지스터(register)라고 부른다.

![비선형 시스템에서는 읽기 요청이 쓰기 요청과 동시에 실행되면 과거 값을 반환할 수도, 새로운 값을 반환할 수도 있다.](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/61923768/50c8ef2f-c923-4e90-aaa9-dfa9ff26bb46)

비선형 시스템에서는 읽기 요청이 쓰기 요청과 동시에 실행되면 과거 값을 반환할 수도, 새로운 값을 반환할 수도 있다.

위 예제에서 2가지 종류의 연산이 있다.

- read(x)⇒ v : 클라이언트가 레지스터 x의 값을 읽기 요청하고 데이터베이스가 x의 값을 반환
- write(x, v) ⇒ r : 클라이언트가 레지스터 x의 값을 v로 쓰기 요청하고 데이터베이스가 그 결과를 반환

위 예제에서 레지스터 x의 값은 0이었고 이후에 client C에 의해 1로 수정된다. 이 과정에서 clien A와 B는 최신값을 얻기 위해 폴링한다. A와 B는 자신의 읽기 요청에 어떤 응답을 받을 수 있을까?

- client A
    - 첫번째 read(x)는 명백하게 0을 반환한다.(쓰기 요청 이전)
    - 마지막 read(x)는 명백하게 1을 반환한다.(쓰기 요청 완료 이후)
    - 중간의 read(x)는 0을 반환했을 수도 1을 반환했을 수도 있다.
- client B
    - 첫번째 read(x)는 0을 반환했을 수도 1을 반환했을 수도 있다.
    - 마지막 read(x)는 0을 반환했을 수도 1을 반환했을 수도 있다.

이것으로 선형성을 완전하기에 부족하다. 쓰기가 진행되는 동안 읽기 요청에 대해서 오래된 값이나 새로운 값을 반환한다면 읽기를 실행하는 측은 쓰기가 진행되는 동안 값이 여러번 왔다갔다할 수 있다. 이것은 “데이터의 단일 복사본”을 모방하는 시스템에 기대하는 바가 아니다.

시스템을 선형적으로 만드릭 위해서는 또 다른 제약조건을 추가 해야한다.

![읽기가 새로운 값을 반환한 적이 있다면 이후에 모든 읽기는 새로운 값으로 반환되어야 한다.](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/61923768/725ec9bc-3ad9-401f-9160-825b28988629)

읽기가 새로운 값을 반환한 적이 있다면 이후에 모든 읽기는 새로운 값으로 반환되어야 한다.

선형성 시스템에서는 레지스터의 값이 바뀌는 특정 시점 있다고 생각하고 그 시점 이후엔 일관되게 변경된 값을 반환해야 한다. 위 그림에서는 client A의 읽기 반환된 이후 시작된 client B의 새로운 읽기는 확실히 A보다 뒤에 실행되므로 C의 쓰기가 진행 중이더라도 1을 반환해야 한다.

새로운 연산을 추가한다.

- cas(x, v_old, v_new) ⇒ r : 클라이언트가 원자적으로 compare-and-set 연산 요청 및 결과를 반환

![읽기와 쓰기 영향이 나타나는 것으로 보이는 시점을 시각화 하기. B의 마지막 읽기는 선형적이지 않다](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/61923768/0f4806ea-a469-405d-839f-1ba6e99c565d)

읽기와 쓰기 영향이 나타나는 것으로 보이는 시점을 시각화 하기. B의 마지막 읽기는 선형적이지 않다

각 연산이 실행되었다고 생각하는 시점이 수직선으로 표시돼 있다.

- B가 읽기 요청을 보낸 후 C와 A가 쓰기 작업을 요청한다. 하지만 읽기 반환을 쓰기가 모두 종료된 값이다.
  → 이것은 요청을 보낸 순서와는 다르게 요청이 동시적이기 때문에 이 순서도 허용된다.
- B의 읽기는 A의 쓰기가 성공했다는 응답을 받기 전에 1을 반환했다.
  → 이것 역시 값이 쓰기 전에 읽힌 것이 아니라 A가 응답을 받기 전에 B가 읽고 응답을 받은 것이다.
- 이 모델은 어떠한 트랜잭션 격리도 가정하지 않는다. 따라서 다른 클라이언트가 값을 바꿨는지 확인하기 위해 CAS 연산을 수행한다.
- 회색의 B의 읽기는 선형적이지 않다. C의 `cas(x,2,4)`와 동시적이기 때문에 A의 읽기 요청이 없었다면, 또는 아직 응답을 받지 않았다면 2를 응답 받아도 된다. 하지만 이미 A가 4를 반환 받았기 때문에 과거값을 읽는 것은 허용되지 않는다.

## 선형성에 기대기

시스템이 올바르게 동작하기 위해서 선형성이 중요하게 요구되는 몇가지 영역이 있다.

### 잠금과 리더 선출

단일 리더 복제 시스템은 진짜로 리더가 1명이도록 보장되어야 한다. 이를 위한 가장 쉬운 방법은 잠금을 이용하여 잠금을 획득한 노드가 리더 노드가 되는 방식이다. 잠금의 구현과 관계 없이 모든 노드는 어떤 노드가 잠금을 소유하는 지에 대해 동의해야 한다.

분산 잠금과 리더 선출 구현을 위해 아파치 주키퍼와 etcd와 같은 코디네이션 서비스가 종종 사용된다. 분산 잠금은 오라클 리얼 애플리케이션 클러스터(Oracle Real Application Cluster, RAC) 같은 분산 데이터베이스에서 훨씬 세분화된 수준 사용되기도 한다.

### 제약 조건과 유일성 보장

데이터가 기록될 때 유일성 보장을 위한 제약 조건을 강제하고 싶다면 선형성이 필요하다. 이 상황을 잠금을 이용하는 것과 유사하다. 실제 애플리케이션에서 이런 제약 조건이 때로는 느슨하게 다뤄도 된다.

### 채널 간 타이밍 의존성

![Untitled](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/61923768/dd5b1783-f8ba-41d0-a19c-072f6533e740)

파일 저장 후 이미지의 크기를 변경하는 이 시스템은 선형적이지 않다면 경쟁 조건의 위험이 있다. 메세지 큐 메세지를 전달하는 과정(3,4)이가 파일 저장소의 저장(2)보다 빠르다면 크기 변경 모두에서 이미지를 읽을 때(5) 과거 버전을 보거나 이미지가 없을 수 있다.

이 문제는 웹서버와 이미지 크기 변경 모듈 사이의 2가지 통신 채널(파일 저장소, 메세지 큐)로 인해서 발생한다. 선형성이 유일한 경쟁 조건 회피 방법은 아니지만 이해하기 가장 단순하다.

## 선형성 시스템 구현하기

선형성은 근본적으로 “데이터 복사본이 하나만 있는 것처럼 동작하고 그 데이터에 실행되는 모든 연산은 원자적이다”라는 의미이다. 이에 대한 가장 간단한 해법은 정말 데이터 복제본 하나만 사용하는 것이지만 내결함성을 가질 수 있다. 내 결함성을 지니도록 만드는 가장 쉬운 방법인 복제를 사용하고 복제방법을 살펴보자.

- 단일 리더 복제(선형적 가능성 있음)
    - 리더가 주 복제본을 가지고 있고 리더나 동기적으로 갱신되는 팔로워에서는 실행한 읽기는 **선형적이 될 가능성이 있다.** 그러나 실제로 단일 리더 데이터 베이스가 선형적이지 않을 수 있다.
- 합의 알고리즘(선형적)
    - 후반부에 설명하는 어떤 알고리즘은 단일 리더 복제를 닮았다. 그러나 합의 프로토콜에서는 스플릿 브레인과 복제본이 뒤쳐지는 문제를 막을 수단이 포함되어 있다.
- 다중 리더 복제(비선형적)
    - 다중 리더 복제 시스템은 일반적으로 선형적이지 않다. 여러 노드에서 동시에 쓰기를 처리하고 비동기로 복제하기 때문이다.
- 리더 없는 복제(아마도 비선형적)
    - 정족수 읽기, 쓰기를 통해 엄격한 일관성으 ㄹ달성할 수 있다고 주장하지만 일 기준 시계 기반의 최정 쓰기 승리 충돌 해소법은 거의 확실히 비선형적이며, 느슨한 정족수도 선형성의 가능성을 망친다.

### 선형성과 정족수

![Untitled](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/61923768/dd27a090-b5f3-489a-bab4-4e5e18a50659)

다이나모 스타일(리더 없는 복제) 모델에서 엄격한 정족수를 사용한 읽기 쓰기는 선형적인 것처럼 보인다. x의 초깃값은 0이고 쓰기 클라이언트가 x를 1로 쓰기 요청을 보낸다. (n=3, w=3) 동시에 클라이언트 A는 두 노드에서 읽어서 하나의 새로운 값 1을 본다. 또 쓰기와 동시에 클라이언트 B는 두 노드로 구성된 다른 정족수로부터 읽어서 두 노드 모두 예전 값 0을 본다. (1을 읽은 뒤에 다시 0을 읽게 됨, 비선형적)

성능은 다소 포기한다면 읽기 클라이언트는 결과 반환 전에 읽기 복구를 동기식으로 수행하고 쓰기 클라이언트는 쓰기 전 최신 상태를 읽어 선형적으로 만들 수 있다. 이 방법으로는 선형적 읽기과 쓰기만 보장할 뿐, cas 연산을 동시에 실행하면 선형성을 잃게 된다.

## 선형성의 비용

두 데이터 센터 사이의 네트워크 연결이 끊기면 선형성과 가용성 사이에 선택을 해야 한다. 다중 리더 쓰기라면 네트워크 연결이 끊어지더라도 각각의 데이터 센터에서 쓰기를 처리하고 네트워크 복구 후 비동기로 동기화할 수 있다.

단일 리더 복제라면 리더가 아닌 데이터 센터는 쓰기가 불가능하게 되어 선형성을 읽게 된다. 읽더라도 과거의 값을 읽을 수도 있다. 클라이언트가 리더가 있는 데이터 센터에 연결이 가능하다면 정상 동작할 수도 있지만 그게 아니라면 한동안 서비스 중단을 경험하게 된다.

### CAP 정리

위 문제는 단순히 복제 전략의 문제나 데이터 센터의 문제가 아니다. 신뢰성 없는 네트워크에서는 언제든지 발생할 수 있다.

- 애플리케이션에 **선형성을 요구하면,** 네트워크 문제가 발생했을 때 **일부 복제 서버는 가용성이 없다.**
- 애플리케이션에 **선형성을 요구하지 않는다면,** 네트워크 문제가 발생하더라고 복제 서버는 가용적이다.

이러한 통찰은 CAP 정리로 널리 알려졌다.

### 선형성과 네트워크 지연

선형성은 유용한 보장이지만 실제로는 거의 없다.  CPU에서는 성능을 위해 내 결합성을 포기하기도 한다. 여러 분산 데이터베이스에서도 마찬가지다. 선형성을 느리고 그건 네트워크 결함과 무관하게 항상 참이다.

# 순서화 보장

순서화는 이 책에서 되풀이되는 주제이다. 따라서 설계에서 중요한 근본적 아이디어 일 수 있다. 앞서 단일 리더 복제에서는 쓰기의 순서화가 목적이라고 이야기할 수 있다. 트랜잭션의 직렬성 역시 순서화의 일환이다.

## 순서화와 인과성

순서화가 자주 나오는 한가지 이유는 인과성을 보존하는데 큰 도움을 주기 때문이다. 답변을 하기 위해서는 질문이 앞서 와야하는 것처럼 **인과적 의존성(causal dependency)**가 있다고 말한다. 동시에 연산이 발생할 경우 한가지 먼저 발생했거나 동시에 발생했을 수 있다. 한가지가 먼저 발생했을 경우 다른 한가지는 이전의 연산을 알거나 기반으로 할 수도 있다. 이를 **이전 발생(happened before)**이라고 한다. 동시에 실행될 경우 둘 간의 인과적 연결이 없거나 확신할 수 없다. 트랜잭션에서 스냅숏 격리는 **일관적인 인과성(consistent with causally)**을 제공하는 것에 의미가 있다.

인과적인 행위들은 필연적으로 의존성을 가지게 되고 이는 순서를 의미한다. 원인은 항상 결과 이전에 발생해야 하기 때문에 순서화는 인과성을 보존하는데 큰 도움을 준다.

### 인과적 순서가 전체 순서는 아니다.

어떤 요소의 **전체 순서(total order)**는 두 요소의 대소를 명확하게 나타낼 수 있다. 하지만 수학적 집합에서는 전체 순서를 정할 수 없다. 단, 한 집합이 다른 집합의 모든 요소를 포함하는 경우에 명확히 대소를 표현할 수 있다. 이 외에는 **비교 불가능(incomparable)**하고 이를 **부분 순서(patially ordered)**라고 한다.

선형성은 전체 순서를 인과성은 부분 순서를 정할 수 있다. 이 정의에 따르면 선형성 데이터 스토어에서는 동시 연산이 없다.

### 선형성은 인과적 일관성보다 강하다.

선형성은 인과성을 내포한다. 어떠한 특별한 일을 할 필요 없이 인과성이 자동으로 보존되도록 보장한다. 하지만 선형성의 비용은 성능과 가용성이 해가 될 수도 있다. 결국 시스템에 필요한 것은 인과적 일관성이며 이를 달성하기 위해 새로운 종류의 데이터 베이스를 연구하고 있다.

### 인과적 의존성 담기

비선형적 시스템에서 인과적 일관성 달성하기 위한 핵심 아이디어 중 일부를 살펴보자. 인과성 유지를 위해서는 어떤 연산이 다른 연산보다 **먼저 실행** 되었는지 알아야 한다. 동시에 실행되는 연산의 순서는 상관 없지만 한 연산이 다른 연산보다 먼저 실행 되었다면 모든 서버에서도 이 순서에 따라 실행되어야 한다.

인과적 순서를 결정하기 위해 애플리케이션이 어떤 버전을 읽었는지 알아야 한다. 트랜잭션이 커밋을 원할 때 읽은 버전이 여전히 최신인지 알아야 한다.

## 일련번호 순서화

인과성은 중요한 개념이지만 실제로 모든 인과적 의존성을 추적하는 것은 오버헤드가 크다. 이보다 일련번호나 타임스탬프 등을 이용해 순서를 정하는 것이 더 좋은 방법일 수 있다. 이것들은 적은 메모리로 전체 순서를 제공한다. 전체 순서는 일관된 인과성을 보장해줄 수 있다.

### 비인과적 일련번호 생성기

각 노드가 독립적인 일련 번호 생성하기, 각 노드가 일련 번호의 일부를 미리 할당받아서 사용하기, 물리적 시계의 타임스탬프 사용하기 등을 통해 고유한 근사 증가하는 일련번호를 생성할 수 있다. 또한 쉽게 확장이 가능하다. 하지만 생성한 일련 번호가 인과성에 일관적이지 않다.

예를 들어 홀수와 짝수로 이루어진 독립적 일련 번호 생성기에서도 속도에 따라 순서가 달라질 수 있으며 짝수와 홀수 사이에는 인과적인 우선순위를 설명할 수 없다.

### 램포트 타임스탬프

인과성에 일관적인 일련 번호를 생성하는 간단한 방법은 **램포트 타임스탬프(Lamport Timestamp)**이다.

![Untitled](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/61923768/ab98c9ca-f127-4bd3-926a-4939eb9e22bd)

각 노드는 고유 식별자를 갖고 처리한 연산 개수를 카운트로 유지한다. 램포트 타임스탬프는 물리적 시계와 관련 없이 전체 순서화를 제공한다. 두 타임 스탬프가 있으면 카운터가 큰 것이 타임스탬프가 크다. 카운터 값이 같으면 노드 ID가 큰 것이 타임 스탬프가 크다.

모든 노드와 클라이언트가 지금까지 본 카운트의 최대 값을 유지하고 이를 모든 요청에 포함시키는 것이 핵심 아이디어다. 노드는 자신의 카운터 값보다 큰 카운터 값을 받으면 자신의 카운터를 최대 값으로 증가 시킨다. 스탬프의 전체 순서화로부터 두 연산은 동시적인지 인과적으로 의존성이 있는 지는 알 수 없다.

### 타임스탬프 순서화로는 충분하지 않다.

그러나 당장 순서를 결정해야할 때는 이것으로 부족하다. 다른 노드가 연산에 어떤 타임스탬프를 배정할 지 모르기 때문이다. 언제 전체 순서가 확정되는지 알아야 한다는 아이디어는 전체 순서 브로드캐스트의 주제로 다루겠다.

## 전체 순서 브로드캐스트

단일 코어라면 순서 정하기가 쉽다. 어려운 문제는 “단일 처리량을 넘어설 때 어떻게 확장할 것인가?”와 “리더에 장애가 발생했을 때 어떻게 장애 복구를 할 것인가?”다. 분산 시스템에서는 이 문제를 전체 순서 브로드캐스트(total order broadcast)와 원자적 브로드캐스트(atomic broadcast)로 알려져 있다.

전체 순서 브로드캐스트는 보통 노드 사이의 메세지 교환 프로토콜로 기술된다. 비공식적으로 다음 2가지 속성을 항상 만족해야 한다.

1. 신뢰성 있는 전달(reliable delivery): 어떤 메세지도 손실되지 않는다.
2. 전체 순서가 정해진 전달(totally ordered delivery): 메시지는 모든 노드에 같은 순서로 전달된다.

### 전체 순서 브로드캐스트 사용하기

주키퍼나 etcd  같은 합의 서비스는 전체 순서 브로드캐스트를 실제로 구현한다. 전체 순서 브로드캐스트는 데이터베이스 복제에 딱 필요하다. 메세지는 쓰기 작업을 의미하고 모든 복제 서버가 동일한 순서로 작업을 한다면 항상 일관된 상태를 유지할 것이다. 이 원리는 **상태 기계 복제(state machine replication)**이라고 한다.

전체 순서 브로드 캐스트의 중요한 측면은 메세지가 전달되는 시점에 순서가 정해진다는 것이다. 또 다른 관점은 로그를 만드는 방법 중 하나라는 것이다. 전체 순서 브로드캐스트는 펜싱 토큰을 제공하는 잠금 서비스를 만들 때도 유효다. 잠금을 획득하는 모든 요청은 메세지로 로그가 추가되고 일련 번호가 붙는다. 일련 번호는 단조증가하므로 펜싱 토큰 역할을 수행할 수 있다. 주키퍼에서는 이 일련번호를 zxid라고 한다.

### 전체 순서 브로드캐스트 사용해 선형성 저장소 구현하기

전체 순서 브로드캐스트는 비동기식이다. 메세지를 고정된 순서로 신뢰성 있게 보내지만 언제 메세지가 전달될 지는 보장하지 않는다. compare-and-set을 통해서 선형적 쓰기를 구현할 수 있지만 읽기는 보장할 수 없다.

### 선형성 저장소를 사용해 전체 순서 브로드캐스트 구현하기

메세지를 보낼때 마다 increment-and-set 연산을 통해 연속된 일련 번호를 생성하여 보낸다. 응답을 처리할 때도 연속된 일련 번호를 받지 못했다면 기다려서 받고 처리하도록 한다. 램포트 타임스탬프 순서화와의 핵심적인 차이이다.
