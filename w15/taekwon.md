# 09장. 일관성과 합의

## Overview

분산 시스템에서는 많은 것들이 잘못될 수 있다. 이런 결함을 다루는 가장 간단한 방법은 전체 서비스가 실패하도록 두고 사용자에게 오류 메세지를 보여주거나, 결함을 견뎌낼 방법을 찾아야 한다.

분산시스템도 트랜잭션 추상화와 같이(원자성, 지속성, 격리성 등) 분산 시스템에 있는 문제를 무시할 수 있게 만들어주는 추상화를 찾아야 한다.

예를 들어 분산 시스템에 가장 중요한 추상화 중 하나는 합의로 모든 노드가 어떤 것에 동의하게 만드는 것이다.

합의가 있다면 리더가 죽어서 다른 노드로 복구해야 하는 상황에 남은 데이터베이스 노드들이 합의를 사용해 새 리더를 뽀을 수 있다. 올바르게 구현된 합의는 `스플릿 브레인` 과같은 문제를 피하는 데 도움이 된다.

## ## 일관성 보장

복제 데이터베이스는 대부분 최소한 `최종적 일관성` 을 제공한다. 그러나 이것은 매우 약한 보장이며, 그에 대한 버그는 종종 미묘하며 테스트로 발견하기 어렵다. 시스템에 결함이 있거나 동시성이 높을 때만 분명히 드러난다.

강한 보장을 제공하는 시스템은 성능이 나쁘거나 약한 보장을 제공하는 시스템보다 내결함성이 약할지도 모른다. 그럼에도 올바르게 사용하기 쉬우므로 매력적이다.

## 선형성

선형성은 모든 클라이언트가 똑같은 데이터를 보고 복제 지연을 걱정할 필요가 없음에 아이디어가 있다. 이를 `원자적 일관성` `강한 일관성` `즉각 일관성` `외부 일관성` 이라고도 한다.

선형성 시스템에서는 클라이언트가 쓰기를 완료하자마자 그 데이터베이스를 읽는 모든 클라이언트가 방금 쓰여진 값을 볼 수 있어야 한다. 다시 말해 선형성은 `최신성 보장` 이다.

![image](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/71249347/6386eeed-cbd7-4d80-9957-da9561a4f42c)

위의 그림은 비선형 시스템이며, 앨리스와 밥 모두 경기 결과를 조회하지만 밥의 경우 지연된 데이터베이스 복제본으로 요청이 전달되어 경기중인인 것으로 보인다.

### 시스템에 선형성을 부여하는 것은 무엇인가

![image](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/71249347/811a3242-fbb9-4ee0-af28-eb87f4b2f8ae)

선형성 데이터베이스에서 동시에 같은 키 X를 읽고 쓰는 세 클라이언트를 보여준다. 위의 예제에서 레지스터(x)는 두 가지 종류의 연산이 있다.

- read(x) → v  클라이언트가 레지스터 X의 값을 익기를 요청했고 데이터베이스가 v를 반환함.
- write(x, v) → r 클라이언트가 x의 값을 v로 설정하라고 요청했고 데이터베이스가 응답r함.

위의 그림에서 클라이언튼 A와 B는 최신 값을 읽기 위해 반복적으로 데이터베이스를 폴링한다.

- A가 실행한 첫번째 읽기는 쓰기 시작전에 완료되므로 0을 반환하는게 명백하다.
- A가 실행한 마지막 읽기는 쓰기 완료후 시작하므로 명백히 1을 반환해야 한다.
- 쓰기 연산과 시간이 겹치는 읽기 연산은 0을 반환했을 수도 1을 반환했을 수도 있다. 이 연산들은 쓰기와 동시에 실행 된다.

위의 그림을 선형적으로 만드려면 다른 제약 조건이 추가되어야 한다.

![image](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/71249347/8d9878f7-3e9a-4469-86a0-a234621578d6)

A의 읽기가 반환된 후 B가 새로운 읽기를 시작하면 B의 읽기는 확실히 A의 읽기 뒤에 실행되므로 C의 쓰기연산이 진행 중이라도 역시 1을 반환해야 한다.

![image](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/71249347/bba57804-0f88-4c24-b90a-7ca50eb1b115)

- cas(x, old, new)  → r 은 compare-and-set으로 레지스터 x의 현재 값이 old와 같으면 원자적으로 new로 설정돼야 한다. x ≠ old 라면 이 연산은 레지스터를 그대로 두고 오류를 반환해야 한다.

선형성의 요구사항은 연산 표시를 모은 선들이 항상 시간순으로 진행돼야 하고 이 요구사항은 최신성 보장이 되도록 만들어 준다.  모든 요청과 응답 시점을 기록하고 그것들이 유효한 순차 순서로 배열되는지 확인함으로써 시스템의 동작이 선형적인지 테스트할 수 있다.

- **직렬성**
    - 모든 트랜잭션이 여러 객체를 읽고 쓸 수 있는 상황에서의 **트랜잭션들**의 격리 속성
    - 트랜잭션들이 **어떤** 순서에 따라 실행되는 것처럼 동작하도록 보장한다.
- **선형성**
    - 레지스터(**개별 객체**)에 실행되는 읽기와 쓰기에 대한 최신성 보장이다.
    - 연산을 트랜잭션으로 묶지 않아서 충돌 구체화 같은 부가적인 수단을 사용하지 않으면 쓰기 스큐 같은 문제를 막지 못한다.

데이터베이스는 직렬성과 선형성을 모두 제공할 수 있으므로 이러한 조합은 **엄격한 직렬성(strict serializability)** 혹은 **강한 단일 복사 직렬성(strong one-copy serializability)** 라고 한다.

그러나 직렬성 스냅숏 격리는 선형적이지 않다. 설계상 직렬성 스냅숏 격리는 읽는 쪽과 쓰는 쪽 사이의 잠금 경쟁을 피하기 위해 일관된 스냅숏에서 읽는다. 일관된 스냅숏의 요점은 스냅숏에 스냅숏보다 나중에 실행된 쓰기를 포함하지 않는다는 것이고 따라서 스냅숏 읽기는 선형적이지 않다.

### 잠금과 리더 선출

단일 리더 복제를 사용하는 시스템은 리더가 여러개가 아니라 진짜로 하나만 존재 하도록 보장해야 한다.

리더를 선출하는 한 가지 방법은 잠금을 사용하는 것으로 모든 노드가 시작할 때 잠금 획들을 시도하고 성공한 노드가 리더가 된다.

분산 잠금과 리더 선출을 구현하기 위해 아파치 주키퍼나 etcd 같은 코디네이션 서비스가 종종 사용된다. 이들은 합의 알고리즘을 사용해 선형성 연산을 내결함성이 있는 방식으로 구현한다.

분산 잠금은 오라클 리얼 애플리케이션 클러스터 같은 분산 데이터베이스에서 훨씬 세분화된 수준으로 사용하기도 한다.

### 제약 조건과 유일성 보장

데이터가 기록될 때 유일성 제약 조건을 강제하고 싶다면 선형성이 필요하다.

이 상황은 실제로 잠금과 비슷하며, 사용자가 서비스에 가입할 때 그들이 선택한 사용자명에 `잠금` 을 획득하는 것으로 생각할 수 있다. 그 연산은 원자적 compare-and-set과도 매우 비슷하다. 사용자명이 이미 점유되지 않았다면 요구한 사용자의 ID에 해당 사용자명을 설정한다.

실제 애플리케이션에서는 이런 제약 조건을 느슨하게 다뤄도 된다. 이런 경우에는 선형성이 필요 없을 수 도 있지만, 관계형 데이터베이스에서 전형적으로 볼 수 있는 엄격한 유일성 제약 조건은 선형성이 필요하다.

### 채널간 타이밍 의존성

서로 다른 채널이 존재할 경우 선형성이 보장되지 않으면 두 채널 사이에 경쟁 조건의 위험이 언제 나 있다.

선형성이 경쟁 조건을 회피하는 유일한 방법은 아니지만 이해하기에 가장 단순하다. 부가적인 통신 채널을 제어한다면 복잡성이 추가되는 대신 대안적인 방법을 사용할 수 도 있다.

### 선형성 시스템 구현하기

선형성의 가장 간단한 해답은 정말로 데이터 복사본 하나만 사용하는 것이다. 그러나 이 방법으로는 결함을 견딜 수 없다. 하나의 복사본을 저장한 노드에 장애가 날경우 데이터는 손실이 되거나 노드가 다시 살아날 때까지 접근할 수 없다.

시스템이 내결함성을 지니도록 만드는 가장 흔한 방법은 복제를 사용하는 것이다.

- **단일 리더 복제(선형적이 될 가능성이 있음)**
  읽기에 리더를 사용하기 위해서는 누가 리더인지를 정확하게 안다고 가정해야 한다.
- **합의 알고리즘(선형적)**
  단일 리더 복제를 닮았으나, 주키퍼등의 코디네이트를 통해 스플릿 브레인과 복제본이 뒤처지는 문제를 막을 수단이 포함된다.
- **다중 리더 복제(비선형적)**
  다중 리더 복제를 하는 시스템들은 일반적으로 선형적이지 않다. 이들은 여러 노드에서 동시에 쓰기를 처리하고 그렇게 쓰여진 내용을 비동기로 다른 노드에 복제하기 때문이다.
- **리더 없는 복제(아마도 선형적)**
  정족수 읽기와 쓰기를 요구함으로써 엄격한 일관성을 달성할 수 있다고 주장하지만 정족수의 정확한 설정에 따라, 그리고 엄격한 일관성을 어떻게 정의하느냐에 따라 완전한 진실은 아니다.

### 선형성과 정족수

![image](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/71249347/855133f9-228c-44e4-88cb-bf3646fc1c84)

위 그림처럼 정족수 조건이 만족(w + r > n) 됨에도 이 실행은 선형직이지 않다. 네트워크 지연의 변동이 심하면 경쟁 조건이 생길 수 있다.

성능이 떨어지는비용을 지불하고 다이나모 스타일 정족수를 선형적으로 만드는 게 가능하지만 이 경우 선형성 읽기와 쓰기 연산만 가능하다.

따라서 다이나모 스타일 복제를 하는 리더 없는 시스템은 선형성을 제공하지 않는다고 보는 게 가장 안전하다.

### 선형성의 비용

![image](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/71249347/812f6359-019a-42bf-b1d7-36e93bf8a4cd)

두 데이터센터 사이에 네트워크가 끊긴다면 다중 리더 데이터베이스는 사용이 가능하지만 단일 리더 복제의 경우 리더가 데이터센터 중 하나에 있어야만 돌아간다.

애플리케이션에서 선형성 읽기와 쓰기를 요구한다면 네트워크가 끊길 때 리더와 연결할 수 없는 데이터센터에서는 그 애플리케이션을 사용할 수 없다.

### CAP 정리

이 문제는 단일, 다중 리더 복제의 결과만은 아니며 어떤 선형성 데이터베이스라도 구현이 어떻게 됐는지에 상관없이 이 문제가 있다.

이 문제는 다중 데이터센터에 배치에 특정된 것도 아니며 신뢰성이 없는 어떤 네트워크에서도, 심지어 한 데이터센터 내에서도 발생할 수 있다. 트레이드오프는 다음과 같다.

- 애플리케이션에서 선형성을 `요구하고` 네트워크 문제 때문에 일부 복제 서버가 다른 복제 서버와 연결이 끊기면 일부 복제 서버는 연결이 끊긴 동안은 요청을 처리할 수 없다.(**가용성이 없다.**)
- 애플리케이션에서 선형성을 **요구하지 않는다면** 각 복제 서버가 다른 복제 서버와 연결이 끊기더라도 독립적으로 요청을 처리하는 방식으로 쓰기를 처리할 수 있다.(**가용한 상태를 유지하지만 그 동작은 선형적이지 않다**.)

CAP는 때때로 `일관성` `가용성` `분단내성` 세 개 중 두개를 고르라는 것으로 표현되지만 이는 오해의 소지가 있다.

네트워크 분단은 일종의 결함을 ㅗ선택의 여지가 없기 때문이며, 좋든 싫든 발생하기 때문이다.

따라서 **CAP는 네트워크 분단이 생겼을 때 일관성과 가용성 중 하나를 선택하라는 의미**로 보는 게 좋다

공식적으로 정의된 CAP 정리는 매우 범위가 좁다. 오직 하나의 일관성 모델(즉 선형성)과 한종류의 결함(네트워크 분단 혹은 서로 연결이 끊긴 상황)만 고려한다.

그러므로 CAP가 역사적인 영향력은 있지만 시스템을 설계할 때는 실용적인 가치가 거의 없다.

### 선형성과 네트워크 지연

선현성 보장을 제공하지 않기를 택한 여러 분산 데이터베이스 들은 내결함성 때문이 아니라 주로 성능을 향상시키기 위해 그렇게 한다.

선형성은 느리다. 그리고 이것은 네트워크 결함이 있을 때만 그런 게 아니라 항상 참이다.

선형성을 제공하는 더욱 빠른 알고리즘은 존재하지 않지만 완화된 일관성 모델은 훨씬 더 빠를 수 있다. 따라서 지연 시간에 민감한 시스템에서는 이 트레이드오프가 중요하다.

### 순서화 보장

선형성 레지스터는 데이터 복사본이 하나만 있는 것처럼 동작하고 모든 연산이 어느 시점에 원자적으로 효과가 나타나는 것처럼 보인다. 이 정의는 여산들이 어떤 잘 정의된 순서대로 실행된다는 것을 암시한다. 순서화, 선형성, 합의 사이에는 깊은 연결 관계가 있다.

### 순서화와 인과성

순서화는 인과성을 보존하는데 도움을 준다. 인과성은 이벤트에 순서를 부과한다. 결과가 나타나기 전에 원인이 발생한다. 메시지를 받기 전에 메시지를 보낸다. 처럼 인과적으로 의존하는 연산의 이런 연쇄는 시스템에서 인과적 순서, 즉 무엇이 무엇보다 먼저 일어났는가를 정의한다.

예를 들어 스냅숏 격리는 인과적 일관성을 제공한다. 데이터베이스에서 읽어서 데이터의 어떤 조각을 봤다면 그보다 인과적으로 먼저 발생한 어떤 데이터도 볼 수 있어야 한다.

### 인과적 순서가 전체 순서는 아니다

- 선형적
  선형성 시스템에서는 여산의 **전체 순서**를 정의할 수 있다. 모든 연산이 원자적이면 어떤 두 연산에 대해 항상 둘 중 하나가 먼저 실행됐다고 말할 수 있다는 뜻이다.
- 인과성
  두 연산 중 어떤 것도 다른 것보다 먼저 실행되지 않았다면 두 연산이 동시적이라고 말한다.(인과적인 관계에 있으면 이들은 순서가 있지만 이들이 동시에 실행되면 비교할 수 없다.) 인과성이 전체 순서가 아닌 **부분 순서**를 정의 한다는 뜻이다.

그러므로 정의에 따르면 선형성 데이터스토어에는 동시적 연산이 없다. 하나의 타임라인이 있고 모든 연산은 그타임라인을 따라서 전체 순서가 정해져야 한다.

반면 깃 같은 분산 버전 관리 시스템의 경우 버전 히스토리는 인과적 의존성 그래프와 유사하다.

### 선형성은 인과적 일관성보다 강하다.

선형성은 인관성을 내포한다. 선형성이 인과성을 보장해준다는 사실은 이해하기도 쉽고 매력적으로 보일 수 도 있지만 이는 네트워크 지연에 따라 성능과 가용성에 해가 될 수 있다.

다만 절충선으로 선형적으로 만들지 않고도 인과적 일관성을 만족시킬 수 있으며, 많은 경우에 대부분의 시스템에서 실제로 필요한 것은 선형성이 아닌 인과성이다.

### 인과적 의존성 담기

인과성을 유지하기 위해 어떤 연산이 다른 연산보다 먼저 실행됐는지 알아야 한다. 이것은 부분 순서다. 동시에 실행되는 연산은 어떤 순서로든 처리될 수 있지만 한 연산이 다른 연산보다 먼저 실행됐다면 모든 복제 서버에 그 순서ㄹ 처리돼야 한다.

인과적 의존성은 다른 연산보다 먼저 실행됐는지 결정하기 위해 단일 키뿐만 아니라 전체 데이터베이스에 걸친 인과적 의존성을 추적해야 한다. 이를 위해 버전 벡터를 일반화할 수 있다.

인과적 순서를 결정하기 위해 데이터베이스는 애플리케이션이 데이터의 어떤 버전을 읽었는지 알아야 하며, 이전 연산의 버전 번호를 데이터베이스로 되돌려주는 것은 이 때문이다.

### 일련번호 순서화

모든 인과적 의존성을 실제로 추적하는 것은 실횽성이 떨어진다. 이를 위해 **일련번호** 나 **타임스탬프**를 써서 이벤트의 순서를 정할 수 있다.  타임스탬프는 논리적 시계에서 얻어도 된다.

이런 일련번호나 타임스탬프는 크기가 작고 전체 순서를 제공한다. 즉 모든 연산은 고유 일련번호를 갖고 항상 두 개의 일련번호를 비교해서 어떤 것이 큰지 결정할 수 있다.

### 비인과적 일련번호 생성기

단일 리더가 없다면 연산에 사용할 일련번호를 생성하는 방법이 명확해 보이지 않는다. 현실에서는 다양한 방법이 사용된다.

- 각 노드가 자신만의 독립적인 일련번호 집합을 생성할 수 있다.(하나는 홀수, 하나는 짝수)
- 각 연산에 일 기준시계(물리적 시계)에서 얻은 타임스탬프를 붙일 수 있다. 해상도가 충분히 높다면 연산 전체 순서를 정하는 데 충분할 수 도 있다.
- 일련번호 블록을 비리 할당할 수 있다. 이를 테면 노드 A는 일련번호 1부터 1,000 까지, B는 1,001부터 2,000까지의 블록을 차지할 수 있다.

그러나 위 방법엔 문제가 하나 있는데 생성한 일련번호가 **인과성에 일관적이지 않다**.

- 각 노드는 초당연산수가 다를 수 있으며, 이는 한 노드가 뒤쳐지거나 반대의 상황이 생길 수 있다.(홀수와 짝수 연산 중 어느 것이 인과적으로 먼저 실행됐는지 알 수 없다.)
- 물리적 시계에서 얻은 타임스탬프는 시계 스큐에 종속적이어서 인과성에 일관적이지 않을 수 있다.
- 블록 할당자의 경우 뒤의 연산이 1과 1,000 사이를 할당 받는 경우가 생길 수 있다.

### 램포트 타임스탬프

인과성에 일관적인 일련번호를 생성하는 간단한 방법이 있으며 이를 **램포트 타임스탬프** 라고 부른다. 이는 현재 분산 시스템 분야에서 가장 많이 인용된 논문 중 하나다.

램포트 타임스탬프는 그냥 (카운터, 노드ID)의 쌍이다. 두 노드는 때때로 카운터 값이 같을 수 있지만 타임스탬프에 노드 ID를 포함시켜서 각 타임스탬프는 유일하게 된다.

![image](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/71249347/c03cf7ed-be04-4f62-984c-14fd8349a821)

램포트 타임스탬프는 물리적 일 기준 시계와 아무 관련이 없으나 전체 순서화를 제공한다.

핵심 아이디어는 모든 노드와 클라이언트가 본 카운터 값 중 **최대값**을 추적하고 모든 요청에 그 최대값을 포함한다.

램포트 타임스탬프는 때때로 버전 벡터와 혼동되지만 목직이 다르다. 버전 벡터는 두 연산이 동시적인지 또는 어떤 연산이 다른 연산에 인과적으로 의존하는지 구별할 수 있지만, 램포트 타임스탬프는 항상 전체 순서화를 강제한다.

### 타임스탬프 순서화로는 충분하지 않다.

램포트 타임스탬프가 인과성에 일관적인 연산의 전체 순서를 정의하지만 분산 시스템의 공통 문제를 해결하는 데 아주 충분하지는 않다.

사후에 성공하는 쪽을 결정하는 데는 효과적이지만, 사용자로부터 요청이 성공해야 하는지 실패해야 하는지 당장 결정할 때는 부족하다.

결론적으로 사용자명에 대한 유일성 제약 조건 같은 것을 구현하려면 연산의 전체 순서가 있는 것으로는 충분하지 않고 이를 위해 **전체 순서 브로드캐스트**가 등장함.

### 전체 순서 브로드캐스트

어려운 문제는 처리량이 단일 리더가 처리할 수 있는 수준을 넘어설 때 시스템을 어떻게 확장할 것인가와 리더에 장애가 발생했을 때 어떻게 장애 복구를 처리할 것인가다. 분산 시스템 분야에서 이 문제는 전체 순서 브로드캐스트나 원자적 브로드캐스트로 알려져 있다.

전체 순서 브로드캐스트는 보통 노드 사이에 메시지를 교환하는 프로토콜로 기술되며, 비공식적으로는 두 가지 안전성 속성을 만족해야 한다.

- **신뢰성 있는 전달** : 어떤 메시지도 손실되지 않는다. 한노드에 전달되면 모든 노드에도 전달된다.
- **전체 순서가 정해진 전달** : 메시지는 모든 노드에 같은 순서로 전달된다.

전체 순서 브로드캐스트를 구현하는 올바른 알고리즘은 노드나 네트워크에 결함이 있더라도 신뢰성과 순서화 속성이 항상 만족되도록 보장해야 한다.

### 전체 순서 브로드캐스트 사용하기

전체 순서 브로드캐스트는 데이터베이스 복제에 딱 필요한 것으로 모든 메시지가 데이터베이스에 쓰기를 나타내고 모든 복제 서버가 같은 쓰기 연산을 같은 순서로 처리하면 복제 서버들은 서로 일관성 있는 상태를 유지한다. 이 원리를 **상태 기계 복제** 라고 한다.

전체 순서 브로드캐스트를 보는 또 다른 관점은 로그를 만드는 방법 중 하나라는 것이다. 메시지 전달은 로그에 추가하는 것과 비슷하다. 모든 노드가 같은 메시지를 같은 순서로 전달해야 하므로 모든 노드는 로그를 읽어서 순서가 동일한 메시지를 볼 수 있다.

### 전체 순서 브로드캐스트를 사용해 선형성 저장소 구현하기

### 선현성 저장소를 사용해 전체 순서 브로드캐스트 구현하기