# Ch3 저장소와 검색 (데이터 베이스를 강력하게 만드는 데이터 구조)

- 데이터베이스가 데이터를 저장하는 방법과 데이터를 요청했을 때 다시 찾을 수 있는 방법
- 사용 가능한 여러 저장소 엔진 중에 애플리케이션에 적합한 엔진을 선택하는 작업이 필요
- RDB VS NoSQL 설명
- 로그 구조(log-structured) 계졀 저장소 엔진 vs 페이지 지향(page-oriented) 계열 저장소 엔진 검토

# 데이터베이스를 강력하게 만드는 데이터 구조

기본적인 저장소 형식

- 매 라인마다 쉼표로 구분된 키-값 쌍을 포함한 텍스트 파일(CSV 파일과 유사)
- 파일의 끝에 추가하므로 키를 여러번 갱신해도 예전 버전을 덮어쓰지 않음.
- 최신값을 찾기 위해서는 파일에서 키의 마지막 항목을 찾는다.

많은 데이터베이스는 내부적으로 추가 전용(append-only) 데이터 파일인 로그(log)를 사용한다. 로그는 믿기지 않을 정도로 유용하다. 실제 데이터 베이스는 로그에서 다양한 문제(동시성, 디스크 공간 회수, 오류 처리, 부분적으로 기록된 레코드 처리)등을 해결한다.

- 매번 키를 찾을 때마다 db_get은 키가 있는지 찾기 위해 전체 데이터베이스 파일을 처음부터 끝까지 스캔해야 한다. O(n)
- 특정 키의 값을 효율적으로 찾기 위해서는 다른 데이터 구조가 필요하다. 그것이 바로 색인(index)이다.

색인의 일반적인 개념은 어떤 부가적인 메타데이터를 유지하는 것이다. 이 메타데이터는 이정표 역할을 해서 원하는 데이터의 위치를 찾는데 도움이 된다. 동일한 데이터를 여러가지 다양한 방법으로 검색하고 자한다면 데이터의 각 부분에 여러가지 다양한 색인이 필요하다.

어떤 종류의 색인이라도 대개 쓰기 속도를 느리게 만든다. 데이터를 쓸 때마다 색인도 갱신해야 하기 때문이다. 색인을 잘 선택했다면 읽기 질의 속도가 향상된다. 하지만 모든 색인은 쓰기 속도를 떨어트린다. 따라서 개발자는 전형적인 질의 패턴에 대한 지식을 활용해 수동으로 색인을 선택해야 한다.

# 해시 색인

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/04b60e39-3cff-473d-a757-de5d7b6c77eb)

- 키-값 데이터는 사전 타입(dictionary type)과 유사하다. 보통 해시 맵(hash map), 해시 테이블(hash table)로 구현한다.
- 가장 간단한 색인 전략은 키를 데이터 파일의 바이트 오프셋에 매핑해 인메모리 해시 맵을 유지하는 전략이다.
- 바이트 오프셋은 로그의 각 바이트의 길이에 따른 위치를 가지고 있어서 키를 통해 그 위치로 즉시 이동하는 방법이다.
- 만약 데이터 파일의 일부가 이미 파일 시스템 캐시에 있다면 읽기에 디스크 입출력이 필요하지 않다.
- 추가만 된다면 결국 디스크 공간이 부족해진다.
    - 특정 크기의 세그먼트(segment)로 로그를 나누는 방식을 사용할 수 있다.
    - 세그먼트 파일들에 대해 컴팩션(compaction)을 수행할 수 있다. 컴팩션은 로그에서 중복된 키를 버리고 각 키의 최신 갱신 값만 유지하는 것을 의미한다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/0d168352-c343-4f9d-ab70-41a10c805dfb)

- 컴팩션은 세그먼트를 더 작게 만들기 때문에 동시에 여러 세그먼트들을 병합할 수 있다.
- 세그먼트가 쓰여진 후에는 절대 변경할 수 없기 때문에 병합할 세그먼트는 새로운 파일로 만든다.
- 컴팩션을 수행하는 동안 이전 세그먼트 파일을 사용해 읽기와 쓰기 요청의 처리를 정상적으로 계속 수행한다. 전환 후에는 이전 세그먼트 파일을 간단히 삭제하면 된다.

**구현시 고려사항**

1. 파일형식
    - CSV는 로그에 적합한 형식이 아니다.
    - 바이트 단위의 문자열 길이를 부호화한다음 원시 문자열을 부호화하는 바이너리 형식을 사용하는 편이 빠르고 간단한다.
2. 레코드 삭제
    - 키와 관련된 값을 삭제하려면 데이터 파일에 특수한 삭제 레코드를 추가해야한다.
    - 로그 세그먼트가 병합될 때 톰스톤은 병합 과정에서 삭제된 키의 이전 값을 무시하게 한다.
3. 고장(Crash) 복구
    - 데이터베이스가 재시작되면 인메모리 해시 맵은 손실된다. 원칙적으로 전체 세그먼트 파일을 처음부터 끝가지 읽고 각 키에 대한 최신 값의 오프셋을 확인해서 각 세그먼트 해시 맵을 복원할 수 있다.
    - 하지만 세그먼트 파일이 크면 해시 맵 복원은 오랜 시간이 걸릴 수 있다. 비트캐스크는 각 세그먼트 해시 맵을 메모리로 조금 더 빠르게 로딩할 수 있게 스냅숏을 디스크에 저장해 복구 속도를 높인다.
4. 부분적으로 레코드 쓰기
    - 데이터베이스는 로그에 레코드를 추가하는 도중에 죽을 수 있다. 비트캐스크 파일은 체크섬을 포함하고 있어 로그의 손상된 부분을 탐지해 무시할 수 있다.
5. 동시성 제어
    - 쓰기를 엄격하게 순차적으로 로그에 추가할 때 일반적인 구현 방법은 하나의 쓰기 스레드만 사용한다.
    - 데이터 파일 세그먼트는 추가 전용이거나 불변(immutable)이므로 다중 스레드로 동시에 읽기를 할 수 있다.

추가 전용 설계는 여러 측면에서 좋은 설계다.

- 추가와 세그먼트 병합은 순차적인 쓰기 작업이기 때문에 보통 무작위 쓰기보다 훨씬 빠르다.
- 세그먼트 파일이 추가전용이거나 불변이면 동시성과 고장 복구가 간단하다.
- 오래된 세그먼트 병합은 시간이 지남에 따라 조각화되는 데이터 파일 문제를 피할 수 있다.

해시 테이블 색인 또한 제한 사항이 있다.

- 해시 테이블은 메모리에 저장해야 하므로 키가 너무 많으면 문제가 된다. 원칙적으로 디스크에 해시 맵을 유지할 수 있지만 성능이 좋지 않다. 이는 무작위 접근 I/O가 많이 필요하고 디스크가 가득  찼을 때 확장하는 비용이 비싸며 해시 충돌 해소를 위해 성가신 로직이 필요하다.
- 해시 테이블은 범위 질의(range query)에 효율적이지 않다.

# SS테이블과 LSM 트리

- 로그 구조화 저장소 세그먼트는 키-값 쌍의 연속이다.
- 세그먼트 파일의 형식에 간단한 변경사항 한가지는 일련의 키-값 쌍을 키로 정렬하는 것이다.
- 키로 정렬된 형식을 정렬된 문자열 테이블(Sorted String Table) 또는 짧게 SS 테이블이라고 한다. 각 병함된 세그먼트 파일 내에 한 번만 나타나야 한다.
- SS 테이블은 해시 색인을 가진 로그 세그먼트보다 몇 가지 큰 장점이 있다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/a4b8dc71-a3e0-4fca-87c0-e96f124d923a)

1. 세그먼트 병합은 파일이 사용 가능한 메모리보다 크더라도 간단하고 효율적이다. 이 접근법은 병합정렬(mergesort) 알고리즘에서 사용하는 방식과 유사하다. 입력파일을 함께 읽고 각 파일의 첫 번째  키를 본다. 그리고 가장 낮은 키를 출력 파일로 복사한뒤 이 과정을 반복한다. 새로 병합 세그먼트 파일은 키로 정렬되어있다.
2. 파일에서 특정 키를 찾기 위해 더는 메모리에 모든 키의 색인을 유지할 필요가 없다. handbag 오프셋으로 이동해 handiwork가 나올 때까지 스캔하면 된다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/82cc933c-ca58-4fc1-9240-e0239ff39db9)

3. 읽기 요청은 요청 범위 내에서 여러 키-값 쌍을 스캔해야 하기 때문에 해당 레코드들을 블록으로 그룹화하고 디스크에 쓰기 전에 압축한다. 그러면 희소 인메모리 색인의 각 항목은 압축된 블록의 시작을 가리키게 된다. 디스크 공간을 절약한다는 점 외에도 압축은 I/O 대역폭 사용도 줄인다.

## SS테이블 생성과 유지

- 디스크 상에 정렬된 구조를 유지하는 일은 가능하지만 메모리에 유지하는 편이 쉽다.
- 레드 블랙 트리(red-black tree)나 AVL 트리와 같이 잘 알려졌고 사용 가능한 트리 데이터 구조는 많이 있다.

저장소 엔진 만드는 방법

- 쓰기가 들어오면 인메모리 균형 트리(balanced tree) 데이터 구조에 추가한다. 이 인메모리 트리는 멤테이블(memtable)이라고 한다.
- 멤테이블이 보통 수 메가바이트 정도의 입곗값보다 커지면 SS테이블 파일로 디스크에 기록한다. 트리가 이미 키로 정렬된 키-값 쌍을 유지하고 있기 때문에 효율적으로 수행할 수 있다.
- 읽기 요청을 제공하려면 멤테이블에서 키를 찾아야 한다. 그 다음 디스크 상의 가장 최신 세그먼트에서 찾는다. 그 다음은 두 번째, 세 번째 오래된 세그먼트 등에서 찾는다.
- 세그먼트 파일을 합치고 덮어 쓰여지거나 삭제된 값을 버리는 병합과 컴팩션 과정을 수행한다. 이 과정은 백그라운드에서 수행된다.
- 세그먼트 파일을 합치고 덮어 쓰여지거나 삭제된 값을 버리는 병합과 컴팩션 과정을 수행한다. 이 과정은 백그라운드에서 수행된다.

다만 데이터베이스가 고장나면 아직 디스크로 기록되지 않고 멤테이블에 있는 가장 최신 쓰기가 손실된다. 이 문제를 피하기 위해서는 매번 쓰기를 즉시 추가할 수 있게 분리된 로그를 디스크 상에 유지해야 한다. 이 로그는 손상 후 멤테이블을 복원할 때만 필요하기 때문에 순서가 정렬되지 않아도 문제되지 않는다. 멤테이블을 SS테이블로 기록하고 나면 해당 로그는 버릴 수 있다.

## SS테이블에서 LSM 트리 만들기

기본적으로 레벨 DB(LevelDB)와 록스DB(RocskDB) 애플리케이션에 내장하기 위해 설계된 키-값 저장소 엔진 라이브러리에서 사용한다. 리악에서는 비트캐스크 대안으로 레벨 DB를 사용할 수 있고 구글의 빅테이블(Bigtable) 논문(SS테이블과 멤테이블이라는 용어가 소개)에서 영감을 얻은 카산드라와 HBase에서도 유사한 저장소 엔진을 사용한다.

- 이 색인 구조는 로그 구조화 병합 트리(Log-Structured Merge-Tree)(또는 LSM 트리)란 이름으로 패트릭 오닐(Partick O’Neil) 등이 발표했다.
- 로그 구조화 파일 시스템의 초기 작업의 기반이 됐다. 정렬된 파일 병합과 컴팩션 원이를 기반으로 하는 저장소 엔진을 LSM 저장소 엔진이라 부른다.
- 루씬(Lucene)은 엘라스틱 서치나 솔라에서 사용하는 전문 검색 색인 엔진이다. 루씬은 용어 사전(term dictionary)을 저장하기 위해 유사한 방법을 사용한다. 검색 질의로 단어가 들어오면 단어가 언급된 모든 문서(웹 페이지, 제품 설명)를 찾는다.
- 이 접근법은 키를 단어(용어)로 값은 단어를 포함한 모든 문서의 ID 목록(포스팅 목록(Postings list))으로 하는 키-값 구조로 구현한다. 루씬에서 용어와 포스팅 목록의 매핑은 SS 테이블 같은 정렬 파일에 유지하고 필요에 따라 백그라운드에서 병합한다.

## 성능 최적화

- 많은 세부 사항이 저장소 엔진을 잘 동작하게 만든다. LSM 트리 알고리즘은 데이터베이스에 존재하지 않는 키를 찾는 경우 느릴 수 있다.
    - 멤테이블을 확인한 다음 키가 존재하지 않는다는 사실을 확인하기 위해서는 가장 오래된 세그먼트까지 거슬러 올라가야하기 때문이다.
- 이러한 접근을 최적화하기 위해 저장소 엔진은 보통 블룸 필터(Bloom Filter)를 추가적으로 사용한다.
    - 블룸 필터는 집합 내용을 근사한(approximating) 메모리 효율적 데이터 구조이다.
    - 키가 데이터베이스에 존재하지 않음을 알려주므로 존재하지 않는 키를 위한 불필요한 디스크 읽기를 많이 절약할 수 있다.
- SS테이블을 압축하고 병합하는 순서와 시기를 결정하는 다양한 전략이 있다.
    - 크기 계층(size-tiered)
        - HBase, 카산드라
        - 상대적으로 좀 더 새롭고 작은 SS테이블을 오래된 큰 SS 테이블에 연이어 병합
    - 레벨 컴팩션(leveled compaction)
        - 레벨 DB, 록스 DB, 카산드라
        - 키 범위를 더 작은 SS테이블로 나누고 오래된 데이터는 개별 레벨로 이동하기 때문에 컴팩션을 점진적으로 진행해 디스크 공간을 덜 사용

LSM 트리의 기본 개념은 백그라운드에서 연쇄적으로 SS 테이블을 지속적으로 병합하는 것이다. 이 개념은 데이터셋이 가능한 메모리보다 더 크더라도 효과적이다. 데이터가 정렬된 순서로 저장돼 있다면 범위 질의를 효율적으로 실행할 수 있다. 이 접근법의 디스크 쓰기는 순차적이기 때문에 LSM 트리가 높은 쓰기 처리량을 보장할 수 있다.

## B트리

사실 가장 널리 사용되는 색인 구조는 B 트리(B-tree)로 구조가 로그 구조화 색인과는 상당히 다르다.

- 1970년대 등장
- 거의 대부분의 관게형 데이터베이스에서 표준 색인 구현으로 B 트리를 사용할 뿐 아니라 많은 비관계형 데이터베이스에서 사용한다.
- SS 테이블과 같이 키로 정렬된 키-값 쌍을 유지하기 때문에 키-값 검색과 범위 질의에 효율적이다. 하지만 설계 철학은 전혀 다르다.
- 4KB 크기의 고정 크기 블록이나 페이지로 나누고 한 번에 하나의 페이지에 읽기 또는 쓰기를 한다. 디스크가 고정 크기 블록으로 배열되기 때문에 이런 설계는 근본적으로 하드웨어와 조금 더 밀접한 관련이 있다.
- 각 페이지는 주소나 위치를 이용해 식별할 수 있다. 이 방식으로 하나의 페이지가 다른 페이지를 참조할 수 있다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/670fb903-41f3-414b-87ff-799535a6836d)

- 한 페이지는 B 트리의 루트(root)로 지정된다 페이지는 여러 키와 하위 페이지의 참조를 포함한다. 각 하위 페이지는 키가 게속 이어지는 범위를 담당하고 참조 사이의 키는 해당 범위 경계가 어디인지 나타낸다.
    - 251를 찾으려면 200과 300 경계사이의 페이지 참조를 따라 가야한다.
    - 최종적으로는 개별 키(리프 페이지(leaf page))를 포함하는 페이지에 도달한다. 이 페이지는 각 키의 값을 포함하거나 값을 찾을 수 있는 페이지의 참조를 포함한다.
- B 트리의 한 페이지에서 하위 페이지를 참조하는 수를 **분기 계수(branching factor)**라고 부른다.
- B 트리에 존재하는 키의 값을 갱신하려면 키를 포함하고 있는 리프 페이지를 검색하고 페이지의 값을 바꾼 다음 페이지를 디스크에 다시 기록한다. 새로운 키를 추가하려면 새로운 키를 포함하는 범위의 페이지를 찾아 해당 페이지에 키와 값을 추가한다. 새로운 키를 수용한 페이지에 여유 공간이 없으면 페이지 하나를 반쯤 채워진 페이지 둘로 나누고 상위 페이지가 새로운 키 범위의 하위 부분들을 알 수 있게 갱신한다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/03be33d4-6f2a-485a-9494-b7ab45e40639)

- 이 알고리즘은 트리가 계속 균형을 유지하는 것을 보장한다.
- n 개의 키를 가진 B 트리는 깊이가 항상 O(logn)이다. 대부분의 데이터베이스는 B 트리의 깊이가 3이나 4단계 정도면 충분하므로 검색하려는 페이지를 찾기 위해 많은 페이지 참조를 따라가지 않아도 된다.

### 신뢰할 수 있는 B 트리 만들기

- B 트리의 기본적인 쓰기 동작은 새로운 데이터를 디스크 상의 페이지에 덮어쓴다.
- 이 동작은 덮어쓰기가 페이지 위치를 변경하지 않는다고 가정한다. 즉 페이지를 덮어쓰더라도 페이지를 가리키는 모든 참조는 온전하게 남는다. LSM 트리와 같은 로그 구조화 색인과는 아주 대조적인 점이다. 로그 구조화 색인은 파일에 추가할 뿐 같은 위치의 파일은 변경하지 않는다.
    - 디스크의 페이지를 덮어쓰는 일은 실제 하드웨어 동작이다.
- 데이터베이스가 고장 상황에서 스스로 복구할 수 있게 만들려면 일반적으로 디스크 상에 쓰기 전 로그(write-ahead log, WAL)(재실행 로그(redo log)라고도 함)라고 하는 데이터 구조를 추가해 B 트리를 구현한다.
- 쓰기 전 로그는 트리 페이지에 변경된 내용을 적용하기 전에 모든 B 트리의 변경사항을 기록하는 추가 전용 파일이다. 이 로그는 데이터베이스가 고장 이후 복구될 때 일관성 있는 상태로 B 트리를 다시 복원하는 데 사용한다.
- 같은 자리의 페이지를 갱신하는 작업은 추가적인 골칫거리다. 다중 스레드가 동시에 B 트리에 접근한다면 주의 깊게 동시성 제어를 해야한다. 그렇지 않으면 스레드가 일관성이 깨진 상태의 트리에 접근할 수 있다. 동시성 제어는 보통 래치(latch)(가벼운 잠금(lock))로 트리의 데이터 구조를 보호한다.

### B 트리 최적화

최적화 기법

- 페이지 덮어쓰기와 고장복구를 위한 WAL 유지 대신 일부 데이터베이스는 쓰기시 복사 방식(copy-on-write scheme)를 사용한다. 변경된 페이지는 다른 위치에 기록하고 트리에 상위 페이지의 새로운 버전을 만들어 새로운 위치를 가리키게 한다.
- 페이지에 전체 키를 저장하는게 아니라 키를 축약해 쓰면 공간을 절약할 수 있다. 특히 트리 내부 페이지에서 키가 키 범위 사이의 경계 역할을 하는 데 충분한 정보만 제공하면 된다. 페이지 하나에 키를 더 많이 채우면 더 높은 분기 계수를 얻어 트리 깊이 수준을 낮출 수 있다.
    - 이 변형을 B+트리라고 한다. 이러한 최적화가 가장 일반적이다.
- 페이지는 디스크 어디에나 위치할 수 있다. 키 범위가 가까운 페이지들이 디스크 상에 가까이 있어야 할 필요가 없다. 질의가 정렬된 순서로 키 범위의 상당 부분을 스캔해야 한다면 모든 페이지에 대해 디스크 찾기를 필요하기 때문에 페이지 단위 배치는 비효율적이다. 따라서 많은 B 트리 구현에서 리프(leaf) 페이지를 디스크 상에 연속된 순서로 나타나게끔 트리를 배치하려 시도한다. 하지만 트리가 커지면 순서를 유지하기 어렵다. 반대로 LSM 트리는 병합하는 과정에서 저장소의 큰 세그먼트를 한 번에 다시 쓰기 때문에 디스크에서 연속된 키를 서로 가깝게 유지하기가 더 쉽다.
- 트리에 포인트를 추가한다. 각 리프페이지가 양쪽 형제 페이지에 대한 참조를 가지면 상위 페이지로 다시 이동하지 않아도 순서대로 키를 스캔할 수 있다.
- 프랙탈 트리(fractal tree) 같은 B 트리 변형은 디스크 찾기를 줄이기 위해 로그 구조화 개념을 일부 빌렸다.

## B 트리와 LSM 트리 비교

B 트리가 LSM 트리보다 일반적으로 구현 성숙도가 더 높지만 LSM 트리도 그 성능 특성 때문에 관심을 받고 있다. LSM 트리는 보통 쓰기에 더 빠르고 B 트리는 읽기에 더 빠르다. 읽기가 LSM 트리에서 느린 이유는 각 컴팩션 단계에 있는 여러가지 데이터 구조와 SS 테이블을 확인해야 하기 때문이다.

### LSM 트리의 장점

- B 트리 색인은 모든 데이터 조각을 최소한 두 번 기록해야 한다. 쓰기 전 로그 한 번과 트리 페이지에 한 번(페이지가 분리될 때 다시 기록)이다. 해당 페이지 내 몇 바이트만 바뀌어도 한 번에 전체 페이지를 기록해야 하는 오버헤드도 있다.
- 로그 구조화 색인 또한 SS 테이블의 반복된 컴팩션과 병합으로 인해 여러 번 데이터를 다시 쓴다. 데이터베이스에 쓰기 한 번이 여러 쓰기를 야기한다. 이런 효과를 쓰기 중폭(write amplification)이라 한다. SSD는 수명이 다할 때까지 블록 덮어쓰기 횟수가 제한되기 때문에 쓰기 중폭은 SSD의 경우 특별한 관심사이다.
    - 쓰기가 많은 애플리케이션의 성능 병목는 데이터베이스가 디스크에 쓰는 속도일 수 있다. 이 경우 쓰기 종폭이 성능 비용이다. 저장소 엔진이 디스크에 기록할 수록 디스크 대역폭 내 처리할 수 있는 초당 쓰기는 점점 줄어든다.
- LSM 트리는 보통 B 트리보다 쓰기 처리량을 높게 유지할 수 있다. LSM 트리는 상대적으로 쓰기 증폭이 더 낮고 트리에서 여러 페이지를 덮어쓰지 않고 순차적으로 컴팩션된 SS테이블 파일을 쓰기 때문이다. 이런 차이는 자기 하드드라이브에서 특히 중요하다.
- LSM는 압축률이 좋다. 그래서 B 트리보다 디스크에 더 적은 파일을 생성한다.
- SDD의 펌웨어는 내장 저장소 칩에서 임의 쓰기를 순차 쓰기로 전환하기 위해 내부적으로 로그 구조화 알고리즘을 사용한다. 그래서 저장소 엔진의 쓰기 패턴이 SSD에 미치는 영향을 분명하지 않다. 하지만 낮은 쓰기 증폭과 파편화 감소는 SSD의 경우 훨씬 유리하다.

### LSM 트리의 단점

- 컴팩션 과정은 때로는 진행중인 읽기와 쓰기의 성능에 영향을 준다.
    - 저장소 엔진은 컴팩션을 점진적으로 수행하고 동시 접근의 영향이 없게 수행하려 한다. 하지만 디스크가 가진 자원은 한계가 있다. 디스크에서 비싼 컴팩션 연산이 끝날 때까지 요청이 대기해야 하는 상황이 발생하기 쉽다. 처리량과 평균 응답 시간이 성능에 미치는 영향은 대개 작다. 하지만 로그 구조화 저장소 엔진의 상위 백분위 질의의 응답 시간은 때때로 꽤 길다. 반면 B 트리의 성능은 로그 구조화 저장소 엔진보다 예측하기 쉽다.
    - 다른 컴팩션 문제는 높은 쓰기처리량에서 발생한다.
    - 초기 쓰기(로깅)과 멤테빌을 디스크로 방출(flushing)하는 경웅 디스크 대역폭은 초기 쓰기만을 위해 사용할 수 있지만 데이터베이스가 점점 커질수록 컴팩션을 위해 더 많은 디스크 대역폭이 필요하다.
- B트리의 장점은 각 키가 색인의 한 곳에만 정확하게 존재한다는 점이다. 반면 LSM은 다른 세그먼트에 같은 키의 다중 복사본이 존재할 수 있다. 이런 측면 때문에 강력한 트랜잭션 시멘틱(semantic)를 제공하느 ㄴ데이터베이스에는 B 트리가 매력적이다. 관계형 데이터베이스에서 트랜잭션 격리(transactional isolation)는 키 범위의 잠금을 사용해 구현한 반면 B 트리 색인에서는 트리에 트리에 직접 잠금을 포함시킨다.
