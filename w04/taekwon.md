# 03장. 저장소와 검색

## 서론

가장 기본적인 수준에서 데이터베이스는 두 가지 작업을 수행한다.

- 데이터를 받으면 데이터를 저장한다.
- 저장된 데이터를 요청하면 다시 데이터를 제공한다.

대게 개발자는 사용 가능한 여러 저장소 엔진 중에 구현하려는 애플리케이션에 적합한 엔진을 선택하는 작업이 필요하다.

좋은 성능을 내게끔 저장소 엔진을 조정하려면 저장소 엔진이 내부에서 수행되는 작업에 대한 대략적인 개념을 이해할 필요가 있다

## 색인

제일 간단한 set, get을 내포하고 있는 데이터베이스를 기준으로 생각해보자.

```sql
#여기선 동시성 제어, 오류처리, 디스크 공간 회수 등의 실제여러 문제는 배제하고 생각한다
db_set(){
	echo "$1,$2" >> database
}

db_get(){
	grep "^$1," database | sed -e "s/^$1,//" | tail -n 1
}
```

db_set() :  파일의 끝에 추가하므로 키를 여러번 갱신해도 값의 예전 버전을 덮어 쓰지 않는다.

db_get() : 매번 키를 찾을 때마다 데이터베이스의 파일을 처음부터 끝까지 스캔해야 한다. 또한

레코드 수의 증가에 따라 검색 비용이 O(n)으로 증가한다.

set의 경우를 떠나 get메소드 호출시 매우 비효율적임을 알 수 있다.  특정 키의 값을 효율적으로 찾기 위해 다른 데이터 구조가 필요하며, 이를 색인 이라고 한다.

색인은 일반적으로 어떤 부가적인 메타데이터를 유지하며, 이 메타데이터는 이정표 역할로 원하는 데이터의 위치를 찾는 데 도움을 준다.

색인은 추가와 삭제를 허용하며, 이는 데이터베이스의 내용에 영향을 주진 않지만, 질의 성능에 영향을 준다. 무분별한 색인은 쓰기 속도를 떨어트린다.(데이터 쓰기시에 색인도 갱신해야 하기 때문)

색인을 잘 선택했다면, 읽기 질의 속도가 향상되지만, 무분별한 색인은 쓰기 속도를 떨어뜨리는 `trade-off 관계`이다.

## 로그 구조(log-structured)

### 해시 색인

키-값 데이터에 대한 색인으로 사전 타입(dictionary type)과 유사한 해시 맵으로 구현한 색인이다.

디스크 상의 데이터를 위한 인메모리 데이터 구조의 색인으로 생각하자.

단순히 파일에 추가하는 방식의 데이터 저장소를 구성한다는 가정하에 간단하게 아래와 같은 색인 전략을 쓸 수 있다.

![image](https://github.com/akfls221/23-11-DesigningDataIntensiveApplications/assets/71249347/5c5360f3-b5f8-43e9-9fa4-19dde4d3c76f)

키를 디스크상의 데이터 파일의 바이트 오프셋에 매핑하여 해시 맵을 유지한다. 값을 조회하려면 해시 맵을 사용해 데이터 파일에서 오프셋을 찾아 위치를 구하고 값을 읽는다.

이 단순 방식은 해시 맵을 전부 메모리에 유지하는 것을 조건으로 고성능 읽기, 쓰기를 보장한다.

주로 고유 키 자체가 많지는 않지만 키당 쓰기 수가 많은 작업부하에 적합하다.

그러나 위 같은 log-structured의 형식으로 데이터를 저장하면 항상 파일에 추가만 하기때문에 결국 디스크 공간이 부족해지게 된다.

이를 해결하기 위해 데이터를 특정 크기의 `세그먼트`로 나누고, 주기적 `컴팩션`을통해 해결한다.

![image](https://github.com/akfls221/23-11-DesigningDataIntensiveApplications/assets/71249347/117b9e91-45dd-4c32-a1b4-b0a6f1e3336f)

중복된 키를 버리고 각 키의 최신 값만 유지하는 컴팩션과 세그먼트 병합을 동시에 수행해 해시 맵은 각 데이터의 오프셋과 키를 매핑하고, 각 오프셋이 가리키는 값은 최신 값임을 보장할 수 있다.

그러나 해시 색인도 간단한 만큼 단점 또한 확실히 존재한다.

- 해시 테이블은 메모리에 저장해야 하기 때문에 키가 너무 많으면 문제가 된다.
- 해시 맵은 범위 질의(range query)에 대해 효율적이지 않다.(모든 범위를 조회해야 한다.)

### SS테이블과 LSM트리

위의 해시 색인과 같은 제한이 없는 구조도 확인해 보자.

추가적으로 위에서 봤던 세그먼트 파일에서 간단한 변경 사항 한 가지를 적용해 보자.

- 모든 key-value 쌍을 키로 정렬한다.

이처럼 키로 정렬된 형식을 `정렬된 문자열 테이블(Sorted String Table)`이라고 한다.

SS 테이블은 해시 색인을 가진 로그 세그먼트보다 몇 가지 큰 장점이 있다.

- 세그먼트 병합이 보다 효율적이며, 세그먼트가 정렬된 상태에서 병합이 일어나기 때문에 merge-sort가 가능하다.
- 파일에서 특정 키를 찾기 위해 모든 키의 색인을 유지할 필요 없이 일부 키에 대한 색인만 있으면 충분하다.

![image](https://github.com/akfls221/23-11-DesigningDataIntensiveApplications/assets/71249347/9522ee75-2147-4d94-9576-8d9e6455a622)

### SS테이블 생성과 유지

그럼 유입되는 쓰기는 임의 순서대로 발생하는데 이를 키로 정렬하려면 어떻게 해야할까

디스크 상에 정렬된 구조를 유지하는 일은 가능하지만, 메모리에 유지하는 편이 훨씬 쉽다.

아래 와 같은 쓰기와 읽기 과정을 통해 해결이 가능하다.

- 쓰기가 들어오면 인메모리(멤테이블) 균형 트리 데이터 구조에 추가한다.
- 멤테이블이 임계값보다 커지면 SS테이블 파일로 디스크에 기록한다.(트리가 이미 정렬되어 있어 효율적으로 수행이 가능하다)
- 읽기 요청을 제공하기 위해 아래와 같은 순서를 거친다.
  멤테이블 → 최신 세그먼트 → 두 번째 오래된 세그먼트 → 세 번째 오래된 세그먼트
- 백그라운드에서 세그먼트 파일을 합치고 덮어 쓰여지거나, 삭제된 값을 버리는 병홥과 컴팩션을 수행한다.

위와 같은 게획은 한 가지 문제가 있다. 만일 데이터베이스 고장으로 인해 디스크에 정상적으로 기록되지 않고 손실되는 데이터가 발행할 수 있다.

이를 해결하기 위해 매번 쓰기를 즉시 추가할 수 있게 분리된 로그를 디스크 상에 유지하고, 멤테이블이 정상적으로 복원되면, 삭제 처리한다.

### LSM트리

위와 같이 SS 테이블의 형식으로 디스크에 key-value 데이터를 저장하는 색인 방식(정렬된 파일 병합과 컴팩션 원리를 기반으로 함.)을 `LSM 트리`라고 한다.

LSM 트리의 성능 최적화를 위해 아래와 같이 몇 가지의 방법이 있다.

- 블룸 필터(Bloom filter)
  원소가 특정 집합에 속하는지 여부를 확률적으로 알아내는 자료구조로, 이를 활용해 키가 데이터베이스에 존재하지 않음을 확률적으로 알려줄 수 있으며, 없다고 판단되었을 경우는 실제로도 디스크에 없다는 것을 보장해 주기 때문에 디스크 읽기를 아낄 수 있다.
  다만, 확률적으로 알려주는 점에서 데이터가 있다고 판단했지만 실제 없는 `False Positive`가 발생할 수 있다.
- 크기 계층(size-tiered) / 레벨 컴팩션(leveled compaction)


    |  | 사이즈 계층 컴팩션 | 레벨 컴팩션 |
    | --- | --- | --- |
    | 기준 | 데이터의 사이즈 (크기) | 레벨 (계층) |
    | 데이터 저장 방식 | 레벨별로 크기에 따라 분산 저장 | 레벨별로 데이터 개수나 크기를 유지하며 저장 |
    | 병합 대상 | 가장 낮은 레벨에서 상위 레벨로 병합 | 상위 레벨에서 하위 레벨로 순차적으로 병합 |
    | 컴팩션 목표 | 쓰기 작업에 효율적, 디스크 I/O 최소화, 쓰기 성능 개선 | 읽기 작업에 효율적, 읽기 성능 개선 |
    | 중복 데이터 제거 | 가장 낮은 레벨에서 중복 데이터 제거 | 상위 레벨에서 하위 레벨로 순차적으로 중복 데이터 제거 |
    | 주로 사용되는 곳 | LSM 트리의 기본 컴팩션 방식, 쓰기 성능에 초점 | LSM 트리의 읽기 성능 향상에 초점 |

## 페이지 지향(page-oriented)

### B트리

LSM트리도 보편화되고는 있지만 아직 가장 널리 사용되는 색인 구조는 B트리로 그 구조가 LSM 트리와는 상당히 다르다. 사실상 정렬된 key-value 구조를 유지하기 때문에 범위 질의에 효율적이라는 점 빼고는 모두 다르다.

B트리는 수 메가바이트 이상의 가변 크기의 세그먼트를 가진 LSM과 다르게 4KB 크기의 고정 크기 블록이나 페이지로 나누고 한 번에 하나의 페이지에 읽기 또는 쓰기를 한다.

각 페이지는 주소나 위치를 이용해 식별이 가능하며 이 방식으로 하나의 페이지가 다른 페이지를 참조할 수 있다

![image](https://github.com/akfls221/23-11-DesigningDataIntensiveApplications/assets/71249347/254cb432-edbc-4836-b518-bc990c00fbce)

한 페이지는 B트리의 루트(root)로 지정되며, 하나의 페이지는 여러개의 키와 하위 페이지의 참조를 포함한다.(참고로 중간 노드를 브랜치 노드 라고 한다)

최종적으로 개별키(리프 페이지)를 포함하는 페이지에 도달하며, 각 키의 값을 포함하거나 값을 찾을 수있는 페이지의 참조를 포함한다.

B트리에 존재하는 키의 값을 갱신하려면, 키를 포함하고 있는 리프 페이지를 검색하고 페이지의 값을 바꾼 다음 페이지를 디스크에 다시 기록하는 과정이 필요하다. 새로운 키를 추가하기 위해선 새로운 키를 포함하는 범위의 페이지를 찾아 해당 페이지에 키와 값을 추가한다.

만일 여유 공간이 없다면 페이지 하나를 반쯤 채워진 페이지로 나누고, 상위 페이지가 새로운 키 범위의 하위 부분을 알 수 있도록 갱신한다.

![image](https://github.com/akfls221/23-11-DesigningDataIntensiveApplications/assets/71249347/52757cee-876b-431b-841c-bea53470440d)

이 알고리즘을 통해 트리의 균형을 유지하는것을 보장하며, n개의 키를 가진 B트리는 깊이가 항상 `O(log n)`이다. (보통 데이터베이스에선 3, 4정도의 깊이면 충분한 페이지 검색이 이루어진다.)

### 신뢰할 수 있는 B트리 만들기 / 최적화

- 데이터베이스가 고장 상황에서 스스로 복구할 수 있도록 일반적으로 디스크 상에 쓰기 전 로그(write-ahead log, `WAL`) 혹은 재 실행 로그(`redo log`)라고 하는 데이터 구조를 추가한다.
  쓰기 전 로그는 트리 페이지에 변경된 내용을 적용하기 전에 모든 변경 사항을 기록하는 추가 전용 파일로 데이터베이스 고장 이후 복구 될 때 일관성  있는 상태로 B트리를 다시 복원하는데 사용된다.
- 일부 데이터베이스의 경우 WAL 대신 `쓰기 시 복사(copy-on-write)`를 사용하기도 하며, 변경된 페이지를 다른 위치에 기록하고 트리 상위 페이지의 새로운 버전을 만들어 새로운 위치를 가리키게 한다.
- 같은 자리의 페이지 갱신 시 다중 스레드가 동시에 B트리에 접근한다면 주의 깊게 동시성 제어가 필요하며, 이를 위해 `래치(가벼운 잠금(lock))`을 활용해 데이터 구조를 보호한다.
- 페이지에 전체 키를 저장하지 않고 키를 축약해 써 공간을 절약할 수 있으며, 이를 통해 트리 깊이 수준을 낮출 수 있다.
- 트리에 포인터를 추가하여 각 리프 페이지가 양쪽 형제 페이지에 대한 참조를 가져 상위 페이지로 다시 이동하지 않아도 순서대로 키를 스캔할 수 있게 한다.
- B트리 변형인 프랙탈 트리의 경우 디스크 찾기를 줄이기 위해 LSM 구조를 일부 빌렸다.

### B트리와 LSM비교

일반적으로 B트리가 LSM트리보다 구현 성숙도가 더 높지만 LSM트리의 성능 특성때문에 관심을 받고있다. 일반적으로 LSM트리의 경우 쓰기에서 더 빠른 반면 B트리는 읽기에서 더 빠르다고 여긴다.

그러나, 비교가 유효하려면 실제 필요한 작업부하로 시스템 테스트를 진행해야 한다.

- 쓰기증폭

  데이터베이스가 한 번의 쓰기 요청을 처리하는 동안 실제 디스크에는 여러 번의 쓰기를 야기하는 효과를 말하며, 이는 SSD처럼 블록 덮어쓰기 횟수가 제한적인 경우 중요한 관심사이다.

  B트리의 경우 쓰기 전 로그(WAL)과 트리 페이지에 기록 즉, 최소 두 번 기록이 필요하다.
  해당 페이지 내 몇 바이트만 바뀌어도 전체 페이지를 기록해야 하는 오버헤드도 있다.

  하지만 LSM트리의 경우 여러 페이지를 매번 덮어쓰는 것이 아니라 순차적으로 컴팩션된 SS 테이블 파일을 쓰기 때문에 B트리보다 쓰기 증폭 면에선 더 효율적이다. 또한 이 차이는 순차 쓰기가 임의 쓰기보다 빠른 자기 디스크에서 중요하다.

- 성능

  LSM트리의 경우 컴팩션 과정이 때로는 진행 중인 읽기와 쓰기의 성능에 영향을 준다.
  한정적인 디스크 자원에서 비싼 컴팩션 연산이 끝날 때 까지 요청이 대기해야 하는 상황이 발생할 수 있다. 이에 반해 B트리의 성능은 LSM트리보다 예측하기가 쉽다.

  LSM트리의 경우 초기 쓰기 와 백그라운드에서 수행되는 컴팩션 스레드가 한정된 디스크 영역을 공유해야 한다. 데이터베이스가 점검 커질수록 컴팩션을 위한 많은 대역폭이 필요하며, 결국 컴팩션이 유입 쓰기 속도를 따라갈 수 없다. 이는 읽기 성능의 저하를 불러오기 때문에, 이런 상황 감지를 위해 명시적 모니터링이 필요하다.

- 파편화

  B트리의 경우 페이지를 나누거나 로우가 기존 페이지에 맞지 않을 때 페이지의 일부 공간은 사용하지 않게 되는등 디스크 공간 일부가 남는다. 그러나 LSM트리의 경우 페이지 지향 적이지 않고 주기적으로 파편화를 없애기 위해 SS테이블을 다시 기록하기 때문에 파편화가 훨씬 적다.
  레벨 컴팩션을 사용하면 특히 더 그렇다.

- 트랜잭션 시맨틱

  B트리의 경우 각 키가 색인의 한 곳에만 정확하게 존재한다는 장점이 있다. 반면 LSM의 경우 다른 세그먼트에 같은 키의 다중 복사본이 존재할 수 있다. 이런 측면 때문에 강력한 트랜잭션 시맨틱을 제공하는 데이터베이스에는 B트리가 훨씬 매력적이다.