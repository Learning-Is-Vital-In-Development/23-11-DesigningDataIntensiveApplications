# 3장 저장소와 검색

- 데이터베이스의 기본적인 작업 2가지
	- 1. 데이터를 저장
	- 2. 데이터를 제공

- 애플리케이션 개발자는 다양한 저장소 엔진중 `서비스의 작업 부하(Workload)에 적절한 저장소`를 선택해야함
	- 특히 트랜잭션 작업부하에 최적화된 엔진과 분석을 위해 최적화된 엔진 간에 큰 차이가 있음
- 저장소엔진이 좋은 성능을 내도록 튜닝하려면 저장소 내부에서 수행되는 작업에 대한 이해가 필요
- NoSQL, RDBMS
- 로그 구조(Log-Structured), B-Tree (Page-oriented)
	- Log
		- 애플리케이션 로그: 애플리케이션이 무슨일이 일어났는지 기술한 텍스트
		- 용어 자체의 일반적인 의미: `연속된` `추가 전용(Append-Only)` 레코드
			- 데이터의 맨 뒤에 지속적으로 레코드를 추가함
			- 한번 추가한 데이터의 변경은 없음
	- Page
		- 저장소를 페이지 단위로 나누고 해당 페이지의 레코드들을 지속적으로 재 갱신

```text
Log: 연속된 추가 전용 레코드 (애플리케인셔 무슨일이 일어났는지 기술한 텍스트를 넘어 보다 일반적인 의미)
```


## 3.1. 데이터베이스를 강력하게 만드는 데이터 구조

심플한 데이터 set(), get() 함수
```bash
#!/bin/bash

db_set() {
	echo "$1,$2" >> database
}

db_get() {
	grep "^$1," database | sed -e "s/^$1,//" | tail -n 1
}

```

- db_set: Append-only로 저장 시 좋은 성능을 보여줌
- db_get: 파일 전체를 읽어야함, 시간 복잡도: O(n) 

- db_get()의 성능을 개선하기 위해 다른 데이터 구조가 필요 (인덱스)
	- 인덱스는 기본데이터에서 파생된 추가적인 데이터
		1. 색인은 기존 데이터베이스의 내용에는 영향을 미치지 않음
		2. 하지만 기존 데이터의 변경 시 색인도 갱신하는 추가적인 작업이 필요하고 쓰기 속도가 느려짐
- 저장소 시스템의 중요한 트레이드 오프: 인덱스를 설정하면 `읽기 속도가 빨라지지만 저장 속도는 느려`진다.


### 3.1.1. 해시 색인

Key-value 형태로 색인 하는 것
- 프로그래밍 언어의 사전 타입과 유사
![[그림 3-1. 해시맵 색인.png]]]

위처럼 지속적으로 로그를 쌓다보면 디스크 공간이 부족해지는데 이를 극복하기 위해 컴팩션(compaction)을 수행함
- 컴팩션: 로그에서 중복된 키를 버리고 각 키의 최신 갱신 값만 유지

아래 그림 처럼 데이터 세그먼트 파일을 백스라운드  스레드에서 지속적으로 병합함
![[그림 3-3. 컴팩션과 세그먼트 병합.png]]


추가전용 로그 구조의 장점
- 추가와 세그먼트 병합은 순차적인 쓰기 작업이기 때문에 데이터가 저장된 위치를 찾아 내용을 갱신하는 B-Tree의 페이지 방식 보다 빠름
- 세그먼트 파일이 추가 전용이고 불편이기 때문에 동시성과 고장 복구가 간단함 (장애가 발생해도 갱신되기 전의 이전 값들이 그대로 있기에 이전 값들을 읽어 복구)
- 오래된 세그먼트들을 병합하여 시간이 지남에 따라 조각화되는 데이터 파일 문제를 피할 수 있음

해시 테이블 색인의 제한 사항
- 해시 테이블은 메모리에 저장해야 하므로 키가 너무 많으면 문제가 됨
- 해시 테이블은 범위 질의 (Range Scan)시에도 모든 개별 키 값을 조회해야하므로 1~9999와 같은 범위 조회 시  비효율적


### 3.1.2. SS테이블과 LSM 트리

- Sorted String Table
	- 키-값의 쌍을 키 순서로 정렬한 데이터

SS 테이블의 장점 (해시 테이블 색인의 제한 사항 극복)
- 특정 키를 찾기 위해 메모리에 모든 키의 색인을 유지할 필요 없이 아래 그림처럼 희소 색인(Sparse Index)을 유지해 검색할 수 있음
	- ex. handiwork를 찾기 위해 handbag 에서 시작해 handiwork가 나올때까지 스캔
- 요청 범위 내에서 키-값 쌍을 스캔해야 하기 때문에 해당 레코드들을 블록으로 그룹화하고 디스크에 쓰기전에 압축함 (따라서 희소 색인의 각 오프셋은 압축된 블록의 시작을 가리킴)
	- 이는 디스크 공간을 절약하고 I/O 대역폭 사용도 줄임

![[그림 3-5. 인메모리 색인을 가진 SS테이블.png]]

그림 3-5. 인메모리 색인을 가진 SS 테이블
- Log-Structured Merge-Tree

#### 3.1.2.1. SS테이블 생성과 유지
- 데이터를 키로 정렬하기
	- 디스크 상에도 정렬된 구조를 유지하는 일이 가능하지만 메모리에 유지하는 방법이 쉬움
	
1. 레드 블랙 트리나 AVL 트리와 같은 인메모리 균형 트리 자료 구조를 활용해 데이터를 키로 정렬함 (멤테이블, memtable 이라고도함)
2. 멤테이블이 임계값 보다 커지면 SS테이블 파일로 디스크에 기록함 (트리가 이미 키로 정렬된 키-값 쌍을 유지하고 있기에 저장이 수월)
3. 읽기요청 시 우선 멤 테이블에서 키를 찾고 그다음 디스크 상의 SS테이블 세그먼트 탐색
4. 가끔 SS테이블 세그먼트 파일을 합치는 병합, 컴팩션 과정을 수행함

#### 3.1.2.2. SS테이블에서 LSM 트리 만들기

- LSM(Log-Structured Merge-Tree)
	- 정렬된 파일 병합과 컴팩션 원리를 기반으로 하는 저장소 엔진을 LSM 저장소 엔진이라고 부름
- LSM을 적용한 저장소 예시: 레벨DB, 록스DB, 카산드라, HBase 등

#### 3.1.2.3. 성능 최적화

- 존재하지 않는 키를 찾는 경우 느린문제: 존재하지 않는 키를 찾으려는 경우 맴테이블 확인 후 가장 오래된 세그먼트까지 모두 확인해서 키의 존재 유무를 파악해야함 (블룸 필터로 극복, 블룸 킬퍼는 키가 데이터베이스에 존재하지 않음을 알려줌)
- 백그라운드에서 SS테이블을 지속적으로 병합함
	- SS테이블을 압축하고 병합하는 순서와 시기를 결정하는 전략 
		- 크기 계층 (size-tiered), 레벨 컴팩션 (leveled compaction)
		- 
### 3.1.3. B 트리

가장 많이 사용되는 색인 구조는 B-Tree 구조로 Log-Structured 색인과는 상당히 다름

- 로그 구조화 색인
	- 데이터베이스를 수 메가바이트 이상의 가변 크기를 가진 세그먼트로 나누고 항상 순차적으로 세그먼트를 기록함
- B-Tree 색인
	- 일반적으로 4~16Kb 크기의 고정 크기 블록이나 페이지로 데이터를 나누고 한번에 하나의 페이지에 읽기 또는 쓰기를 함
	- 데이터를 업데이트 할 때 데이터가 저장된 페이지를 찾아가 업데이트 하기에 저장된 페이지를 찾아야하고 페이지가 덮어씌워지면서 이전 값을 잃어버릴 수 있음

#### 3.1.3.1. 신뢰할 수 있는 B 트리 만들기

- B트리의 기본적인 쓰기 동작은 새로운 데이터를 디스크 상의 페이지에 덮어씌움
- 만약 여러 페이지에 덮어쓰기를 하다 일부 페이지만 기록하고 서버 장애가 발생한다면?
	- 장애가 발생하기 이전 시점으로 돌리기 어려움
	- 장애 복구를 위해 일반적으로 디스크상에 먼저 로그를 저장 함 (Write-Ahead Log, WAL, 재실행 로그 redo log라고도 함)
- 다중 스레드가 동시에 B트리에 접근해서 수정하려고 한다면?
	- 주의 깊은 동시성 제어가 필요
	- 동시성은 보통 Latch(래치) 라는 가벼운 잠금으로 제어

#### 3.1.3.2. B 트리 최적화

B 트리는 오랜기간 사용되었기 때문에 많은 최적화가 있었음

- 페이지 덮어 쓰기와 고장 복구를 위한 Write-Ahaed Log 유지 대신, 여러 버전의 페이지를 가지고 있기 
	- MVCC(Multi-Version Concurrency Control, 다중 버전 동시성 제어)
- 페이지에 전체 키를 저장하는게 아니라 키를 축약해서 쓰고 공간을 절약한다. 트리의 분기계수를 높이고 깊이 수준을 낮출 수 있음 (분기계수를 높인다: 한 페이지에 보다 많은 키값을 저장)
	- B-Tree의 깊이가 3일 때 저장할 수 있는 키값 수
		- 분기계수 500 = 500^3 =
		- 분기계수 200 = 200^3 = 
- B-Tree의 페이지는 디스크상 어디에나 위치할 수 있고 이는 연속된 데이터 스캔시 비효율적이기에 리프 페이지를 디스크 상에 연속된 순서로 배치하려는 로직이 있음
- 트리의 리프에 포인터를 추가해 양쪽 형제페이지 간 이동할 수 있음 (트리를 타지 않고 레인지 스캔 가능)
- 프랙탈 트리: B 트리 변형, 디스크 찾기를 줄임


### 3.1.4. B 트리와 LSM 트리 비교

일반적으로 LSM 트리는 쓰기에서 빠른 반면 B 트리는 읽기에서 빠르다고 여김
- LSM 트리가 읽기에서 더 느린 이유: 각 컴팩션 단계에 있는 여러 가지 데이터 구조와 SS 테이블을 확인해야 함
#### 3.1.4.1. LSM 트리의 장점

B-Tree
- B-Tree 색인은 페이지 단위로 데이터를 업데이트 하기에 페이지의 레코드 1개만 변경되어 전체 레코드를 변경해야함
- B-Tree 는 데이터를 최소한 2번 기록 해야함 (WAL + Page)
	- 이렇게 한번 쓸 때 여러번 쓰는 작업을 쓰기 증폭 이라고함
	- 디스크에 여러번 데이터 쓰기 작업을 해야하고 이는 디스크의 수명에 영향을 줌 
	- 또한 쓰기가 많은 애플리케이션의 경우 디스크에 쓰는 속도가 병목 (성능 비용 발생)

LSM 트리
- LSM 트리는 순차쓰기를 하기 때문에 높은 처리량을 높게 유지할 수 있고 상대적으로 쓰기 증폭이 낮음
- 데이터가 페이지 지향적이지 않고 주기적으로 병합하기 때문에 데이터가 파편화되지 않고 압축률이 좋음

#### 3.1.4.2. LSM 트리의 단점
- 컴팩션 과정이 읽기와 쓰기 성능에 영향을 
	- LSM 트리의 경우 저장소 엔진의 응답시간 상위 백분위(p99, p999) 값이 높음
- 컴팩션 속도가 쓰기 속도를 따라가지 못한다면 병합되지 않은 세그먼트가 디스크 공간이 부족할때까지 계속 증가함
	- 컴팩션이 잘 되고 있는지 명시적인 모니터링 필요
- B 트리의 경우 각 키가 색인의 한 곳에만 정확하게 존재하지만, 로그 구조화 저장소엔진은 다른 세그먼트에 같은 키의 다중 복사본이 존재할 수 있음 (별도 처리가 필요)


### 3.1.5. 기타 색인 구조

- 키-값 색인의 대표적인 예는 기본 키(Primary Key) 인덱스
- 기본 키로 테이블에서 하나의 Row, 문서 데이터베이스에서 Document 그래프 데이터베이스에서 Vertex를 참조
- 보조 색인(Secondary Index): PK와 달리 보조 색인을 중복된 값을 가질 수 있음

기본 키와 보조색인 모두 LSM, B Tree 데이터 구조에 사용할 수 있음


#### 3.1.5.1. 색인 안에 값 저장하기

- 커버링 인덱스, 클러스터링 인덱스
- 색인안에 Row의 모든 값을 저장해서 바로바로 사용한다.
- 읽기 성능을 높일 수 있지만 추가적인 저장소와 인덱스의 업데이트가 필요하므로 쓰기 속도에 영향을 줄 수있음

#### 3.1.5.2. 다중 컬럼 색인
- Key: (성, 이름)
- Value: 전화번호

위 색인으로 특정 성을 가진 모든 사람이나, 특정 성 + 이름을 가진 모든 사람을 찾을 수 있지만 특정 이름을 가진 모든 사람을 찾기는 힘듦 (스킵 스캔을 지원하기도 함)


#### 3.1.5.3. 전문 검색과 퍼지 색인
- 전문 검색 시  철자가 틀린 단어와 유사한 키에 대해서도 검색할 수 있도록 동의어를 자동으로 검색하거나 특정 편집 거리 내(edit distance) 단어 검색을 지원
#### 3.1.5.4. 모든 것을 메모리에 보관
- 데이터를 디스크에 저장하는 것의 장점
	- GB 당 비용이 저렴함
	- 디스크는 지속성이 있음
- 메모리에 저장하는 것의 장점
	- 모든 것을 메모리에 저장해 빠르게 읽어올 수 있음
	- 디스크에 데이터를 저장하기 위해 데이터를 부호화할 필요가 없어 오버헤드 감소
	- 디스크에 저장하는 것보다 구현이 간단함


### 용어
- Log: 시스템의 운영 현황 기록, 추가 전용 저장소
- WAL: Write Ahead Log, 로깅하기 전에 먼저 디스크에 데이터를 저장하고 장애 발생 시 복구에 활용
- LSM(Log-Structured Merge-Tree)
- SS Table: Sorted String Table


## 3.2. 트랜잭션 처리나 분석?

- 보통 애플리리케이션은 인덱스를 이용해 데이터 저장소에서 적은 수의 레코드를 찾는다.
```sql
select * from orders where id = 12345
```

- OLTP: 일반적인 애플리케이션
- OLAP: 데이터 분석 환경 


### 3.2.1. 데이터 웨어하우징

- 여러 도메인, 서비스의 데이터를 변환해서 한 곳에 모으고 분석한다.

#### 3.2.1.1. 데이터베이스와 데이터 웨어하수의 차이점


#### 3.2.2. 분석용 스키마: 별 모양 스키마와 눈꽃송이 모양 스키마

## 3.3. 컬럼 지향 저장소

### 3.3.1. 컬럼 압축

### 3.3.2. 컬럼 저장소의 순서 정렬

### 3.3.3. 컬럼 지향 저장소에 쓰기

### 3.3.4. 집계: 데이터 큐브와 구체화 뷰

## 3.4. 정리
