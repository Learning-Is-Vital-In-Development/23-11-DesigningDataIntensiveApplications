## 직렬성

쓰기 스큐, 팬텀 등 완화된 격리 수준(read committed, snapshot isolation 등)으로는 해결하기 어려운 문제가 있다. 
일반적으로 이를 해결할 때 직렬성 격리를 사용한다.
직렬성 격리는 여러 트랜잭션이 병렬로 실행되더라도 최종 결과는 동시성 없이 한번에 하나씩 직렬로 실행될 떄와 같도록 보장한다.

### 실제적인 질렬 실행(Actual Serial Execution)

동시성 문제를 피하는 가장 간단한 방법은 모든 작업을 순차처리 하는 것이다.
단일쓰레드 한번에 트랜잭션 하나만 직렬로 수행되도록 하면 된다.

단일 쓰레드로 실행되도록 설계된 시스템이 동시성을 지원하는 시스템보다 성능이 나을 때도 있다.
Lock을 코디네이션하는 오버헤드를 피할 수 있기 때문이다.
하지만 이들은 처리량이 CPU 코어 하나의 처리량으로 제한된다는 단점이 있다.

#### 트랜잭션을 스토어드 프로시저 안에 캡슐화하기

DB에서 동시성을 허용하지 않고 순차적으로 트랜잭션을 하나씩 처리한다면 성능이 많이 느릴 것이다.
이를 위해 트랜잭션 코드 전체를 스토어드 프로시저 형태로 데이터베이스에 미리 제출한다.

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/6b5ab43f-37bc-4f40-9c8e-5b71116c4f20)

#### 파티셔닝

모든 트랜잭션을 순차적으로 실행하면 동시성 제어는 간단해지지만 DB 처리량이 단일 장비의 단일 CPU 코어의 속도로 제한된다. 
쓰기 처리량이 높은 어플리케이션에서는 단일 스레드 트랜잭션 처리자가 심각한 병목이 될 수 있다.

- 파티셔닝을 통한 쓰기 처리량 분산
    - 각 트랜잭션이 단일 파티션 내에서만 데이터를 읽고 쓰도록 데이터셋을 파티셔닝할 수 있다.
        - 이 경우, 각 파티션은 다른 파티션과 독립적으로 실행되는 자신만의 트랜잭션 처리 쓰레드를 가질 수 있다.
    - 그러나 여러 파티션에 접근해야 하는 트랜잭션이 있다면 해당 트랜잭션이 접근하는 모든 파티션에 걸쳐 코디네이션을 해야한다.
        - 따라서 코디네이션으로 인한 오버헤드가 발생하고, 단일 파티션 트랜잭션보다 엄청나게 느리다.

#### 직렬 실행 요약

트랜잭션 직렬실행은 몇가지 제약 사항 안에서 직렬성 격리를 획득하는 실용적인 방법이 됐다.

- 모든 트랜잭션은 작고 빨라야 한다.
- 활성화된 데이터셋이 메모리에 적재될 수 있어야 한다(단일 스레드).
- 쓰기 처리량이 단일 CPU 코어에서 처리할 수 있을 정도로 충분히 낮아야 한다. 그렇지 않으면 여러 파티션에 걸친 코디네이션이 필요하지 않도록 트랜잭션을 파티셔닝해야 한다.


### 2단계 잠금(2PL)

쓰기 트랜잭션은 다른 쓰기 트랜잭션뿐만 아니라 읽기 트랜잭션도 진행하지 못하게 막고 읽기 트랜잭션 또한 다른 쓰기 트랜잭션이 동작하지 못하도록 막는다.

- 읽기 시 공유 모드(shared mode) 잠금
- 쓰기 시 독점 모드(exclusive mode) 잠금
- 트랜잭션이 잠금을 획득한 후에는 트랜잭션이 종료(커밋 또는 어보트)될 때까지 잠금을 갖고 있어야 한다.


동시성이 크게 줄어들어 완화된 격리 수준을 쓸 때보다 트랜잭션 처리량과 질의 응답 시간이 크게 나빠진다.

#### 서술 잠금(Predicate lock)

한 트랜젝션이 다른 트랜젝션의 검색 질의 결과를 바꾸어버리는 문제인 팬텀을 막기 위해 어떤 검색 조건에 해당하는 객체를 잠근다.

하지만 진행 중인 트랜젝션들이 획득한 잠금이 많다면 조건에 부합하는 잠금을 확인하는데 시간이 오래 걸린다.

#### 색인범위잠금(index-range locking)

때문에 대부분의 DB는 서술 조건을 간략화하고 그 조건에 해당하는 객체를 잠그는 색인 범위 잠금을 구현한다.

서술 잠금보다 정밀하지는 않지만(더 큰범위를 잠글 수도 있지만) 오버헤드가 훨씬 더 낮기 때문에 좋은 타협안이 된다.



### 직렬성 스냅숏 격리(Serializable snapshop isolation, SSI)

- 직렬 실행 : 확장성이 좋지 않음
- 2PL : 성능이 좋지 않음
- 완화된 격리 수준 : 성능은 좋지만 다양한 경쟁 조건(갱신 손실, 쓰기 스큐, 팬텀)에 취약함

직렬성 격리의 좋은 성능은 근본적으로 공존을 위해 **직렬성 스냅숏 격리(serializable snapshot isolation)** 알고리즘이 아주 유망하다


#### 비관적 동시성 제어 vs 낙관적 동시성 제어

| 비관적 동시성 제어 | 낙관적 동시성 제어|
|:--|:--|
|뭔가 잘못될 가능성이 있다면 뭔가를 하기 전에 상황이 다시 안전해질 때까지 기다린다 |뭔가 위험한 상황이 발생했을 때 트랜젝션을 막는 대신 모든 것이 괜찮아질 거라는 희망을 갖고 계속 진행한다|
|2단계 잠금, 직렬실행| 직렬성 스냅숏 격리|

- 경쟁이 심해 같은 객체에 많은 트랜젝션들이 접근하고자 하면 어보트시켜야 할 트랜젝션의 비율이 높아지기 때문에 성능이 나빠진다.
- 그러나 예비 용량이 충분하고 트랜젝션 사이의 경쟁이 너무 심하지 않으면 낙관적 동시성 제어 기법은 비관적 동시성 제어보다 성능이 좋은 경향이 있다.
- 경쟁은 가환(communicative) 원자적 연산을 써서 줄일 수 있다.( 카운터를 증가...)

SSI는 스냅숏 격리 위에 쓰기 작업 간의 직렬성 충돌을 감지하고 어보트시킬 트랜젝션을 결정하는 알고리즘을 추가한다

#### 뒤쳐진 전제에 기반한 결정

일단 스냅숏에 따라 트랜잭션을 실행하고 나중에 해당 트랜잭션이 커밋하려고 할 때 전제조건이 바뀌었는지 판단한다. 뒤처진 전제를 기반으로 동작하는 상황이라면 트랜잭션을 어보트시킨다.

- 오래된 MVCC 읽기 감지하기
  - 트랜젝션이 커밋하려고 할 때 데이터베이스는 무시된 쓰기 중에 커밋된 게 있는지 확인하고 존재한다면 트랜젝션을 어보트한다
- 과거의 읽기에 영향을 미치는 쓰기 감지하기



#### 직렬성 스냅숏 격리의 성능

추적 정도에 따른 트레이드 오프를 고려해야한다.

- 매우 상세하게 추적 : 어보트돼야 하는 트랜젝션을 정확하게 판별 가능, 기록 오버헤드가 증가
- 덜 상세하게 추적 : 빠르지만 진짜 필요한 것보다 지나치게 많은 트랜젝션이 어보트

|VS| description|
|:--:|:--|
|2단계 잠금| 2PL과 달리 직렬성 스냅숏 걱리의 큰 이점은 트랜젝션이 다른 트랜젝션들이 잡고 있는 잠금을 기다리느라 차단될 필요가 없다<br><br>스냅숏 격리하에서와 마찬가지로 쓰는 쪽은 읽는 쪽을 막지 않고 읽는 쪽도 쓰는 쪽을 막지는 않는다<br>이런 설계 원칙은 질의 지연 시간 예측이 쉽고 변동이 적게 만든다<br><br>특히 읽기 전용 질의는 어떤 잠금도 없이 일관된 스냅숏 위에서 실행될 수 있어 읽기 작업부하가 심한 경우에 매우 좋다| 
|순차 실행|SSI은 단일 CPU 코어의 처리량에 제한받지 않는다<br>(파운데이션DB는 직렬성 충돌 감지를 여러 장비로 분산시켜 처리량이 아주 높도록 확장가능케 한다)<br><br>데이터가 여러 장비에 걸쳐 파티셔닝되어 있어도 트랜젝션은 직렬성 격리를 보장하면서 여러 파티션으로부터 읽고 쓸 수 있다 |
