# Ch07 트랜잭션(직렬성)

- 격리 수준은 이해하기 어렵고 데이터베이스마다 그 구현에 일관성이 없다. 예를 들어 반복 읽기의 의미는 상당히 다양하다.
- 애플리케이션 코드를 보고 특정한 격리 수준에서 해당 코드를 실행하는 게 안전한지 알기 어렵다.
- 경쟁 조건을 감지하는 데 도움이 되는 좋은 도구가 없다.

직렬성 격리는 보통 가장 강력한 격리 수준이라고 여겨진다. 여러 트랜잭션이 병렬로 실행되더라도 최종 결과는 동시성 없이 한 번에 하나씩 직렬로 실행될 때와 같도록 보장한다. 즉 데이터베이스가 발생할 수 있는 **모든** 경쟁 조건을 막아준다.

오늘날 직렬성 격리를 제공하는 데이터베이스는 대부분 세 가지 기법 중 하나를 사용한다.

- 트랜잭션을 순차적으로 실행하기
- 2 Phase Lock (2단계 잠금)
- 직렬성 스냅숏 격리 같은 낙관적 동시성 제어(Optimistic concurrency control, [[Optimistic Lock]]) 기법

### 실제적인 직렬 실행

동시성 문제를 피하는 가장 간단한 방법은 동시성을 완전히 제거하는 것이다. 한 번에 트랜잭션 하나씩만 직렬로 단일 스레드에서 실행하면 된다. 그러면 트랜잭션 사이의 충돌을 감지하고 방지하는 문제를 완전히 회피할 수 있으며 결과적으로 격리 수준은 당연히 직렬성 격리가 된다.

뻔한 생각처럼 보이지만 데이터베이스 설계자들은 상당히 최근(2007년경)이 돼서야 단일 스레드 루프에서 트랜잭션을 실행하는 게 실현 가능하다고 결론내렸다. 30년 동안의 다중 스레드 동시성에 대한 생각이 변하게 된 이유는 다음과 같다.

- **램 가격이 저렴해져서 활성화된 데이터셋 전체를 메모리에 유지할 수 있을 정도가 됐다.** 트랜잭션이 접근해야 하는 모든 데이터가 메모리에 있다면 디스크에서 읽어 오기를 기다려야 할 때보다 트랜잭션이 훨씬 빨리 실행될 수 있다.
- 데이터베이스 설계자들은 OLTP 트랜잭션이 보통 짧고 실행하는 읽기와 쓰기의 개수가 적다는 것을 깨달았다.

트랜잭션을 순차적으로 실행하는 방법은 볼트Db/H-스토어, [[Redis]], [[Datomic]] 에서 구현돼 있다. 잠금을 코디네이션하는 오버헤드를 피할 수 있기 때문에 단일 스레드로 실행되도록 설계된 시스템이 동시성을 지원하는 시스템보다 성능이 나을 때도 있다. 그렇지만 이들의 처리량은 하나의 CPU 코어로 제한되기 때문에, 단일 스레드를 최대한 활용하려면 트랜잭션이 전통적인 형태와는 다르게 구조화돼야 한다.

#### 직렬 실행 요약

트랜잭션 직렬 실행은 몇 가지 제약 사항 안에서 직렬성 격리를 획득하는 실용적인 방법이다.

- 모든 트랜잭션은 작고 빨라야 한다. 느린 트랜잭션 하나가 모든 트랜잭션 처리를 지연시킬 수 있다.
- 활성화된 데이터셋이 메모리에 적재될 수 있는 경우로 사용이 제한된다.
- 쓰기 처리량이 단일 CPU 코어에서 처리할 수 있을 정도로 충분히 낮아야 한다. 그렇지 않으면 여러 파티션에 걸친 코디네이션이 필요하지 않도록 트랜잭션을 파티셔닝해야 한다.
- 여러 파티션에 걸친 트랜잭션도 쓸 수 있지만 이것을 사용할 수 있는 정도에는 엄격한 제한이 있다.

### 2단계 잠금(2PL)

약 30년 동안 데이터베이스에서 직렬성을 구현하는 데 널리 쓰인 유일한 알고리즘이 있다. 바로 **2단계 잠금(two-phase locking, 2PL)** 이다.

> [!warning] 2PL 은 2PC 가 아니다
> 2단계 잠금(2PL)과 2단계 커밋([[Two Phase Commit]], 2PC)은 아주 비슷하게 들리지만 완전히 다르다.

더티 쓰기(dirty write)를 막는 데 잠금이 자주 사용된다. 두 개의 트랜잭션이 동시에 같은 객체에 쓰려고 하면 잠금은 나중에 쓰는 쪽이 진행하기 전에 먼저 쓰는 쪽에서 트랜잭션을 완료(어보트되거나 커밋되거나)할 때까지 기다리도록 보장해준다.

2단계 잠금도 비슷하지만 잠금 요구사항이 훨씬 더 강하다.

- 트랜잭션 A 가 객체 하나를 읽고 트랜잭션 B 가 그 객체에 쓰기를 원한다면 B 는 진행하기 전에 A가 커밋되거나 어보트될 때까지 기다려야 한다
- 트랜잭션 A가 객체에 썼고 트랜잭션 B가 그 객체를 읽기 원한다면 B는 진행하기 전에 A가 커밋되거나 어보트될 때까지 기다려야 한다. **2PL 을 쓸 때는 객체의 과거 버전을 읽는 게 허용되지 않는다**.

2PL 에서 쓰기 트랜잭션은 다른 쓰기 트랜잭션 뿐만 아니라 읽기 트랜잭션도 진행하지 못하게 막고 그 역도 성립한다. 스냅숏 격리는 **읽는 쪽은 결코 쓰는 쪽을 막지 않으며 쓰는 쪽도 결코 읽는 쪽을 막지 않는다**는 원칙이 있는데 이게 스냅숏 격리와 2단계 잠금의 중요한 차이다. 반면 2PL 은 직렬성을 제공하므로 앞에서 설명했던 갱신 손실과 쓰기 스큐를 포함한 모든 경쟁 조건으로부터 보호해준다.

#### 2단계 잠금 구현

2PL 은 [[MySQL]](InnoDB)과 SQL server 에서 직렬성 격리 수준을 구현하는데 사용되고 DB2에서는 반복 읽기 격리 수준을 구현하는데 사용된다.

읽는 쪽과 쓰는 쪽을 막는 것은 데이터베이스의 각 객체에 잠금을 사용해 구현한다. 잠금은 **공유 모드(shared mode)** 나 **독점 모드(exclusive mode)** 로 사용될 수 있다. 잠금은 다음과 같이 사용된다.

- 트랜잭션이 객체를 읽기 원한다면 먼저 공유 모드로 잠금을 획득해야 한다. 동시에 여러 트랜잭션이 공유 모드로 잠금을 획득하는 것은 허용되지만 만약 그 객체에 이미 독점 모드로 잠금을 획득한 트랜잭션이 있으면 이 트랜잭션이 완료될 때까지 기다려야 한다.
- 트랜잭션이 객체에 쓰기를 원한다면 먼저 독점 모드로 잠금을 획득해야 한다. 다른 어떤 트랜잭션도 동시에 잠금을 획득할 수 없으므로(공유 모드든지 독점 모드든지) 그 객체에 잠금이 존재한다면 트랜잭션은 대기해야 한다.
- 트랜잭션이 잠금을 획득한 후에는 트랜잭션이 종료(커밋 또는 어보트)될 때까지 잠금을 갖고 있어야 한다.

잠금이 아주 많이 사용되므로 교착 상태([[Dead Lock]])가 매우 쉽게 발생할 수 있다. 데이터베이스는 트랜잭션 사이의 교착 상태를 자동으로 감지하고 트랜잭션 중 하나를 어보트시켜서 다른 트랜잭션이 진행할 수 있게 한다. 어보트된 트랜잭션은 애플리케이션에서 재시도해야 한다.

#### 2단계 잠금의 성능

2단계 잠금의 가장 큰 약점은 성능이다. 2단계 잠금을 쓰면 완화된 격리 수준을 쓸 때보다 트랜잭션 처리량과 질의 응답 시간이 크게 나빠진다.

원인은 동시성이 줄어드는 것에 있다. 설계에 따라 두 트랜잭션이 어떤 식으로든 경쟁 조건을 유발하는 일을 하려고 하면 한 트랜잭션은 다른 트랜잭션이 완료될 때까지 기다려야 한다.

2PL 을 실행하는 데이터베이스는 작업부하에 경쟁이 있다면 지연 시간이 아주 불안정하고 높은 백분위에서 매우 느릴 수 있다. 견고한 연산이 필요할 때 이런 불안정성은 문제가 된다.

트랜잭션이 교착 상태 때문에 어보트돼 재시도하면 작업을 전부 다시 해야 한다. 교착 상태가 잦으면 헛수고가 심하다는 뜻도 된다.

#### 서술 잠금

직렬성 격리를 쓰는 데이터베이스는 팬텀을 막아야 한다.

회의실 예약 예제로 설명하면 한 트랜잭션이 특정 시간 범위 내에 있는 회의실 예약을 검색했다면, 다른 트랜잭션이 같은 시간 범위 내에서 동일한 회의실을 쓰는 예약을 삽입하거나 갱신하는 게 허용되지 않는다는 뜻이다.

개념상으로 **서술 잠금(predicate lock)** 이 필요하다. 서술 잠금은 앞에서 설명한 공유/독점 잠금과 비슷하게 동작하지만 특정 객체에 속하지 않고 아래와 같은 어떤 검색 조건에 부합하는 모든 객체에 속한다.

```sql
SELECT * FROM bookings
    WHERE room_id = 123 AND
        end_time > '2018-01-01 12:00' AND
        start_time < '2018-01-01 13:00';
```

- 트랜잭션 A가 위 SELECT 질의처럼 어떤 조건에 부합하는 객체를 읽기 원한다면 질의의 조건에 대한 공유 모드 서술 잠금을 획득해야 한다. 다른 트랜잭션 B가 그 조건에 부합하는 어떤 객체에 독점 잠금을 갖고 있으면 A는 질의를 실행하도록 허용되기 전에 B가 잠금을 해제하기를 기다려야 한다.
- 트랜잭션 A가 어떤 객체를 삽입, 갱신, 삭제하길 원한다면 먼저 기존 값인 ㅏ새로운 값 중에 기존의 서술 잠금에 부합하는게 있는지 확인해야 한다. 부합하는 서술 잠금을 트랜잭션 B가 잡고 있다면 A 는 B가 종료될 때까지 기다려야 한다.

여기서 핵심 아이디어는 서술 잠금은 데이터베이스에 아직 존재하지 않지만 미래에 추가될 수 있는 객체(팬텀)에도 적용할 수 있다는 것이다. 2단계 잠금이 서술 잠금을 포함하면 데이터베이스에서 모든 형태의 쓰기 스큐와 다른 경쟁 조건을 막을 수 있어서 격리 수준이 직렬성 격리가 된다.

#### 색인 범위 잠금

유감스럽게도 서술 잠금은 잘 동작하지 않는다. 진행 중인 트랜잭션들이 획득한 잠금이 많으면 조건에 부합하는 잠금을 확인하는 데 시간이 오래 걸린다. 이 때문에 2PL 을 지원하는 대부분의 데이터베이스는 실제로는 **색인 범위 잠금(index-range locking, 다음 키 잠금(next-key locking)이라고도 한다)** 을 구현한다. 이것은 서술 잠금을 간략하게 조절하여 더 많은 객체가 해당되도록 한 것이다.

더 많은 객체가 부합하도록 서술 조건을 간략화하는 것은 안전하다. 예를 들어 정오와 오후 1시 사이에 123번 방을 예약하는 것에 대한 서술 잠금은 모든 시간 범위에 123번 방을 예약하는 것에 대한 잠금으로 근사할 수 있다. 또는 정오와 오후 1시 사이에 모든 방을 잠그는 것으로 근사할 수 있다. 원래의 서술 조건에 부합하는 쓰기는 분명히 근사 조건에도 부합하므로 안전하다.

어떤 방법을 쓰든지 간략화한 검색 조건이 색인 중 하나에 붙는다. 이제 다른 트랜잭션이 같은 방을 사용하거나 시간이 겹치는 예약을 삽입, 갱신, 삭제하길 원한다면 색인의 같은 부분을 갱신해야 한다. 그 과정에서 공유 잠금을 발견하고 잠금이 해제될 때까지 기다리게 된다.

색인 범위 잠금은 서술 잠금보다 정밀하지 않지만 오버헤드가 훨씬 더 낮기 때문에 좋은 타협안이 된다.

범위 잠금을 잡을 수 있는 적합한 색인이 없다면 데이터베이스는 테이블 전체에 공유 잠금을 잡는 것으로 대체할 수 있다. 그 테이블에 쓰는 다른 모든 트랜잭션을 멈추므로 성능에는 좋지 않지만 안전한 대비책이다.

### 직렬성 스냅숏 격리(SSI)

직렬성 격리와 좋은 성능은 근본적으로 공존할 수 없는 것처럼 보인다.

직렬성 스냅숏 격리(serializable snapshot isolation, SSI)라는 알고리즘은 완전한 직렬성을 제공하지만 스냅숏 격리에 비해 약간의 성능 손해만 있다.

오늘날 SSI 는 단일 노드 데이터베이스(PostgreSQL 은 9.1 버전부터 직렬성 격리 수준을 제공)와 분산 데이터베이스 모두에서 사용된다.

#### 비관적 동시성 제어 대 낙관적 동시성 제어

2단계 잠금은 이른바 **비관적** 동시성 제어 메커니즘이다. 뭔가 잘못될 가능성이 있으면 뭔가를 하기 전에 상황이 다시 안전해질 때까지 기다리는 게 낫다는 원칙을 기반으로 한다. 다중 스레드 프로그래밍에서 자료구조 보호를 위해 사용되는 **상호 배제(mutual exclusion)** 와 비슷하다.

반대로 직렬성 스냅숏 격리는 **낙관적** 동시성 제어 기법이다. 트랜잭션이 커밋되기를 원할 때 데이터베이스는 나쁜 상황이 발생했는지(즉 격리가 위반됐는지) 확인한다. 만약 그렇다면 트랜잭션은 어보트되고 재시도해야 한다.

낙관적 동시성 제어는 경쟁이 심하면 어보트시켜야할 트랜잭션의 비율이 높아지므로 성능이 떨어진다. 시스템이 이미 최대 처리량에 근접했다면 재시도되는 트랜잭션으로부터 발생하는 부가적인 트랜잭션 부하가 성능을 저하시킬 수 있다.

그러나 예비 용량이 충분하고 트랜잭션 사이의 경쟁이 너무 심하지 않으면 낙관적 동시성 제어 기법은 비관적 동시성 제어보다 성능이 좋은 경향이 있다.

이름이 나타내듯이 SSI 는 스냅숏 격리를 기반으로 한다. 즉 트랜잭션에서 실행되는 모든 읽기는 데이터베이스의 일관된 스냅숏을 보게 된다. 이게 이전의 낙관적 동시성 제어 기법과 크게 다른 점이다. SSI 는 스냅숏 격리 위에 쓰기 작업 사이의 직렬성 충돌을 감지하고 어보트시킬 트랜잭션을 결정하는 알고리즘을 추가한다.

#### 뒤쳐진 전체에 기반한 결정

스냅숏 격리하에서는 트랜잭션이 커밋되는 시점에 원래 질의의 결과가 더 이상 최신이 아닐 수 있다. 도중에 데이터가 변경됐을 수 있기 때문이다. 직렬성 격리를 제공하려면 데이터베이스는 트랜잭션이 뒤처진 전제를 기반으로 동작하는 상황을 감지하고 그런 상황에서는 트랜잭션을 어보트시켜야 한다.

- 오래된(stale) MVCC 객체 버전을 읽었는지 감지하기(읽기 전에 커밋되지 않은 쓰기가 발생했음)
- 과거의 읽기에 영향을 미치는 쓰기 감지하기(읽은 후에 쓰기가 실행됨)

#### 오래된 MVCC 읽기 감지하기

스냅숏 격리는 보통 다중 버전 동시성 제어([[MVCC]])로 구현한다는 점을 다시 떠올려보자. 데이터베이스는 트랜잭션이 MVCC 가시성 규칙에 따라 다른 트랜잭션의 쓰기를 무시하는 경우를 추적해야 한다. 트랜잭션이 커밋하려고 할 때 데이터베이스는 무시된 쓰기 중에 커밋된 게 있는지 확인해야 한다. 커밋된 게 있다면 트랜잭션은 어보트돼야 한다.

#### 과거의 읽기에 영향을 미치는 쓰기 감지하기

두 번째 경우는 데이터를 읽은 후 다른 트랜잭션에서 그 데이터를 변경할 때다.

트랜잭션이 데이터베이스에 쓸 때 영향받는 데이터를 최근에 읽은 트랜잭션이 있는지 색인에서 확인해야 한다. 이 과정은 영향받는 키 범위에 쓰기 잠금을 획득하는 것과 비슷하지만 읽는 쪽에서 커밋될 때까지 차단하지 않는다. 커밋하길 원할 때 충돌되는 쓰기가 이미 커밋됐다면 어보트된다.

#### 직렬성 스냅숏 격리의 성능

어떤 경우에는 다른 트랜잭션에서 덮어쓴 정보를 트랜잭션이 읽어도 괜찮다. 어떤 일이 있었는지에 따라 때로는 데이터가 덮어쓰여졌음에도 실행 결과가 직렬적이라는 것을 증명하는 게 가능하다. [[PostgreSQL]] 은 불필요한 어보트 개수를 줄이기 위해 이 이론을 사용한다.

2단계 잠금과 비교할 때 직렬성 스냅숏 격리의 큰 이점은 트랜잭션이 다른 트랜잭션들이 잡고 있는 잠금을 기다리느라 차단될 필요가 없다는 것이다. 스냅숏 격리하에서와 마찬가지로 쓰는 쪽은 읽는 쪽을 막지 않고 읽는 쪽도 쓰는 쪽을 막지 않는다. 특히 읽기 전용 질의는 어떤 잠금도 없이 일관된 스냅숏 위에서 실행될 수 있다. 읽기 작업부하가 심한 경우에 매우 매력적이다.

순차 실행과 비교할 때 직렬성 스냅숏 격리는 단일 CPU 코어의 처리량에 제한되지 않는다.

어보트 비율은 SSI 의 전체적인 성능에 큰 영향을 미친다. 이를테면 오랜 시간 동안 데이터를 읽고 쓰는 트랜잭션은 충돌이 나고 어보트되기 쉬워서 SSI 는 읽기 쓰기 트랜잭션이 상당히 짧기를 요구한다. 그러나 2단계 잠금이나 순차 실행보다는 느린 트랜잭션에 덜 민감할 것이다.

## Conclusion

트랜잭션은 애플리케이션이 어떤 동시성 문제와 어떤 종류의 하드웨어와 소프트웨어 결함이 존재하지 않는 것처럼 동작할 수 있게 도와주는 추상층이다.

아래 키워드를 다시 한 번 살펴보자.

- 더티 읽기
- 더티 쓰기
- 읽기 스큐(비반복 읽기)
- 갱신 손실
- 쓰기 스큐
- 팬텀 읽기

완화된 격리 수준은 이런 이상 현상 중 일부는 막아주지만 나머지는 애플리케이션 개발자가 수동으로 처리해야 한다. 직렬성 격리만 이 모든 문제들로부터 보호해준다. 직렬성 트랜잭션을 구현하는 세 가지 다른 방법을 설명했다.

- 순서대로 실행하기
- 2단계 잠금
- 직렬성 스냅숏 격리
