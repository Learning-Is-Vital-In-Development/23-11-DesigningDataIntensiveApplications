## 분산트랜잭션과 합의
합의는 분산 컴퓨팅에서 가장 중요하고 근본적인 문제 중 하나이다.
-> 노드들이 뭔가에 동의하게 만드는 것.
### 1. 노드가 동의하는 것이 중요한 상황
- 리더 선출 : 단일 리더 복제를 사용하는 db에서 모든 노드는 어떤 노드가 리더인지 동의해야한다. 
            이 경우 합의는 두노드가 자신이 리더라고 생각하는 스플릿 브레인을 유발할 수 있는 잘못된 장애 피하는데 중요.
- 원자적 커밋 : 여러 노드나 파티션에 걸친 트랜잭션을 지원하는 데이터베이스에는 트랜잭션이 어떤 노드에서는 성공하고
              어떤 노드에서는 실패할 수도 있는 문제가 있다. 트랜잭션 원자성을 유지하고 싶으면 모든 노드가 트랜잭션의 결과 동의하게 
              만들어야한다. 뭔가 잘못되면 모두 abort/rollback 잘못된게 없으면 commit -> 이런 합의문제를 원자적 커밋문제라함.
*합의 불가능성
- FLP결과 
1) 노드가 죽을 위험이 있다면 항상 합의에 이를 수 있는 알고리즘은 없다는 것을 증명한 것.
분산시스템에서는 노드가 죽을 수 있다고 가정해야되고 위의 정의에 따르면 신뢰성있는 합의는 불가능하다. 그럼에도 
우리는 여기서 합의를 얻는 알고리즘을 살펴보고 있다. 대체 무슨일인가...?
-> FLP결과는 어떤 시계나 타임아웃도 사용할 수 없는 결정적인 알고리즘을 가정하는 매우 제한된 모델인 비동기 시스템(306pg)에서 증명된다.
-> 알고리즘이 타임아웃을 쓰는게 허용되거나 죽은 것으로 의심되는 노드를 식별하는 다른 방법이 있다면 합의는 해결해진다. 
-> 알고리즘이 임의의 숫자를 사용하는 것을 허용하기만 해도 불가능성 결과를 회피하는데 충분하다.

원자적 커밋 문제를 더 자세히 살펴볼 것임
-> 2PC 알고리즘 (2단계 커밋) : 원자적 커밋을 해결하는 가장 흔한 방법이고 다양한DB, 메시징 시스템, 애플리케이션 서버에서 구현됨
-> 2PC를 통해 주키퍼(zab), etcd(raft)에서 쓰이는 더 좋은 합의 알고리즘을 볼 것임

### 2. 원자적 커밋과 2단계 커밋(2PC)
트랜잭션 원자성 목적은 7장에서 여러 쓰기를 실행하는 도중 뭔가 잘못되는 경우에 간단한 시맨틱을 제공하기 위함이라 했다.
트랜잭션 결과는 커밋 성공이나 어보트다. 커밋을 성공한 겨우 트랜잭션에서 쓴 내용은 모두 지속성으 ㄹ지니게 되며 어보트된 내용은 롤백된다.
원자성은 실패한 트랜잭션이 절반만 완료된 결과나 절반만 갱신된 상태로 데이터베이스를 어지럽히는 것을 막아준다.
 -> 이것은 다중 객체 트랜잭션과 보조 색인을 유지하는 데이터베이스에서 특히 중요하다. 
 -> 원자성은 보조 색인이 주 데이터와 일관성을 유지하도록 보장한다. 

### 3. 단일 노드에서 분산 원자적 커밋으로 

단일 노드에서 트랜잭션 커밋은 데이터가 디스크에 지속성 있게 쓰이는 순서에 결정적으로 의존한다.
-> 디스크가 커밋 레코드 쓰기를 마치는 시점에 커밋/어보트 결정됨
트랜잭션에 여러 노드가 관여한다면?
-> 파티셔닝된 데이터베이스에서 다중 객체 트랜잭션을 쓰거나 용어 파티셔닝된 보조 색인을 사용. 대부분의 NoSQL 분산데이터 스토어는 
   이런 분산 트랜잭션을 지원하지 않지만 다양한 클러스터 관계형 시스템은 지원한다.

모든 노드에 커밋 요청을 보내고 각 노드에서 독립적으로 트랜잭션을 커밋하는 것으로는 충분하지 않다.
어떤 노드에서는 커밋이 성공하고 다른 노드에서는 실패해서 원자성 보장을 위반하기 쉽다.
- 어떤 노드들은 어보트가 필요하지만, 다른 노드들은 성공적으로 커밋될 수 있다.
- 어떤 커밋 요청은 네트워크에서 손실되어 타임아웃 때문에 어보트될 수 있다.
- 어떤 노드들은 커밋 레코드가 완전히 쓰이기 전에 죽어서 복구할 때 롤백될 수 있다.

트랜잭션 커밋은 되돌릴 수 없어야 한다. 하지만 보상 트랜잭션이 취소하는 것은 가능하다.
보상 트랜잭션(compensating transaction) : 커밋된 트랜잭션의 효과를 나중에 다른 트랜잭션이 취소하는 것.


### 4. 2PC (2단계 커밋)
2PC는 여러 노드에 걸친 원자적 트랜잭션 커밋을 달성하는, 모든 노드가 커밋/어보트 되도록 보장하는 알고리즘. 
- 단일 노드 트랜잭션에서는 보통 존재하지 않는 새로운 컴포넌트인 코디네이터(coordinator)를 사용

    - 애플리케이션은 분산 트랜잭션을 시작하기 원할 때 coordinator에게 트랜잭션 ID를 요청한다.
    - 애플리케이션은 각 참여자에서 단일 노드 트랜잭션을 시작하고 단일 노드 트랜잭션에 전역적으로 유일한 트랜잭션 ID를 붙인다.
    - 각 노드에 준비 요청을 보내서 커밋할 수 있는지 "준비 요청"을 물어본다.

참가자는 트랜잭션을 커밋할 수 있는지 확인한다.
모두 네라고 응답했으면 coordinator는 커밋할지 안 할지 최종적 결정을 한다. 
추후 죽는 경우에 어떻게 결정했는지 알 수 있도록 그 결정을 디스크에 있는 트랜잭션 로그에 기록해야 한다. -> 커밋 포인트
커밋 포인트가 남으면 요청이 실패하거나 타임아웃이 될 때 성공할 때까지 영원히 재시도해야 한다.
아니요라고 한 노드라도 응답하면 2단계에서 모든 노드에 어보트를 보낸다.
-> 이 프로토콜에는 두개의 중대한 돌아갈 수 없느 ㄴ지저이 있다. 코디네이터가 한번 결정하면 그 결정은 변경할 수 없다.
-> 이러한 결정 때문에 2PC의 원자성을 보장한다. 
 
### 5. coordinator 장애
coordinator가 준비 요청을 보내고 나서 "네"에 투표한 다음 장애가 났다면, 참여자는 기다리기만 해야 한다.
이 상태에 있는 참여자의 트랜잭션을 in doubt 혹은 uncertain이라고 한다.
2PC가 완료할 수 있는 유일한 방법은 코디네이터가 복구되기를 기다리는 것뿐이다.
-> 코디네이터 로그에 커밋 레코드가 없는 트랜잭션은 어보트된다. 
-> 따라서 2PC의 커밋 포인트는 코디네이터에서 보통 단일 노드 원자적 커밋으로 내려온다.
 
### 6. 3PC (2PC의 대안으로 제안됨)
이론상으로는 노드에 장애가 나도 멈추지 않도록 원자적 커밋 프로토콜을 non-blocking하게 만들 수 있다.
하지만 기약 없는 네트워크 지연과 프로세스 중단이 있는 대부분 실용적 시스템에서 3PC는 원자성을 보장하지 못한다.
-> 일반적으로 논블로킹 원자적 커밋은 완벽한 장애 감지기(perfect failure detector) 노드가 죽었는지 안죽었는지 구별할 수 있는 신뢰성 매커니즘 필요
-> 기약 없는 지연이 있는 네트워크에서 타임아웃은 신뢰성 있는 장애 감지가 아니다. 아무 노드도 안죽었지만 단순 네트워크문제 때문일수도 있으므로
때문에 코디네이터 장애와 관련된 알려진 문제가 있는데도 2PC가 계속 쓰임.
 
### 7.현실의 분산 트랜잭션
분산 트랜잭션 특히 2PC로 구현된 분산 트랜잭션으로 평판이 엇갈림
    - 특정 분산 트랜잭션 => ex. MySQL의 경우, 10배 이상 느림.
두 종류의 분산 트랜잭션
    - 데이터베이스 내부 분산 트랜잭션 : 분산 DB에서 DB 노드 간 트랜잭션 지원 -> 아래의 방법보다 쉽고, 흔히 매우 잘 동작한다.
    - Heterogeneous 트랜잭션 : 서로 다른 벤더의 DB일 수도, 메시지 브로커처럼 비데이터베이스 시스템일 수도 있다.
    
 
### 8. 정확히 한 번 메시지 처리
이종 분산 트랜잭션
    - 메시지 큐에서 나온 메시지는 그 메시지를 처리하는 데이터베이스 트랜잭션 커밋에 성공 했을 때만 처리 된것으로 확인
    - 메시지 확인과 데이터베이스 쓰기를 단일 트랜잭션에서 원자적으로 커밋함으로써 구현할 수 있다.
메시지 전달이나 DB 트랜잭션 중 하나가 실패하면 둘 다 어보트되고 메시지 브로커는 나중에 메시지를 안전하게 재전달할 수 있다.
그러므로 메시지와 그 처리 과정의 side effect를 원자적으로 커밋함으로써 effectively exactly once 처리되도록 보장할 수 있다.
그렇지만 이런 분산 트랜잭션은 트랜잭션의 영향을 받는 모든 시스템이 동일한 원자적 커밋 프로토콜을 사용할 수 있을 때만 가능하다.
 
### 9 .XA Transaction(eXtended Architecture)
이종 기술에 걸친 2단계 커밋을 구현하는 표준.
XA는 네트워크 프로토콜이 아니라, 트랜잭션 코디네이터와 연결되는 인터페이스를 제공하는 API일 뿐이다.
드라이버가 XA를 지원한다는 것은 연산이 분산 트랜잭션의 일부가 돼야 하는지 알아내기 위해 XA API를 호출한다는 것을 뜻한다.
그리고 만약 그렇다면 드라이버는 DB 서버로 필요한 정보를 보낸다.
트랜잭션 코디네이터는 XA API를 구현한다.
 
### 10. 의심스러운 상태에 있는 동안 잠금을 유지하는 문제
트랜잭션이 의심스러운 상태에 빠지는 것이 왜 문제일까?
문제는 잠금과 관련이 있다. 데이터베이스 트랜잭션은 보통 더티 쓰기를 막기 위해 그들이 변경한 로우에 로우 수준의 독점적인 잠금을 획득한다.
추가로 직렬성 격리를 원한다면 2단계 잠금을 사용하는 데이터베이스는 트랜잭션에서 읽은 로우에 공유 잠금도 획득해야 한다.
데이터베이스는 트랜잭션이 커밋하거나 어보트할 때까지 이런 잠금을 해제할 수 없다.
그러므로 2단계 커밋을 사용할 때 트랜잭션은 의심스러운 상태에 있는 동안 내내 잠금을 잡고 있어야 한다.
잠금이 유지되는 동안 다른 어떤 트랜잭션도 그 로우를 변경할 수 없다. 데이터베이스에 따라 다른 트랜잭션이 로우를 읽지조차 못하게
차단할 수 있다. 

### 11. 코디네이터 장애에서 복구하기
이론상으로는 코디네이터가 죽은 후 재시작하면 로그로부터 그 상태를 깨끗하게 복구하고 의심스러운 트랜잭션을 해소해야 한다.
그러나 현실에서는 orphaned 의심스러운 트랜잭션, 즉 코디네이터가 어떤 이유 때문인지 그 결과를 결정할 수 없는 트랜잭션이 생길 수 있다.
이런 트랜잭션은 자동으로 해소될 수 없어서 잠금을 유지하고 다른 트랜잭션을 차단하면서 데이터베이스에 영원히 남는다.
여기서 빠져나가는 유일한 방법은 관리자가 수동으로 트랜잭션을 커밋하거나 롤백할지 결정하는 것뿐이다.
여러 XA 구현에는 참여자가 코디네이터로부터 확정적 결정을 얻지 않고 의심스러운 트랜잭션을 어보트하거나 커밋할지를 일방적으로 
결정할 수 있도록 하는 경험적 결정(heuristic decision)이라고 부르는 비상 탈출구가 있다.
 
### 12. 분산 트랜잭션의 제약
XA 트랜잭션은 여러 참여 데이터 시스템이 서로 일관성을 유지하게 하는 실제적이고 중요한 문제를 해결해 주지만 
지금까지 본 것처럼 XA 트랜잭션도 중요한 운영상 문제를 가져온다.
특히 핵심 구현은 트랜잭션 코디네이터 자체가 트랜잭션 결과를 저장할 수 있는 일종의 DB여야 한다는 점이고 
따라서 다른 중요한 DB와 동일하게 신경 써서 접근해야 한다.

코디네이터가 복제되지 않은 경우 단일 장애점(SPOF, single point of failure)가 될 수 있다.
    -> 여러 코디네이터의 구현은 기본적으로 고가용성을 제공하지 않거나 기초적인 복제만 제공
코디네이터가 애플리케이션 서버의 일부가 되면 배포의 특성이 바뀌어 코디네이터의 로그가 지속적인 시스템 상태의 중대한 부분이 된다. 
코디네이터 로그는 죽은 후에 의심스러운 트랜잭션을 복구하기 위해 필요하므로 DB 자체만큼 중요하다.

XA는 광범위한 데이터 시스템과 호환돼야 하므로 최소 공통분모가 될 필요가 있다.
    -> 여러 시스템에 걸친 교착상태를 감지할 수 없고 SSI함께 동작하지 않는다. 

2PC가 성공적으로 트랜잭션을 커밋하려면 모든 참여자가 응답해야한다.
결과적으로 시스템의 어떤 부분이라도 고장 나면 트랜잭션도 실패한다. 따라서 분산 트랜잭션은 장애를 증폭시키는 경향이 있다.

### 13. 내결함성을 지닌 합의
합의문제는 다음과 같이 형식화 됨
    - 하나 또는 그 이상의 노드들이 값을 제안할 수 있고 합의 알고리즘이 값 중 하나를 결정함
합의 알고리즘은 다음 속성을 만족해야함
    - 균일한 동의 : 어떤 두 노드도 다르게 결정하지 않는다.
    - 무결성 : 어떤 두 노드도 두번 결정하지 않는다.
    - 유효성 : 한 노드가 v를 결정한다면 v는 어떤 노드에서 제안된 것.
    - 종료 : 죽지 않는 모든 노드는 결국 어떤 값을 결정한다.
내결함성이 상관없다면 처음 세개의 속성 만족시키기 쉽다! 그냥 한 노드를 독재자로 하드코딩하고 노드가 모든 결정 내리게 하면 됨
    -> 노드 하나에 장애가 나면 그 시스템은 더 이상 어떤 결정도 내릴 수 없다. 
    (2PC에서 본 예시, 코디네이터에 장애가 나면 의심스러운 참여자들은 커밋할지 어보트할지 결정 X)
합의 시스템 모델은 노드가 죽으면 그 노드가 갑자기 사라져 결코 돌아오지 않는다 가정함. 
물론 모드 노드가 죽어서 아무 노드도 실행 중이 아니라면 어떤 알고리즘을 쓰든지 아무것도 결정할 수 없다. 
알고리즘이 견딜 수 있는 장애의 수에는 제한이 있다. 어떤 합의 알고리즘이라도 종료를 보장하려면 최소한의 노드의 과반수가 올바르게 동작해야한다.
    -> 과반수는 안전하게 정족수 형성 가능
따라서 종료 속성은 죽거나 연결할 수 없는 대수가 절반 미만이라는 가정에 종속적이다. 
그러나 대부분의 합의 구현은 과반수의 노드에 장애가 나거나 심각한 네트워크 문제가 있더라도 
안전성 속성 (동의, 무결성, 유효성)을 항상 만족한다. 


### 14. 합의 알고리즘과 전체 순서 브로드 캐스트
내결함성을 지닌 합의 알고리즘 중 가장 널리 알려진 것은 아래 알고리즘. 이 중 대다수는 실제로 여기서 설명한 
형식적 모델(동의 무결성 유효성 종료 속성을 만족하며 하나의 값을 제한하고 결정)을 직접 사용하지 않는다. 
대신 값의 순차열(sequence)에 대해 결정해서 앞장에서 설명한 전체 순서 브로드 캐스트 알고리즘을 만든다.
    - 뷰스탬프 복제(view stamped replication), 팍소스(pacts), 라프트(raft), 잽(zab)

### 15. 단일리더 복제와 합의
5장에서 모든 쓰기를 리더에게 전달하고 쓰기를 같은 순서로 팔로워에 적용해서 복제본이 최신 상태를 유지하게 하는 단일 리더 복제를 설명했다.
이것은 본질적으로 전체 순서 브로드캐스트가 아닌가? 왜 5장에서는 합의에 대해 걱정할 필요가 없었을까?
    -> 리더를 어떻게 선택하느냐에 답이 있다. 리더를 선출하려면 먼저 리더가 필요한 것처럼 보인다. 
       합의를 해결하려면 먼저 합의를 해결해야한다. 어떻게 이 난제에 대해서 벗어날 수 있나?

### 16. 에포크 번호 붙이기와 정족수
합의 프로토콜은 내부적으로 어떤 형태로든 리더를 사용하지만 리더가 유일하다고 보장하지X
대신 더 약한 보장으로 이 프로토콜은 epoch number를 정의하고 각 에포크 내에서 리더가 유일하다고 보장한다. 
 - 뷰스탬프 복제(view stamped replication), 팍소스(pacts), 라프트(raft), 잽(zab)

현재 리더가 죽었다고 생각될 때마다 새노드를 선출하기 위해 노드 사이에서 투표가 시작된다. 이 선출은 에포크 번호를 증가시키며 따라서 
에포크 번호는 전체 순서가 있고 단조 증가한다. 
    - 노드의 정족수로부터 투표를 받아야한다. 아래의 두번의 투표를 하는 정족수가 겹쳐야한다. 
        - 리더를 선출하기 위한 투표
        - 리더의 제안에 투표 
중요한 것은 제안에 대한 투표가 성공하면 그 제안에 투표한 노드 중 최소 하나는 가장 최근의 리더 선출에도 참여했어야 한다.
따라서 제안에 대한 투표를 할 때 에포크 번호가 더 큰 것이 있다고 밝혀지지 않았다면 
현재 리더는 에포크 번호가 더 높은 리더 선출이 발생하지 않았다고 결론을 내릴 수 있다.

이 투표 과정은 2PC와 비슷해 보이지만 가장 큰 차이는 
    - 2PC에서 코디네이터는 선출되지 않는다
    - 2PC는 모든 참여자로부터 네 투표가 필요하지만 내결함성을 지닌 합의 알고리즘은 노드의 과반수로부터만 투표를 받으면 된다.
    - 합의 알고리즘은 새로운 리더가 선출된 후 노드를 일관적인 상태로 만들어주는 복구 과정을 정의해 안전성 속성이 항상 만족됨.

### 17. 합의의 제약
합의 알고리즘 : 안전성 속성을 가져오고, 내결함성을 유지하지만 다양한 이슈가 있다.
    - 성능
    - 엄격한 과반수 동작으로 인한 비용
    - 네트워크 지연이 심한 경우 리더 선출에 시간을 더 쓸 수 있음
    - 그 외 (라프트 예시)

### 18. 멤버십과 코디네이션 서비스
주키퍼/etcd 
    - 분산 키-값 저장소 / 코디네티션 설정 서비스 라고 설명된다.
이것들이 기본적으로 데이터베이스라면 왜 합의 알고리즘을 구현하는데 무엇이 이것을 다른 종류의 데이터베이스와 다르게 만들까?
-> 주키퍼 살펴보자 
    - 다른 프로젝트를 통해 간접적으로 주키퍼에 의존하게 될 가능성이 높다.
        - HBase, Hadoop YARN, OpenStack Nova, Kafka 모두 배후에서 실행되는 주키퍼에 의존
    - 완전히 메모리 안에 들어올 수 있는 작은 양의 데이털르 보관하도록 설계됨 
    - 이 소량의 데이터는 내결함성을 지닌 전체 순서 브로드캐스트 알고리즘을 사용해 모든 노드에 걸쳐 복제된다. 
    - 앞에서 말했다 싶이 전체 순서 브로드 캐스트는 데이터베이스 복제에 딱 필요한 것임.
    - 개별 메시지가 데이터베이스에 쓰기를 나타낸다면 같은 쓰기를 같은 순서로 적용함으로써 복제본들이 서로 일관성을 유지할 수 있다.
    - 주키퍼는 유용한 기능 집합도 제공한다. (선형적 원자적 연산, 연산의 전체 순서화, 장애감지, 변경 알림)

### 19. 작업을 노드에 할당하기
주키퍼/처비 모델이 잘 동작하는 예 
    - 여러개의 프로세스나 서비스가 있고 그 중 하나가 리더나 주 구성요소로 선택돼야 할때, 리더에 장애가 나면 다른 노드 중 하나가 넘겨 받아야한다.
        - 이는 당연히 단일 리더 데이터베이스에 유용하지만 작업 스케줄러나 비슷한 상태 저장 시스템에서도 유용
    - 파티셔닝된 자원(데이터베이스, 메이지스트림, 파일 저장소, 분산 액터 시스템 등 )이 있고 어떤 파티션을 어느 노드에 할당할지 결정하는 경우
        - 새 노드들이 클러스터에 합류하면서 부하의 재균형화를 위해 어떤 파티션은 기존 노드에서 새로운 노드로 이동된다. 
            -> 주키퍼에서 원자적 연산, 단명노드, 알림을 신중하게 사용하면 하면 결함으로부터 자동으로 복구될 수 있지만 실패함.. 
                - 주키퍼 클라이언트 API위에서 고수준 도구를 제공하려고 생긴 아파치 큐레이터 같은 라이브러리가 등장했는데도!

### 20. 서비스 찾기
주키퍼, etcd, Consul은 Service Discovery, 즉 특정 서비스에 연결하려면 어떤 IP 주소로 접속해야하는지 알아내는 용도로 자주 사용된다. 
가상 장비가 지속적으로 들어왔다 나갔다 하는게 흔한 클라우드 데이터센터 환경에서 서비스의 ip주소를 사전에 알지 못할때가 자주있어 
서비스가 시작할 때 자신의 네트워크 종점을 서비스 등록소에 등록하도록 설정할 수 있다. 그러면 다른 서비스 등록소에서 서비스를 찾을 수 있다.
-> 하지만 서비스 찾기가 실제로 합의가 필요한지는 분명하지 x 
    - DNS는 서비스 이름으로 IP주소를 찾는 전통적인 방법이고 좋은 성능과 가용성을 달성하기 위해 다층 캐시를 사용한다.
서비스 찾기는 합의가 필요없지만 리더선출은 합의가 필요하다. 따라서 합의 시스템이 누가 리더인지 안다면
다른 서비스들이 리더를 찾는데 그 정보를 이용하는 것도 타당함. 

### 21. 멤버쉽 서비스 
주키퍼와 유사 프로젝트들은 오랜 membership service 연구 역사의 일부로 볼 수 있다.
멤버십 서비스는 클러스터에서 어떤 노드가 현재 활성화 되어있는 살아있는 멤버인지 결정한다. 
노드가 실제로 살아있지만 합의에 의해 죽은 것으로 잘못 선언될 가능성이 있다. 
그러나 합의는 시스템에서 어떤 노드가 현재 멤버십을 구성하는지 동의하는데 유용함
    - 예) 리더 선택을 현재 멤버들 중 번호가 가장 낮은 것을 선택하는 식으로 간단히 구현할 수도 있지만, 다른 노드와 현재 멤버가 누군지에 대한
        의견이 갈린다면 이방법은 동작하지 x



