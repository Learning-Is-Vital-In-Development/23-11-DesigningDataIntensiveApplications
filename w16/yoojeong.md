
### 분산 트랜젝션에서의 합의 (Consensus)

> 합의는 분산 컴퓨팅에서 가장 중요하고 근본적인 문제 중 하나다. 합의의 목적은 단지 ***여러 노드들이 뭔가에 동의하게 만드는 것***이다.<br>
분산시스템에서의 트랜젝션은 일련의 합의 알고리즘을 통해서 진행한다.<br>
대부분의 경우에는 비잔틴 문제를 해결하는 것을 시작으로 다양한 이점의 견고한 합의 알고리즘 이용한다.


### 원자적 커밋과 2단계 커밋(2PC)

> 원자성의 목적은 여러 쓰기를 실행하는 도중 뭔가 잘못되는 경우에 간단한 시맨틱을 제공하기 위함이다.

트랜잭션의 결과는 **커밋** 혹은 **어보트** 이다.

이런 원자성은 실패한 트랜잭션이 절반만 완료된 결과나 절반만 갱신된 상태로 데이터베이스를 어지럽히는 것을 막아준다.<br>
이 사실은 다중 객체 트랜잭션과 보조 색인을 유지하는 데이터베이스에서 특히 중요하다.

- 개별 보조 색인은 주 데이터와 분리된 자료구조이다.
- 따라서 데이터를 변경하면 그에 해당하는 변경은 보조 색인에도 반영되어야 한다.
- 결국 원자성은 보조 색인이 주 데이터와 일관성을 유지하도록 보장한다.

#### 단일 노드에서 분산 원자적 커밋으로

1. 단일 노드에서 트랜젝션 커밋

단일 데이터베이스 노드에서 실행되는 트랜잭션에게 원자성은 보통 저장소 엔진에서 구현된다.

- 클라이언트가 DB 노드에게 커밋하라고 요청
- 트랜잭션의 쓰기가 “지속성”을 가지게 한다. (쓰기 전 로그 (B트리))
    - 만약 여기서 DB가 죽으면 노드가 재시작 될 때, 쓰기 전 로그를 통해서 해당 트랜잭션을 복구한다.
    - 죽기 전 커밋 레코드가 디스크에 쓰여지는 게 성공했다면 트랜잭션이 커밋된 것으로 간주, 실패했다면 롤백

= 데이터가 먼저고 커밋 레코드는 그 다음이다.

단일 노드에서 트랜잭션 커밋 여부는 **디스크가 커밋레코드 쓰기를 마치는 시점**에 결정적으로 의존한다. <br>
커밋을 원자적으로 만들어주는 것은 단일 장치 (하나의 노드에 부탁된 단일 디스크 드라이브의 컨트롤러)이다.

2. 여러 노드가 트랜젝션에 관여

트랜잭션에 여러 노드가 관여되면 어떤 노드에서는 커밋이 성공하고 다른 노드에서는 실패해서 원자성 보장을 위반하기 쉽다.

- 어떤 노드들은 제약 조건 위반이나 충돌을 감지해서 어보트가 필요하게 되지만 다른 노드들은 성공적으로 커밋될 수 있다.
- 어떤 커밋 요청은 네트워크에서 손실되어 타임아웃 때문에 결국 어보트되지만 다른 커밋 요청은 전달될 수 있다.
- 어떤 노드는 커밋 레코드가 완전히 쓰여지기 전에 죽어서 복구할 때 롤백되지만 다른 노드는 성공적으로 커밋될 수 있다.

<br>
따라서 다중 노드간에 트랜잭션을 올바르게 사용하기 위해서는 아래와 같은 규칙이 필요하다.

- 노드는 트랜잭션에 참여하는 다른 모든 노드도 커밋될 것이라고 확신할 떄만 커밋 되어야 한다.
  - 어떤 노드는 커밋하고 어떤 노드는 어보트한다면 노드들이 서로 일관성이 없어진다.
  - 트랜잭션이 한번 커밋 되면 나중에 다른 노드에서 어보트 된게 밝혀지더라도 다시 취소할 수 없다.
- 트랜잭션 커밋은 되돌릴 수 없어야한다.
  - 데이터가 커밋되면 다른 트랜잭션에게 보이게 되고 다른 클라이언트들은 그 데이터에 의존하기 시작할 수도 있기 때문이다.
  - 트랜잭션이 커밋 된 후 어보트 되는게 허용 된다면, 커밋된 데이터를 읽은 트랜잭션들은 존재하지 않는 것으로 선언된 데이터를 의존하게 되는 상황이 벌어진다.

#### Two-Phase Commit

- 2단계 커밋은 여러 노드에 걸친 원자적 트랜잭션 커밋을 달성하는, 즉 모든 노드가 커밋되거나 모든 노드가 어보트되도록 보장되는 알고리즘이다.
- 일부 데이터베이스는 2PC가 내부적으로 사용되고 **XA 트랜잭션**의 형태나 SOAP 웹 서비스용 WS-AtomicTransaction을 통해 애플리케이션에서 사용할 수 있다.

<details>
    <summary>2PC와 2PL을 혼동하지 마라</summary>

- 2PC(2단계 커밋) : 분산데이터베이스에서 원자적 커밋을 제공
- 2PL(2단계 잠금) : 직렬성 격리를 제공

</details>

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/763c3ba2-5501-4d00-86ae-b5d8a2357f74)


단일 노드 트랜젝션에서처럼 하나의 커밋 요청을 하는 대신에 2PC의 커밋/어보트 과정은 **2단계(phase 1, phase 2)**로 나뉜다.

- 참여자 : 데이터를 읽고 쓰는 여러 데이터베이스 노드
- 코디네이터 : 트랜젝션 관리자로 ****트랜젝션을 요청하는 어플리케이션 프로세스 내에서 라이브러리 혹은 분리된 프로세스(서비스)로 구현됨

**트랜젝션 요청 과정**

- **준비 단계 (1단계)**
어플리케이션이 커밋할 준비가 되면 1단계를 시작한다. 
각 노드에 준비 요청을 보내 커밋할 수 있는지 묻고 코디네이터는 참여자들의 응답을 추적한다.
- **커밋 단계 (2단계)**
    - 모든 참여자가 준비 완료되었다면 코디네이터는 2단계에서 커밋 요청을 보내고 커밋을 실행한다.
    - 참여자 중 어떤 참여자가 준비가 안되었다면 코디네이터는 2단계에서 모든 노드에 어보트 요청을 보낸다.


#### 약속에 관한 시스템

2PC의 단계를 더 자세히 분석해보자.

1. 어플리케이션은 분산 트랜젝션을 시작할 때 코디네이터에게 트랜젝션 ID를 요청한다.
    
    이 트랜젝션 ID는 globally unique하다.
    
2. 어플리케이션은 각 참여자에서 단일 노드 트랜젝션을 시작하고 단일 노드 트랜젝션에 전역적으로 유일한 트랜젝션 ID를 붙인다.
    
    모든 읽기/쓰기는 이런 단일 노드 트랜젝션 중 하나에서 실행된다.
    
    이 단계에서 뭔가 잘못되면 코디네이터 혹은 참여자 중 누군가가 어보트할 수 있다.
    
3. 어플리케이션이 커밋할 준비가 되면 코디네이터는 모든 참여자에게 전역 트랜젝션 ID로 tagging된 준비 요청을 보낸다.
    
    이 요청 중 실패하거나 타임아웃된 것이 있으면 코디네이터는 모든 참여자에게 그 트랜젝션 ID로 어보트 요청을 보낸다.
    
4. ⚠️ 참여자가 준비 요청을 받으면 모든 상황에서 분명히 트랜젝션을 커밋할 수 있는지 확인한다.
    
    모든 트랜젝션 데이터를 디스크에 쓰는 것과 충돌/제약 조건 위반을 확인하는 과정이 포함된다.
    
    코디네이터에게 ‘네’라고 응답함으로써 노드는 요청이 있으면 트랜젝션을 오류 없이 커밋할 것이라고 약속하는 것이다.
    
    즉, 참여자들은 트랜젝션을 어보트할 권리를 포기하지만 실제로 커밋을 하는 것은 아니다.
    
5. 코디네이터가 모든 준비 요청에 응답을 받으면 트랜젝션을 커밋할 것인지 어보트할 것인지 최종적으로 결정한다.
    
    모든 참여자가 ‘네’에 투표할 때만 커밋한다.
    코디네이터는 추후 죽는 경우 어떻게 결정했는지 알 수 있도록 그 결정을 디스크에 있는 트랜젝션 로그에 기록한다. 이 기록을 **커밋 포인트**라고 한다.

6.  ⚠️ 코디네이터의 결정이 디스크에 쓰여지면 모든 참여자에게 커밋 혹은 어보트 요청이 전송된다.
    
    이 요청이 실패하거나 타임아웃되면 코디네이터는 성공할 때까지 계속 재시도한다.
    
    재시도를 몇 번 하든지 코디네이터의 결정은 변함없고 강제해야 한다.
    
    도중에 한 참여자가 죽었다면 트랜젝션은 그 참여자가 복구될 때 커밋된다.
    
    즉, 투표가 완료되고 결정이 나면 이 커밋을 거부할 수는 없다.


 ⚠️ **두 개의 돌아갈 수 없는 지점**

- 참여자가 ‘네’에 투표할 때 나중에 분명히 커밋할 것이라고 약속
- 코디네이터가 한 번 결정하면 그 결정은 변경할 수 없다.
### 내결함성을 지닌 합의

### 멤버십과 코디네이션 서비스
