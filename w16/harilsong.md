## 분산 트랜잭션과 합의

> 여러 노드들이 뭔가에 동의하게 만드는 것

### 원자적 커밋과 [[Two Phase Commit|2PC]]

- 코디네이터라고 불리는 트랜잭션 관리자를 사용
- 모든 참여자가 코디네이터에게 "네" 라고 응답해야 참여자들이 커밋할 수 있다
- 코디네이터는 모든 준비 요청에 대해 응답을 받았을 때 최종 결정을 하며, 이 때 디스크에 로그를 기록해야 한다. 이를 **커밋 포인트**라고 부른다.
- 코디네이터가 일종의 "독재자"가 되어 모든 결정을 내리기 때문에, 코디네이터가 죽는다면 데이터베이스가 제 구실을 못하게 될 위험이 있다

### 현실의 분산 트랜잭션

일부 분산 트랜잭션 구현은 무거운 성능 손해를 수반한다. 2단계 커밋에 내장된 성능 비용의 많은 부분은 장애 복구를 위해 필요한 부가적인 디스크 강제 쓰기(fsync) 와 부가적인 네트워크 왕복 시간 때문이다.

- 데이터베이스 내부 분산 트랜잭션
- 이종(heterogeneous) 분산 트랜잭션

#### 정확히 한 번 메시지 처리

메시지 큐에서 나온 메시지는 그 메시지를 처리하는 데이터베이스 트랜잭션이 커밋에 성공했을 때만 처리된 것으로 확인받을 수 있다. 메시지 확인과 데이터베이스 쓰기를 단일 트랜잭션에서 원자적으로 커밋함으로써 이를 구현할 수 있다.

- ? 메시지 큐에 메시지를 발행하는 동작은 http 통신인데 이게 롤백이 가능할까?
- ? [[Transactional Outbox Pattern]] 에 대한 이야기인가?

#### XA 트랜잭션

> X/Open XA(eXtended Architecture)

이종 기술에 걸친 2단계 커밋을 구현하는 표준

- XA 는 네트워크 프로토콜은 아님
- 트랜잭션 코디네이터와 연결되는 인터페이스를 제공하는 C API
- Java 에서는 Java Transaction API(JTA)를 사용해 구현되며 JTA 는 다시 [[JDBC]]를 사용하는 데이터베이스용 드라이버 다수와 자바 메세지 서비스(Java Message Service, [[JMS]]) 를 사용하는 메시지 브로커용 드라이버에서 지원

애플리케이션 프로세스가 죽거나 실행 중인 장비가 죽으면 코디네이터도 함께 사라진다. 그러면 준비됐지만 커밋되지 않은 트랜잭션들을 가진 참여자들은 의심스러운 상태에 빠지게 되며 코디네이터 라이브러리는 로그를 읽어서 각 트랜잭션의 커밋/어보트 결과를 복구해야 한다.

#### 의심스러운 상태에 있는 동안 잠금을 유지하는 문제

트랜잭션이 의심스러운 상태에 빠지는 것을 신경써야 하는 이유는 **잠금**과 관련이 있다. 데이터베이스는 트랜잭션이 커밋되거나 어보트할 때까지 잠금을 해제할 수 없으므로 2단계 커밋을 사용할 때 트랜잭션은 의심스러운 상태에 있는 동안 내내 잠금을 잡고 있어야 한다.

이는 **의심스러운 트랜잭션이 해소될 때까지 애플리케이션의 많은 부분을 사용할 수 없게 되는 원인**이 된다.

#### 코디네이터 장애에서 복구하기

이론상으로는 코디네이터가 죽은 후 재시작하면 로그로부터 그 상태를 깨끗하게 복구하고 의심스러운 트랜잭션을 해소해야 한다. 그러나 현실에서는 **고아가 된(orphaned)** 의심스러운 트랜잭션, 즉 코디네이터가 어떤 이유 때문인지 그 결과를 결정할 수 없는 트랜잭션이 생길 수 있다. 이런 트랜잭션은 자동으로 해소될 수 없어서 잠금을 유지하고 다른 트랜잭션을 차단하면서 데이터베이스에 영원히 남는다.

2PC 의 올바른 구현은 재시작을 하더라도 의심스러운 트랜잭션의 잠금을 유지해야하기 때문에(그렇지 않으면 원자성 보장을 위반할 위험이 있다), 데이터베이스 서버를 재부팅해도 이 문제를 고칠 수 없다.

여기서 빠져나가는 유일한 방법은 관리자가 수동으로 트랜잭션의 커밋하거나 롤백할지 결정하는 것 뿐이다. 이 문제를 해결하려면 잠재적으로 많은 수작업이 필요하고, 대부분 심각한 서비스 중단이 있는 도중에 스트레스가 높고 시간 압박이 있는 상태에서 처리해야할 가능성이 높다.

여러 XA 구현에는 참여자가 코디네이터로부터 확장적 결정을 얻지 않고 의심스러운 트랜잭션을 어보트하거나 커밋할지를 일방적으로 결정할 수 있도록 하는 **경험적 결정(heuristic decision)** 이라고 부르는 비상 탈출구가 있다. 이 말은 **아마도 원자성을 깰 수 있다**를 완곡하게 표현한 것이다. 큰 장애 상황을 벗어나고자 할 때만 쓰도록 의도된 것이다.

#### 분산 트랜잭션의 제약

- 트랜잭션 코디네이터 자체가 트랜잭션 결과를 저장할 수 있는 일종의 데이터베이스여야 한다.
- 따라서 코디네이터가 복제되지 않고 단일 장비에서만 실행되면 단일 장애 지점(Single Point Of Failure, [[SPOF]]) 가 된다.
- 코디네이터의 로그가 지속적인 시스템 상태의 중대한 부분이 된다. (Stateless -> Stateful)
- XA 는 광범위한 데이터 시스템과 호환돼야 하므로 최소 공통 분모가 될 필요가 있다.
- 2PC 가 성공하려면 **모든** 참여자가 응답해야 한다. 결과적으로 시스템의 **어떤** 부분이라도 고장나면 트랜잭션도 실패한다. 따라서 분산 트랜잭션은 **장애를 증폭시키는** 경향이 있으며 이는 내결함성을 지닌 시스템을 구축하려는 목적에 어긋난다.

### 내결함성을 지닌 합의

- 균일한 동의
- 무결성
- 유효성
- 종료

#### 합의 알고리즘과 전체 순서 브로드캐스트

내결함성을 지닌 합의 알고리즘 중 가장 널리 알려진 것은

- 뷰스탬프 복제(Viewstamped Replication, VSR)
- 팍소스(Paxos)
- 라프트(Raft)
- 잽(Zab)

> 전체 순서 브로드캐스트를 하려면 모든 노드에게 메시지가 정확히 한 번, 같은 순서로 전달돼야 한다.

- 합의의 동의 속성 때문에 모든 노드는 같은 메시지를 같은 순서로 전달하도록 결정한다.
- 무결성 속성 때문에 메시지는 중복되지 않는다.
- 유효성 속성 때문에 메시지는 오염되지 않고 난데없이 조작되지 않는다.
- 종료 속성 때문에 메시지는 손실되지 않는다.

#### 단일 리더 복제와 합의

모든 쓰기를 리더에게 전달하고 쓰기를 같은 순서로 팔로워에 적용해서 복제본이 최신 상태를 유지하게 하는 단일 리더 복제는 본질적으로 전체 순서 브로드캐스트가 아닌가?

차이는 **리더를 어떻게 선택하느냐**에 있다. 리더를 운영팀에 있는 사람이 수동으로 선택해서 설정한다면 본질적으로는 독재자 방식의 "합의 알고리즘"을 사용하는 것이다. 이런 시스템은 현실에서는 잘 동작하지만 진행하기 위해 사람의 개입이 필요하므로 합의의 종료 속성을 만족하지 않는다.

[[Split Brain]] 문제를 설명했고 모든 노드들이 누가 리더인지 동의해야 한다고 했다. 그렇지 않으면 결과적으로 데이터베이스가 일관성이 깨진 상태가 된다. 따라서 리더를 선출하려면 합의가 필요하다. 그러나 여기서 설명한 합의 알고리즘이 실제로는 전체 순서 브로드캐스트 알고리즘이라면 전체 순서 브로드캐스트는 단일 리더 복제와 같고 단일 리더 복제는 리더가 필요하고, 그러면...

리더를 선출하려면 먼저 리더가 필요한 것처럼 보인다. 이 난제에서 어떻게 벗어날 수 있을까?

#### 에포크 번호 붙이기와 정족수

리더가 죽었다고 생각될 때마다 새 노드를 선출하기 위해 투표가 시작된다. 이 선출은 번호를 증가시키며 두 가지 다른 에포크(epoch)에 있는 두 가지 다른 리더 사이에 충돌이 있으면 에포크 번호가 높은 리더가 이긴다.

리더는 자신이 다른 노드에 의해 쫓겨나지 않았다는 것을 어떻게 알 수 있을까? 노드의 **정족수**로부터 투표를 받아야 한다.

따라서 두 번의 투표가 있다. 한 번은 리더를 선출하기 위해, 두 번째는 리더의 제안에 투표하기 위해. 중요한 것은 두 번의 투표를 하는 정족수가 겹쳐야 한다는 점이다. 제안에 대한 투표가 성공하면 그것에 투표한 노드 중 최소 하나는 가장 최근의 리더 선출에도 참여했어야 한다.

#### 합의의 제약

### 멤버십과 코디네이션 서비스

#### 작업을 노드에 할당하기

#### 서비스 찾기

#### 멤버십 서비스

