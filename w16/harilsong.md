
## 분산 트랜잭션과 합의

> 여러 노드들이 뭔가에 동의하게 만드는 것

### 원자적 커밋과 [[Two Phase Commit|2PC]]

- 코디네이터라고 불리는 트랜잭션 관리자를 사용
- 모든 참여자가 코디네이터에게 "네" 라고 응답해야 참여자들이 커밋할 수 있다
- 코디네이터는 모든 준비 요청에 대해 응답을 받았을 때 최종 결정을 하며, 이 때 디스크에 로그를 기록해야 한다. 이를 **커밋 포인트**라고 부른다.
- 코디네이터가 일종의 "독재자"가 되어 모든 결정을 내리기 때문에, 코디네이터가 죽는다면 데이터베이스가 제 구실을 못하게 될 위험이 있다

### 현실의 분산 트랜잭션

#### 정확히 한 번 메시지 처리

#### XA 트랜잭션

#### 의심스러운 상태에 있는 동안 잠금을 유지하는 문제

#### 코디네이터 장애에서 복구하기

#### 분산 트랜잭션의 제약

### 내결함성을 지닌 합의

- 균일한 동의
- 무결성
- 유효성
- 종료

#### 합의 알고리즘과 전체 순서 브로드캐스트

내결함성을 지닌 합의 알고리즘 중 가장 널리 알려진 것은 

- 뷰스탬프 복제(Viewstamped Replication, VSR)
- 팍소스(Paxos)
- 라프트(Raft)
- 잽(Zab)

> 전체 순서 브로드캐스트를 하려면 모든 노드에게 메시지가 정확히 한 번, 같은 순서로 전달돼야 한다.

- 합의의 동의 속성 때문에 모든 노드는 같은 메시지를 같은 순서로 전달하도록 결정한다.
- 무결성 속성 때문에 메시지는 중복되지 않는다.
- 유효성 속성 때문에 메시지는 오염되지 않고 난데없이 조작되지 않는다.
- 종료 속성 때문에 메시지는 손실되지 않는다.

#### 단일 리더 복제와 합의

모든 쓰기를 리더에게 전달하고 쓰기를 같은 순서로  팔로워에 적용해서 복제본이 최신 상태를 유지하게 하는 단일 리더 복제는 본질적으로 전체 순서 브로드캐스트가 아닌가?

차이는 **리더를 어떻게 선택하느냐**에 있다. 리더를 운영팀에 있는 사람이 수동으로 선택해서 설정한다면 본질적으로는 독재자 방식의 "합의 알고리즘"을 사용하는 것이다. 이런 시스템은 현실에서는 잘 동작하지만 진행하기 위해 사람의 개입이 필요하므로 합의의 종료 속성을 만족하지 않는다.

[[Split Brain]] 문제를 설명했고 모든 노드들이 누가 리더인지 동의해야 한다고 했다. 그렇지 않으면 결과적으로 데이터베이스가 일관성이 깨진 상태가 된다. 따라서 리더를 선출하려면 합의가 필요하다. 그러나 여기서 설명한 합의 알고리즘이 실제로는 전체 순서 브로드캐스트 알고리즘이라면 전체 순서 브로드캐스트는 단일 리더 복제와 같고 단일 리더 복제는 리더가 필요하고, 그러면...

리더를 선출하려면 먼저 리더가 필요한 것처럼 보인다. 이 난제에서 어떻게  벗어날 수 있을까?

#### 에포크 번호 붙이기와 정족수

리더가 죽었다고 생각될 때마다 새 노드를 선출하기 위해 투표가 시작된다. 이 선출은 번호를 증가시키며 두 가지 다른 에포크(epoch)에 있는 두 가지 다른 리더 사이에 충돌이 있으면 에포크 번호가 높은 리더가 이긴다.

리더는 자신이 다른 노드에 의해 쫓겨나지 않았다는 것을 어떻게 알 수 있을까? 노드의 **정족수**로부터 투표를 받아야 한다.

따라서 두 번의 투표가 있다. 한 번은 리더를 선출하기 위해, 두 번째는 리더의 제안에 투표하기 위해. 중요한 것은 두 번의 투표를 하는 정족수가 겹쳐야 한다는 점이다. 제안에 대한 투표가 성공하면 그것에 투표한 노드 중 최소 하나는 가장 최근의 리더 선출에도 참여했어야 한다.

#### 합의의 제약

### 멤버십과 코디네이션 서비스

#### 작업을 노드에 할당하기

#### 서비스 찾기

#### 멤버십 서비스

