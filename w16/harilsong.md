## 분산 트랜잭션과 합의

> 여러 노드들이 뭔가에 동의하게 만드는 것

### 원자적 커밋과 [[Two Phase Commit|2PC]]

- 코디네이터라고 불리는 트랜잭션 관리자를 사용
- 모든 참여자가 코디네이터에게 "네" 라고 응답해야 참여자들이 커밋할 수 있다
- 코디네이터는 모든 준비 요청에 대해 응답을 받았을 때 최종 결정을 하며, 이 때 디스크에 로그를 기록해야 한다. 이를 **커밋 포인트**라고 부른다.
- 코디네이터가 일종의 "독재자"가 되어 모든 결정을 내리기 때문에, 코디네이터가 죽는다면 데이터베이스가 제 구실을 못하게 될 위험이 있다

### 현실의 분산 트랜잭션

일부 분산 트랜잭션 구현은 무거운 성능 손해를 수반한다. 2단계 커밋에 내장된 성능 비용의 많은 부분은 장애 복구를 위해 필요한 부가적인 디스크 강제 쓰기(fsync) 와 부가적인 네트워크 왕복 시간 때문이다.

- 데이터베이스 내부 분산 트랜잭션
- 이종(heterogeneous) 분산 트랜잭션

#### 정확히 한 번 메시지 처리

메시지 큐에서 나온 메시지는 그 메시지를 처리하는 데이터베이스 트랜잭션이 커밋에 성공했을 때만 처리된 것으로 확인받을 수 있다. 메시지 확인과 데이터베이스 쓰기를 단일 트랜잭션에서 원자적으로 커밋함으로써 이를 구현할 수 있다.

- ? 메시지 큐에 메시지를 발행하는 동작은 http 통신인데 이게 롤백이 가능할까?
- ? [[Transactional Outbox Pattern]] 에 대한 이야기인가?

#### XA 트랜잭션

> X/Open XA(eXtended Architecture)

이종 기술에 걸친 2단계 커밋을 구현하는 표준

- XA 는 네트워크 프로토콜은 아님
- 트랜잭션 코디네이터와 연결되는 인터페이스를 제공하는 C API
- Java 에서는 Java Transaction API(JTA)를 사용해 구현되며 JTA 는 다시 [[JDBC]]를 사용하는 데이터베이스용 드라이버 다수와 자바 메세지 서비스(Java Message Service, [[JMS]]) 를 사용하는 메시지 브로커용 드라이버에서 지원

애플리케이션 프로세스가 죽거나 실행 중인 장비가 죽으면 코디네이터도 함께 사라진다. 그러면 준비됐지만 커밋되지 않은 트랜잭션들을 가진 참여자들은 의심스러운 상태에 빠지게 되며 코디네이터 라이브러리는 로그를 읽어서 각 트랜잭션의 커밋/어보트 결과를 복구해야 한다.

#### 의심스러운 상태에 있는 동안 잠금을 유지하는 문제

트랜잭션이 의심스러운 상태에 빠지는 것을 신경써야 하는 이유는 **잠금**과 관련이 있다. 데이터베이스는 트랜잭션이 커밋되거나 어보트할 때까지 잠금을 해제할 수 없으므로 2단계 커밋을 사용할 때 트랜잭션은 의심스러운 상태에 있는 동안 내내 잠금을 잡고 있어야 한다.

이는 **의심스러운 트랜잭션이 해소될 때까지 애플리케이션의 많은 부분을 사용할 수 없게 되는 원인**이 된다.

#### 코디네이터 장애에서 복구하기

이론상으로는 코디네이터가 죽은 후 재시작하면 로그로부터 그 상태를 깨끗하게 복구하고 의심스러운 트랜잭션을 해소해야 한다. 그러나 현실에서는 **고아가 된(orphaned)** 의심스러운 트랜잭션, 즉 코디네이터가 어떤 이유 때문인지 그 결과를 결정할 수 없는 트랜잭션이 생길 수 있다. 이런 트랜잭션은 자동으로 해소될 수 없어서 잠금을 유지하고 다른 트랜잭션을 차단하면서 데이터베이스에 영원히 남는다.

2PC 의 올바른 구현은 재시작을 하더라도 의심스러운 트랜잭션의 잠금을 유지해야하기 때문에(그렇지 않으면 원자성 보장을 위반할 위험이 있다), 데이터베이스 서버를 재부팅해도 이 문제를 고칠 수 없다.

여기서 빠져나가는 유일한 방법은 관리자가 수동으로 트랜잭션의 커밋하거나 롤백할지 결정하는 것 뿐이다. 이 문제를 해결하려면 잠재적으로 많은 수작업이 필요하고, 대부분 심각한 서비스 중단이 있는 도중에 스트레스가 높고 시간 압박이 있는 상태에서 처리해야할 가능성이 높다.

여러 XA 구현에는 참여자가 코디네이터로부터 확장적 결정을 얻지 않고 의심스러운 트랜잭션을 어보트하거나 커밋할지를 일방적으로 결정할 수 있도록 하는 **경험적 결정(heuristic decision)** 이라고 부르는 비상 탈출구가 있다. 이 말은 **아마도 원자성을 깰 수 있다**를 완곡하게 표현한 것이다. 큰 장애 상황을 벗어나고자 할 때만 쓰도록 의도된 것이다.

#### 분산 트랜잭션의 제약

- 트랜잭션 코디네이터 자체가 트랜잭션 결과를 저장할 수 있는 일종의 데이터베이스여야 한다.
- 따라서 코디네이터가 복제되지 않고 단일 장비에서만 실행되면 단일 장애 지점(Single Point Of Failure, [[SPOF]]) 가 된다.
- 코디네이터의 로그가 지속적인 시스템 상태의 중대한 부분이 된다. (Stateless -> Stateful)
- XA 는 광범위한 데이터 시스템과 호환돼야 하므로 최소 공통 분모가 될 필요가 있다.
- 2PC 가 성공하려면 **모든** 참여자가 응답해야 한다. 결과적으로 시스템의 **어떤** 부분이라도 고장나면 트랜잭션도 실패한다. 따라서 분산 트랜잭션은 **장애를 증폭시키는** 경향이 있으며 이는 내결함성을 지닌 시스템을 구축하려는 목적에 어긋난다.

### 내결함성을 지닌 합의

- 균일한 동의
- 무결성
- 유효성
- 종료

#### 합의 알고리즘과 전체 순서 브로드캐스트

내결함성을 지닌 합의 알고리즘 중 가장 널리 알려진 것은

- 뷰스탬프 복제(Viewstamped Replication, VSR)
- 팍소스(Paxos)
- 라프트(Raft)
- 잽(Zab)

> 전체 순서 브로드캐스트를 하려면 모든 노드에게 메시지가 정확히 한 번, 같은 순서로 전달돼야 한다.

- 합의의 동의 속성 때문에 모든 노드는 같은 메시지를 같은 순서로 전달하도록 결정한다.
- 무결성 속성 때문에 메시지는 중복되지 않는다.
- 유효성 속성 때문에 메시지는 오염되지 않고 난데없이 조작되지 않는다.
- 종료 속성 때문에 메시지는 손실되지 않는다.

#### 단일 리더 복제와 합의

모든 쓰기를 리더에게 전달하고 쓰기를 같은 순서로 팔로워에 적용해서 복제본이 최신 상태를 유지하게 하는 단일 리더 복제는 본질적으로 전체 순서 브로드캐스트가 아닌가?

차이는 **리더를 어떻게 선택하느냐**에 있다. 리더를 운영팀에 있는 사람이 수동으로 선택해서 설정한다면 본질적으로는 독재자 방식의 "합의 알고리즘"을 사용하는 것이다. 이런 시스템은 현실에서는 잘 동작하지만 진행하기 위해 사람의 개입이 필요하므로 합의의 종료 속성을 만족하지 않는다.

[[Split Brain]] 문제를 설명했고 모든 노드들이 누가 리더인지 동의해야 한다고 했다. 그렇지 않으면 결과적으로 데이터베이스가 일관성이 깨진 상태가 된다. 따라서 리더를 선출하려면 합의가 필요하다. 그러나 여기서 설명한 합의 알고리즘이 실제로는 전체 순서 브로드캐스트 알고리즘이라면 전체 순서 브로드캐스트는 단일 리더 복제와 같고 단일 리더 복제는 리더가 필요하고, 그러면...

리더를 선출하려면 먼저 리더가 필요한 것처럼 보인다. 이 난제에서 어떻게 벗어날 수 있을까?

#### 에포크 번호 붙이기와 정족수

리더가 죽었다고 생각될 때마다 새 노드를 선출하기 위해 투표가 시작된다. 이 선출은 번호를 증가시키며 두 가지 다른 에포크(epoch)에 있는 두 가지 다른 리더 사이에 충돌이 있으면 에포크 번호가 높은 리더가 이긴다.

리더는 자신이 다른 노드에 의해 쫓겨나지 않았다는 것을 어떻게 알 수 있을까? 노드의 **정족수**로부터 투표를 받아야 한다.

따라서 두 번의 투표가 있다. 한 번은 리더를 선출하기 위해, 두 번째는 리더의 제안에 투표하기 위해. 중요한 것은 두 번의 투표를 하는 정족수가 겹쳐야 한다는 점이다. 제안에 대한 투표가 성공하면 그것에 투표한 노드 중 최소 하나는 가장 최근의 리더 선출에도 참여했어야 한다.

#### 합의의 제약

합의 알고리즘은 불확실한 시스템에 구체적인 안정성 속성을 가져오고, 내결함성도 유지한다. 전체 순서 브로드캐스트를 제공하고 따라서 내결함성 있는 방식으로 선형성 원자적 연산을 구현할 수도 있다.

합의 알고리즘이 모든 곳에 쓰이지는 않는다.

- 데이터베이스는 종종 비동기 복제를 사용하도록 설정되며, 이런 설정에서 커밋된 데이터는 장애 복구 시 잠재적으로 손실될 수 있다. **더 나은 성능과 트레이드오프** 된다.
- 합의 시스템은 항상 엄격한 과반수가 동작하기를 요구한다.
- 대부분의 합의 알고리즘은 투표에 참여하는 노드 집합이 고정돼 있다고 가정하며 이는 클러스터에 노드를 그냥 추가하거나 제거할 수 없다는 뜻이다.
    - **동적 멤버십(dynamic membership)** 확장은 노드 집합이 변하는 것을 허용하지만 훨씬 어렵다.
- 장애 노드를 감지하기 위해 **타임아웃에 의존**한다. 일시적인 네트워크 문제 때문에 잦은 리더 선출이 발생할 수 있고, 결과적으로 끔찍한 성능 문제가 발생할 수 있다.

### 멤버십과 코디네이션 서비스

주키퍼([[Jookeeper]]), [[etcd]] 같은 프로젝트는 종종 '분산 키-값 저장소'나 '코디네이션과 설정 서비스'라고 설명된다.

이들은 메모리 안에 들어올 수 있는 작은 양의 데이터를 보관하도록 설계됐다. 이 소량의 데이터는 내결함성을 지닌 전체 순서 브로드캐스트 알고리즘을 사용해 모든 노드에 걸쳐 복제된다. 앞서 설명했듯이 **전체 순서 브로드캐스트는 데이터베이스 복제에 딱 필요한 것**이다. 개별 메시지가 데이터베이스에 쓰기를 나타낸다면 같은 쓰기를 같은 순서로 적용함으로써 복제본들이 서로 일관성을 유지할 수 있다.

주키퍼는 전체 순서 브로드캐스트뿐만 아니라 분산 시스템을 구축할 때 특히 유용한 기능도 구현한다.

- 선형성 원자적 연산(compare-and-set) - 합의가 필요한 유일한 부분
- 연산의 전체 순서화
- 장애 감지
- 변경 알림

이 기능들의 조합이 주키퍼를 분산 코디네이션에 매우 적합한 프로젝트로 만들어준다.

다만 주키퍼는 범용 데이터베이스로는 적합하지 않기 때문에 애플리케이션 개발자로서 주키퍼를 직접 다뤄야할 경우는 많지 않다. 아마도 다른 프로젝트를 통해 간접적으로 주키퍼에 의존하게 될 것이다.

#### 작업을 노드에 할당하기

주키퍼를 유용하게 사용할 수 있는 사례를 설명한다.

- 여러 개의 프로세스나 서비스가 있고 그중 하나가 리더나 주 구성요소로 선택돼야 할 때
- 파티셔닝된 자원이 있고 어떤 파티션을 어느 노드에 할당해야 할지 결정해야 할 때
- 수천 대 이상이 될 수도 있는 노드에서 투표를 수행하는 것은 매우 비효율적이기에 주키퍼는 고정된 노드들 사이에서 과반수 투표를 수행한다. 따라서 주키퍼는 노드들을 코디네이트하는 작업의 일부를 외부 서비스에 "위탁"하는 방법을 제공한다.

> [!NOTE]
> 주키퍼로 관리되는 데이터의 종류는 매우 느리게 변한다고 가정된 상태로 설계되었다. 애플리케이션의 런타임 상태를 다른 노드로 복제해야한다면 다른 도구([[Apache BookKeeper]])를 사용하는게 낫다.

#### 서비스 찾기(Service discovery)

주키퍼, etcd, [[Consul]] 은 서비스 찾기(service discovery), 즉 특정 서비스에 연결하려면 어떤 IP 주소로 접속해야 하는지 알아내는 용도로도 자주 사용된다.

DNS 는 서비스 이름으로 IP 주소를 찾는 전통적인 방법이고 좋은 성능과 가용성을 달성하기 위해 다층 캐시를 사용한다. DNS 질의의 결과가 조금 뒤처질 수 있지만, 신뢰성 있게 사용 가능하고 네트워크 끊김에 견고하다는게 더 중요하다.

서비스 찾기는 합의가 필요 없지만 리더 선출은 합의가 필요하다. 합의 시스템이 누가 리더인지 알고 있다면 다른 서비스들이 리더가 누구인지 찾는데 그 정보를 활용할 수 있다. 이런 목적으로 합의 시스템은 읽기 전용 복제 서버를 지원하며, 이 복제 서버에 저장된 리더에 대한 정보를 바탕으로 선형적일 필요가 없는 읽기 요청을 서비스할 수 있다. (??)

#### 멤버십 서비스

멤버십 서비스는 클러스터에서 어떤 노드가 활성화된 멤버인지 결정한다. 이 장애 감지를 합의와 연결하면 노드들은 어떤 노드의 상태에 대해 투표할 수 있다.

여전히 노드가 살아있지만 합의에 의해 죽은 것으로 잘못 선언될 가능성이 있다. 그럼에도 합의는 시스템에서 어떤 노드가 현재 멤버십을 구성하는지(=클러스터의 구성원인지) 인식하는 데 매우 유용하다. 예를 들어 리더 선택을 현재 멤버들 중 번호가 가장 낮은 것을 선택하는 식으로 간단하게 구현할 수 있지만 다른 노드와 현재 멤버가 누군지에 대해 의견이 갈린다면 이 방법은 동작하지 않는다(가장 낮은 번호를 가진 멤버에 대해 의견이 갈릴 수 있으므로).

## 정리

- 선형성을 이해하기 쉽지만, 느리다는 단점이 있다.
- 인과성은 선형성보다 더 약한 일관성 모델을 제공하지만 선형성의 코디네이션 오버헤드가 없고, 네트워크 문제에 덜 민감하다.
- 램포드 타임스탬프 등으로 인과적 순서를 담아내더라도 어떤 것들은 이 방법을 사용할 수 없다. 이 문제가 우리를 **합의**로 이끈다.
- 합의를 달성하는 것은 결정된 것에 모든 노드가 동의하고 결정을 되돌릴 수 없는 방식으로 뭔가를 결정한다는 뜻이다.
- **선형성 compare-and-set 레지스터**: 레지스터는 현재 값이 연산의 매개변수로 넘겨진 값과 같은지 여부에 따라 값을 설정할지 말지 원자적으로 **결정**해야 한다.
- **원자적 트랜잭션 커밋**: 데이터베이스는 분산 트랜잭션을 커밋할 것인지 어보트할 것인지 **결정**해야 한다.
- **전체 순서 브로드캐스트**: 메시징 시스템은 메시지를 전달할 순서를 **결정**해야 한다.
- **잠금과 임차권**: 여러 클라이언트들이 잠금이나 임차권을 얻기 위해 경쟁하고 있을 때 잠금은 누가 성공적으로 잠금을 획득할지 **결정**한다.
- **멤버십/코디네이션 서비스**: 장애 감지기가 주어지면 시스템은 어떤 노드는 살아있고 어떤 노드는 세션 타임아웃이 발생해서 죽었다고 생각돼야 하는지를 **결정**해야 한다.
- **유일성 제약 조건**: 여러 트랜잭션들이 동시에 같은 키로 충돌되는 레코드를 생성하려고 할 대 이 제약 조건은 어떤 것을 허용하고 어떤 것을 제약 조건 위반으로 실패하도록 할 것인지 **결정**해야 한다.

단일 리더 데이터베이스라면 간단하다. 모든 것들을 리더가 결정하기 때문에, 단일 리더 데이터베이스는 선형성 연산과 유일성 제약 조건, 전체 순서가 정해진 복제 로그 등을 제공할 수 있다.

그러나 그 단일 리더에 장애가 발생하면 이런 시스템은 아무 진행도 하지 못하게 된다. 이런 상황을 처리하는 방법은 세 가지가 있다.

1. 리더가 복구될 때까지 기다리고 시스템이 그동안 차단되는 것을 받아들인다.
2. 사람이 직접 새 리더 노드를 선택하고 재설정해서 수동으로 장애 복구를 한다.
3. 자동으로 새 리더를 선택하는 알고리즘을 사용한다.

단일 리더 데이터베이스여도 리더를 변경하려면 합의가 필요하다.

주키퍼 같은 도구는 합의, 장애 감지, 멤버십 서비스를 위탁하는데 중요한 역할을 수행한다.

모든 시스템이 반드시 합의가 필요한 것은 아니다. 리더 없는 복제 시스템과 다중 리더 복제 시스템은 보통 전역 합의를 사용하지 않는다. 이런 시스템에서 발생하는 충돌은 합의가 없어서 생긴 결과지만 데이터를 잘 처리하는 법을 배운다면 괜찮다.

