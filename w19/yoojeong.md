## 스트림 처리

일괄처리는 입력의 변화가 일정 시간이 지나야 반영된다는 문제가 있다.<br>
실시간성이 중요한 서비스에서 이런 지연은 치명적이고, 이를 해결하기 위해 스트림 처리가 등장했다.

"스트림"이란 시간 흐름에 따라 점진적으로 생산된 데이터이다.<br>
유닉스의 stdin / stdout, 프로그래밍 언어(느긋한 리스트(lazy lists)), 자바의 FileInputStream, TCP,오디오와 비디오 전송 등


### 이벤트 스트림 전송

||일괄처리|스트림처리|
|:--:|:--|:--|
|입력|파일|이벤트|
|변환|레코드의 연속으로 변환|텍스트문자열/JSON/이진 형태 등으로 부호화|
|소비|한번 기록하면 여러 작업에서 읽기 가능|생산자(producer/publisher)가 이벤트를 만들면 복수의 소비자(consumer, subscriber)가 처리 가능|
|식별|관련 레코드 집합을 파일 이름으로 식별|토픽이나 스트림으로 관련 이벤트를  묶는다|

이론상 DB와 폴링으로 스트리밍이 가능하지만 지연성이 낮아야할수록 폴링이 잦아지고, 커넥션 등 오버헤드가 커진다.
또한 새로운 이벤트마다 노티를 주는 방식도, 데이터베이스의 트리거를 사용할 수 있지만 기능이 제한적이다.

### 메시징 시스템

새로운 이벤트를 소비자에게 알려주는 일반적인 방법으로 메시징 시스템(messaging system)이 있다. 
메시징 시스템을 구축하는 가장 간단한 방법은 생산자와 소비자 사이에 유닉스 파이프나 TCP 연결과 같은 직접 통신 채널을 사용하는 것으로,  대부분의 메시징 시스템이 이러한 기본 모델을 확장해 사용하고 있다. 

- 소비자가 메시지를 처리하는 속도보다 생산자가 메시지를 빠르게 전송한다면?
  - 메시지를 버린다.
  - 큐에 메세지를 버퍼링한다.
  - 배압(backpressure)한다. 흐름 제어(flow control)라고도 하며 생산자가 메시지를 더 보내지 못하게 막는다.
    - 유닉스 파이프와 TCP는 배압을 사용한다.
- 노드가 죽거나 일시적으로 오프라인이 된다면 어떻게 될까? 손실되는 메시지가 있을까?
  - 지속성이 중요하다면 디스크에 기록하거나 복제본을 생성한다. 이는 비용이 든다.
  - 유실돼도 괜찮다면 같은 하드웨어에서 처리량은 높이고 지연시간은 낮출 수 있다.


### 생산자에서 소비자로 메시지 직접 전달하기

많은 메시지 시스템은 중간 노드를 거치지 않고 생산자와 소비자간에 직접 통신한다.

- UDP 멀티 캐스트는 낮은 지연이 필수인 주식 시장과 같은 금융 산업에서 많이 사용된다.  UDP 자체로는 신뢰성이 낮아도 애플리케이션 단의 프로토콜은 읽어버린 패킷을 복구할 수 있다. (생산자는 필요할 떄 패킷 재전송을 할 수 있도록 전송한 패킷을 기억해야 한다.)
- ZeroMQ같은 브로커가 필요없는 메시징 라이브러리와 나노메시지(nanomsg)가 이와 유사한 접근법을 사용하는데 TCP 또는 IP 멀티캐스트 상에서 발행/구독 메시징을 구현한다.
- StatsD과 BruBeck은 지표 수집 및 모니터링에 UDP 메시징을 사용한다. 
- 소비자가 네트워크에 서비스를 노출하면 생산자는 직접 HTTP나 RPC 요청을 직접 보낼 수 있다. webhook의 기본 아이디어로 서비스 콜백 URL을 다른 서비스에 등록하는 형식으로 이벤트가 발생할 때마다 콜백 URL로 요청을 보낸다.

  
직접 메시징 시스템은 메시지가 유실될 가능성을 고려한 코드 작성이 되야 한다.<br>
소비자가 오프라인이기에 메시지를 전달하지 못하는 상황에서 전송된 메시지는 유실될 수 있고, 이런 실패한 메시지 전송을 재시도하다보면 생산자 장비가 죽거나 재시도 하려 했던 메시지 버퍼를 잃어버릴 수 있기에 문제가 있다. 

### 메시지 브로커

 > [생산자] - 메세지전송 -> [브로커(메세지큐)] - 메세지읽기 -> [소비자]

브로커에 데이터가 모이기 때문에 클라이언트 상태변경으로 인한 유실에 쉽게 대처할 수 있다.<br>
경우에 따라 메모리에만 보관/디스크에 기록(유실 방지), 큐 사이즈 확대 등의 설정도 가능하다.

### 메시지 브로커와 데이터베이스의 비교

|DB|메시지 브로커|
|:--:|:--:|
|명시적으로 데이터가 삭제될 떄까지 데이터를 보관|대부분은 메시지 전송이 끝나면 자동으로 메시지를 삭제|
|보조 색인 지원| 특정 패턴과 부합하는 토픽의 부분 집합을 구독하는 방식|
|질의 결과는 일반적으로 질의 시점의 데이터 스냅숏을 기준으로 한다|임의 질의를 지원하지 않지만 데이터가 변하면 클라이언트에게 알려준다| 


### 복수 소비자

복수 소비자가 같은 토픽에서 메시지를 읽을 떄 사용하는 패턴은 다음과 같다. 

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/f33bdf23-384b-4bd8-b316-8d3c1a047df4)


- `로드 밸런싱` : 여러 소비자가 하나의 토픽을 소비하는 작업을 공유
  - 각 메시지는 소비자 중 하나로 전달된다.
  - 브로커는 메시지를 전달할 소비자를 임의로 지정한다.
  - 메시지 처리 비용이 높아 처리를 병렬화 하기 위해 소비자를 추가 하고 싶을 때 유용하다.
  - JMS에서는 공유 구독(shared subscription)이라 한다.
  - AMQP는 같은 큐를 소비하는 클라이언트를 여러개 둬 로드밸런싱 구현이 가능하다.
- `팬 아웃` : 각 메시지를 복수 개의 소비자로 전달
  - 각 메시지는 모든 소비자에게 전달된다.
  - 여러 독립적인 소비자가 브로드캐스팅된 동일 메시지를 모두 볼 수 있다.
  - 일괄 처리에서 사용하는 방법과 동일

이 두 가지 패턴은 함께 사용 할 수도 있다. <br>
두 개의 소비자 그룹에서 하나의 토픽을 구독하고 각 그룹은 모든 메시지를 받지만 그룹 내에선 각 메시지를 하나의 노드만 받게 할 수 있다. 


### 확인 응답과 재전송

클라이언트는 메세지 처리가 끝나면 브로커에게 `확인 응답` 을 보내 메세지 큐에서 제거할 수 있게 해야한다.<br>
브로커는 확인 응답을 받지 못하면 실패로 간주하고 다른 소비자에게 다시 전송한다.

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/96c0a222-b7cd-48fc-877e-fd083beff807)

때문에 위 처럼 소비자 1에서 m4 → m3 → m5 순으로 메시지를 처리하는 경우가 생기게 된다.

부하 균형 분산 기능을 사용하지 않고 소비자마다 독립된 큐를 사용하면 문제를 피할수 있으나, 아니라면 메세지간 인과성이 중요한 서비스에서는 치명적이다.

### 파티셔닝된 로그
네트워크 상에서 패킷을 전송하거나 네트워크 서비스에 요청하는 작업은 보통 영구적 추적을 남기지 않는 일시적 연산이다. 

메세지 브로커에서 이미 소비된 메시지는 복구할 수 없고, 소비자를 다시 실행해도 동일한 결과를 받을 수 없다.<br>
메시징 시스템에 새로운 소비자를 추가한다면 추가된 등록 시점 이후의 메시지부터 받기 시작하며 이전 메시지는 다시 읽을 수 없다. 

DB의 지속성 + 메세징시스템의 짧은 지연시간 = 로그 기반 메세지 브로커

### 로그를 사용한 메시지 저장소

로그는 단순히 디스크에 저장된 추가 전용 레코드의 연속이다. <br>
생산자가 보낸 메시진 로그 끝에 추가하고 소비자는 로그를 순차적으로 읽어 메시지를 받는다. 소비자가 로그 끝에 도달하면 새 메시지가 추가됐다는 알림을 기다린다.

유닉스 도구 tail -f는 파일에 추가되는 데이터를 감시하는데 본질적으로 이 구조와 동일하다. 


![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/17206195-23e5-472d-98c0-d8920b2daa7f)

- 각 파티션 내에서 브로커는 모든 메시지에 오프셋이라 부르는, 단조 증가하는 순번을 보여한다.
- 파티션은 추가 전용이고, 파티션 내 전체 메시지는 전체 순서가 있기에 순번을 부여하는 것은 타당하다. (다른 파티션 간 메시지의 순서는 보장하지 않는다.)
- 아파치 카프카(Apache Kafka), 아마존 키네시스 스트림(Amazon Kinesis Stream), 트위터의 분산 로그(DistributedLog)
- 이러한 메시지 브로커는 모든 메시지를 디스크에 저장하지만 여러 장비에 메시지를 파티셔닝해 초당 수백만 개의 메시지를 처리할 수 있고 메시지를 복제함으로써 장애에 대비할 수 있다.

> 참고: JMS (Java Message Service)
> Java를 사용해 메시지 지향 미들웨어(Message-Oriented Middleware, MOM)를 비동기 메시지 전송을 단순화하는 API로 스트림 처리와 결합해 대규모 분산 시스템에서 실시간 데이터 처리를 할 수 있으며 다음과 같은 메시지 모델들을 지원한다. 
> 1. Point-to-Point: 메시지를 큐(Queue)에 저장하고, 하나 이상의 컨슈머에 전달한다. 각 메시지는 오직 하나의 컨슈머에게만 전달된다. 
> 2. Publish-Subscribe: 퍼블리셔가 특정 토픽(Topic)에 메시지를 게시하면 해당 토픽을 구독하는 모든 구독자에게 브로드캐스팅된다.


### 로그 방식과 전통적인 메시징 방식의 비교


로그 방식 (예: Apache Kafka):
1. 내구성: 메시지를 영구적으로 저장하고 순서를 유지하여 높은 내구성을 제공한다.
2. 재생성 가능: 컨슈머가 이미 처리한 메시지를 다시 처리할 수 있게 하며 이러한 점은 디버깅에 유용하다.
3. 고성능: 데이터를 연속적으로 저장하고 메시지를 빠르게 전달하므로 대량의 데이터 처리에 적합하다.
4. 확장성: 클러스터를 통해 수평적으로 확장할 수 있습니다.

전통적인 메시징 방식 (예: JMS, RabbitMQ, ActiveMQ)
1. 유연한 메시지 처리: 메시지를 큐나 토픽으로 분리하여 다양한 메시지 처리 패턴을 지원한다.
2. 상태 관리: 메시지 상태를 메시징 시스템에서 추적하고 관리할 수 있다. (Ex:  메시지가 전송되었는지, 처리되었는지 등).
3. 전송 보장: 메시지 전송 여부 확인 및 실패시 재전송할 수 있는 기능을 제공한다.
4. 메시지 필터링: 구독자가 특정 조건을 기반으로 메시지를 선택적으로 수신할 수 있다.


로그 기반 접근법은 팬 아웃 메시징 방식을 제공하기에 대용량 데이터 처리 및 확장성과 내구성을 가질 수 있다.<br>
반면 전통적인 메시징 방식은 메시지 처리를 유연하게 하고 상태 관리를 하는데 중점을 둔다. 

- `JMS / AMQP 방식의 메시지 브로커`
  - 메시지 처리 비용이 비싸고,
  - 메시지 단위로 병렬화 처리하고 싶고
  - 메시지 순서는 중요하지 않다면
- `로그 기반 메세지 브로커`
  - 메시지 처리량이 많고,
  - 메시지를 처리하는 속도가 빠르지만
  - 메시지 순서가 중요하다면


### 소비자 오프셋

파티션 하나를 순서대로 처리하면, 소비자의 현재 오프셋을 기준으로 이전은 이미 처리한 메시지, 이후는 아직 처리하지 않은 메시지다.<br>
따라서 브로커는 개별 메시지마다 보내는 확인 응답을 추적할 필요가 없고, 주기적으로 소비자 오프셋을 기록하면 된다.<br>
추적 오버헤드 감소, 일괄처리 및 파이프라이닝을 수행할 수 있는 기회를 제공해 처리량을 늘리는데 도움이 된다.


이 방식은 단일 리더 DB 복제에서 사용되는 로그 순차 번호(log sequence number)와 비슷하다.<br>
메시지 브로커가 DB의 리더처럼 동작하고 소비자가 팔로워처럼 동작한다. <br>
그래서 소비자 노드에 장애가 발생할 경우 소비자 그룹 내 다른 노드에 장애가 발생한 소비자의 파티션을 할당하고 기록된 오프셋 메시지를 처리하기 시작한다. <br>
장애가 발생한 소비자가 처리했지만 아직 오프셋을 기록하지 못한 메시지가 있다면 이 메시지는 재시작할 때 두 번 처리된다. 

### 디스크 공간 사용

로깅을 하다보면 디스크 공간이 가득차게 될 것이다. 

- 로그를 여러 조각으로 나눠 오래된 것부터 삭제하거나 보관 저장소로 이동(Ex: DB)
- 소비자의 소비가 너무 늦어서 메시지 생산 속도를 따라잡지 못하면, 소비자의 오프셋이 이미 삭제된 조각을 가리킬 수도 있고 이는 메시지 유실을 의미한다. 
- 로그는 크기가 제한된 버퍼로 구현하고버퍼가 가득 차면 오래된 메시지 순서대로 버린다.
  - 원형 버퍼(circular buffer) or 링 버퍼(ring buffer)라 한다.
