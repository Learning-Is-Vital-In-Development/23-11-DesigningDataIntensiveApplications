## 스트림 처리

일괄처리는 입력의 변화가 하루가 지나야 반영된다는 문제가 있다.
실시간성이 중요한 서비스에서 이런 지연은 치명적이고, 이를 해결하기 위해 스트림 처리가 등장했다.

"스트림"이란 시간 흐름에 따라 점진적으로 생산된 데이터이다.
유닉스의 stdin / stdout, 프로그래밍 언어(느긋한 리스트(lazy lists)), 자바의 FileInputStream, TCP,오디오와 비디오 전송 등


### 이벤트 스트림 전송

||일괄처리|스트림처리|
|:--:|:--|:--|
|입력|파일|이벤트|
|변환|레코드의 연속으로 변환|텍스트문자열/JSON/이진 형태 등으로 부호화|
|소비|한번 기록하면 여러 작업에서 읽기 가능|생산자(producer/publisher)가 이벤트를 만들면 복수의 소비자(consumer, subscriber)가 처리 가능|
|식별|관련 레코드 집합을 파일 이름으로 식별|토픽이나 스트림으로 관련 이벤트를  묶는다|

이론상 DB와 폴링으로 스트리밍이 가능하지만 지연성이 낮아야할수록 폴링이 잦아지고, 커넥션 등 오버헤드가 커진다.
또한 새로운 이벤트마다 노티를 주는 방식도, 데이터베이스의 트리거를 사용할 수 있지만 기능이 제한적이다.

### 메시징 시스템

새로운 이벤트를 소비자에게 알려주는 일반적인 방법으로 메시징 시스템(messaging system)이 있다. 
메시징 시스템을 구축하는 가장 간단한 방법은 생산자와 소비자 사이에 유닉스 파이프나 TCP 연결과 같은 직접 통신 채널을 사용하는 것으로,  대부분의 메시징 시스템이 이러한 기본 모델을 확장해 사용하고 있다. 

- 소비자가 메시지를 처리하는 속도보다 생산자가 메시지를 빠르게 전송한다면?
  - 메시지를 버린다.
  - 큐에 메세지를 버퍼링한다.
  - 배압(backpressure)한다. 흐름 제어(flow control)라고도 하며 생산자가 메시지를 더 보내지 못하게 막는다.
    - 유닉스 파이프와 TCP는 배압을 사용한다.
- 노드가 죽거나 일시적으로 오프라인이 된다면 어떻게 될까? 손실되는 메시지가 있을까?
  - 지속성이 중요하다면 디스크에 기록하거나 복제본을 생성한다. 이는 비용이 든다.
  - 유실돼도 괜찮다면 같은 하드웨어에서 처리량은 높이고 지연시간은 낮출 수 있다.


### 생산자에서 소비자로 메시지 직접 전달하기

많은 메시지 시스템은 중간 노드를 거치지 않고 생산자와 소비자간에 직접 통신한다.

- UDP 멀티 캐스트는 낮은 지연이 필수인 주식 시장과 같은 금융 산업에서 많이 사용된다.  UDP 자체로는 신뢰성이 낮아도 애플리케이션 단의 프로토콜은 읽어버린 패킷을 복구할 수 있다. (생산자는 필요할 떄 패킷 재전송을 할 수 있도록 전송한 패킷을 기억해야 한다.)
- ZeroMQ같은 브로커가 필요없는 메시징 라이브러리와 나노메시지(nanomsg)가 이와 유사한 접근법을 사용하는데 TCP 또는 IP 멀티캐스트 상에서 발행/구독 메시징을 구현한다.
- StatsD과 BruBeck은 지표 수집 및 모니터링에 UDP 메시징을 사용한다. 
- 소비자가 네트워크에 서비스를 노출하면 생산자는 직접 HTTP나 RPC 요청을 직접 보낼 수 있다. webhook의 기본 아이디어로 서비스 콜백 URL을 다른 서비스에 등록하는 형식으로 이벤트가 발생할 때마다 콜백 URL로 요청을 보낸다.

  
직접 메시징 시스템은 메시지가 유실될 가능성을 고려한 코드 작성이 되야 한다. 소비자가 오프라인이기에 메시지를 전달하지 못하는 상황에서 전송된 메시지는 유실될 수 있고, 이런 실패한 메시지 전송을 재시도하다보면 생산자 장비가 죽거나 재시도 하려 했던 메시지 버퍼를 잃어버릴 수 있기에 문제가 있다. 

### 메시지 브로커

 > [생산자] - 메세지전송 -> [브로커(메세지큐)] - 메세지읽기 -> [소비자]

브로커에 데이터가 모이기 때문에 클라이언트 상태변경으로 인한 유실에 쉽게 대처할 수 있다.<br>
경우에 따라 메모리에만 보관/디스크에 기록(유실 방지), 큐 사이즈 확대 등의 설정도 가능하다.

### 메시지 브로커와 데이터베이스의 비교

|DB|메시지 브로커|
|:--:|:--:|
|명시적으로 데이터가 삭제될 떄까지 데이터를 보관|대부분은 메시지 전송이 끝나면 자동으로 메시지를 삭제|
|보조 색인 지원| 특정 패턴과 부합하는 토픽의 부분 집합을 구독하는 방식|
|질의 결과는 일반적으로 질의 시점의 데이터 스냅숏을 기준으로 한다|임의 질의를 지원하지 않지만 데이터가 변하면 클라이언트에게 알려준다| 


### 복수 소비자

복수 소비자가 같은 토픽에서 메시지를 읽을 떄 사용하는 패턴은 다음과 같다. 

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/f33bdf23-384b-4bd8-b316-8d3c1a047df4)


- `로드 밸런싱` : 여러 소비자가 하나의 토픽을 소비하는 작업을 공유
  - 각 메시지는 소비자 중 하나로 전달된다.
  - 브로커는 메시지를 전달할 소비자를 임의로 지정한다.
  - 메시지 처리 비용이 높아 처리를 병렬화 하기 위해 소비자를 추가 하고 싶을 때 유용하다.
  - JMS에서는 공유 구독(shared subscription)이라 한다.
  - AMQP는 같은 큐를 소비하는 클라이언트를 여러개 둬 로드밸런싱 구현이 가능하다.
- `팬 아웃` : 각 메시지를 복수 개의 소비자로 전달
  - 각 메시지는 모든 소비자에게 전달된다.
  - 여러 독립적인 소비자가 브로드캐스팅된 동일 메시지를 모두 볼 수 있다.
  - 일괄 처리에서 사용하는 방법과 동일



이 두 가지 패턴은 함께 사용 할 수도 있다. 
두 개의 소비자 그룹에서 하나의 토픽을 구독하고 각 그룹은 모든 메시지를 받지만 그룹 내에선 각 메시지를 하나의 노드만 받게 할 수 있다. 


### 확인 응답과 재전송

