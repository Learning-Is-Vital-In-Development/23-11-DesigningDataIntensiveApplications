# 05장 복제

`5장의 핵심 내용`

- 노드 간 변경을 복제하기 위한 세 알고리즘 : **단일 리더**, **다중 리더**, **리더 없는** 복제
- 복제 시 고려해야 할 트레이드오프 : 동기식 vs 비동기식, 잘못된 복제본 처리 방법.
- 복제 지연 문제 : 자신의 쓰기 읽기 & 단조 읽기 보장 등.

---

## 들어가기에 앞서

이번 장에서는 데이터 셋이 아주 작아 각 장비에 전체 데이터셋의 복사본을 보유할 수 있다고 가정하여 **복제본**을 만들었을 때의 **다양한 종류의 장애**와 **대처 방법**에 대해 다룰 것이다.

**복제란?** 네트워크로 연결된 여러 장비(노드)에 동일한 데이터의 복사본을 유지한다는 의미. 

**복제의 필요성**

- 지연 시간 감소 : 사용자와 가까운 지리적 위치
- 가용성 : 시스템 일부 장애 발생해도 지속적 동작 가능
- 읽기 처리량 증가 : 읽기 질의 제공 장비 수 확장

# 1. ****리더와 팔로워****

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/85903675-8147-479c-a855-6c17bf86398f/Untitled.png)

**`복제 서버(replica)`**

- 데이터 베이스의 복사본 저장하는 각 노드
- 이때 모든 복제 서버에 모든 데이터가 있다는 사실을 보장하는 방법은?
    - **통칭** : 
    리더 기반 복제(leader-based replication) =
    능동(active)수동(passive) =
    마스터 슬레이브(master slave)
    - `리더`(leader), 마스터/프라이머리(primary) : 복제 서버 중 하나
        - 예) 클라이언트가 데이터 베이스에 쓰기 요청 → 요청은 리더에게 감 
        → 리더는 로컬 저장소에 새 데이터 기록
    - `팔로워`(follwer),읽기 복제 서버(read replica), 슬레이브 2차(secondary), 핫대기(hot standby) 
    :다른 복제 서버
        - 예) 리더가 로컬 장소에 새로운 데이터 기록할 때마다 
        → 복제로그(replicationlog)/변경스트림(change stream)의 일부로 팔로워에게 전송
        → 각 팔로워가 리더로부터 로그 받으면 리더가 처리한 것과 동일한 순서로 모든 쓰기 적용
        → 이에 맞게 데이터베이스 로컬 복사본 갱신 처리

## 1-1.동기식 대 비동기식 복제

| 동기식 | 비동기식 | 반동기식 (semi-synchronous) |
| --- | --- | --- |
| - 팔로워 변경 완료까지 대기
(장점) 팔로워-리더 간 데이터 일관성. 리더 장애 시 팔로워 데이터 신뢰로 사용 가능.
(단점) 팔로워가 응답이 없으면 쓰기가 처리되지 않는다 | - 팔로워 응답 대기 X
(장점) 팔로워 -리더 간 장애 격리
(단점) 리더 장애 시 데이터 유실 가능성 존재 
내구성 약하나, 많은 팔로워 또는 지리직 분산 시 비동기식 복제 사용. | - 팔로워1 동기식/팔로워2 비동기식
- 적어도 두 노드(리더 & 동기식 팔로워)에 데이터 최신 복사본 보장 |

## 1-2.새로운 팔로워 설정

새로운 팔로워가 리더의 데이터 복제본을 정확히 갖고 있는지 어떻게 보장하는가?

- (리더의 데이터베이스는 지속적으로 추가/변경/삭제 등이 일어나고 있음) 
DB의 쓰기를 잠그고 복제한다면, 일관성은 획득하나, 고가용성은 희생하게 된다.

> 고가용성(high availability,HA)
시스템이 장애가 나는 상황에서도 사용 가능하도록 유지하는 능력을 의미
> 

따라서 중단 없이 팔로워를 설정하려면 다음과 같이 한다.

1. 리더의 데이터베이스 일정 시점 리더  DB 스냅샷 저장.
2. 스냅샷을 새로운 팔로워 노드에 복사
3. 팔로워는 리더에 연결해 스냅샷 이후 변경분 요청. 
(로그의 정확한 위치 필요. eg. MySQL의 binlog coordinate, PostgresQL의 log sequence number)
4. 팔로워가 스냅샷 이후 데이터 변경의 미처리분(backlog)를 
모두 처리했을 때 "따라잡았다(caught up)"고 보고, 
리더에 발생하는 데이터 변화 처리 가능.

## 1-3. 노드 중단 처리 ***(Handling Node Outages)***

**목표**: 개별 노드의 장애에도 전체 시스템이 동작하게끔 유지하고 노드 중단의 영향을 최소화하는 것

- **장점**: 중단 시간 없이 개별 노드를 재부팅할 수 있다.(운영과 유지보수에 장점)

리더 기반 복제에서 고가용성은 어떻게 달성하는가?

- `팔로워 장애`(따라잡기 복구), `리더 장애`(장애 복구)
    - `팔로워 장애`
    (장애 복구 과정)
        - 팔로워 장애 시 마지막으로 처리한 트랜잭션 조회. 이 후 변경분에 대해 팔로워는 리더에 요청.
    - `리더 장애` → 자동 장애 복구 기능이 있더라도, 수동으로 장애 복구를 하는 쪽을 선호하는 경우도 많다.
    (장애 복구 과정 - **수동**)
        - 팔로워 중 하나를 새로운 리더로 삼아야 한다.
        - 클라이언트는 새로운 리더로 쓰기를 전송해야 하므로 재설정이 필요.
        - 다른 팔로워는 새로운 리더를 바라봐야 한다.
        
        (장애 복구 과정 - **자동**)
        
        - 리더가 장애인지 판단한다.
            - 판단할 수 있는 확실한 방법은 없음 → 보통 타임아웃을 사용
            - 노드 간 메시지를 주고 받고 일정시간 응답하지 않는 노드는 죽은 것으로 간주
                - 예외도 존재, 리더가 계획된 유지 보수를 위해 의도적으로 중단되는 경우
        - 새로운 리더를 선택한다.
            - 복제 노드들이 새로운 리더를 선출
            - 또는 제어 노드(controller node)가 새로운 리더를 임명
            - 최신 데이터 변경사항을 가진 복제 서버가 새로운 리더의 가장 적합한 후보로 지목된다.
        - 새로운 리더 사용을 위해 시스템을 재설정한다.
            - 클라이언트의 쓰기 요청, 팔로워의 데이터 변경 로그 재설정
            - 이전 리더가 복구되는 경우 이전 리더가 새로운 리더를 인식하고 자신은 팔로워가 된다.
        
        (문제점)
        
        - 스플릿 브레인(Split Brain)
        두 노드가 모두 자신이 리더라고 믿는 문제
        - 내구성을 보장하지 X 
        비동기식 복제 사용 시 새로운 리더는 이전 리더가 실패하기 전에 이전 리더의 쓰기를 일부 수진 못할 수 있음.
        - 죽었다고 판단하기에 적절한 타임아웃 값을 정하기가 어렵다.
            - 타임아웃이 길면 → 복구에 너무 오랜 시간이 소요
            - 타임아웃이 짧으면 → 불필요한 장애복구 발생

## 1-4. 복제 로그 구현

**리더 기반 복제의 다양한 복제 방법**

| 복제 방법 특징 | 복제 방법 | 정의 | 설명 |
| --- | --- | --- | --- |
| 애플리케이션의 관여 없이 DB 시스템에 의해 구현 | 구문(Statement) 기반 복제 | 요청받은 구문을 기록하고 쓰기를 실행한 다음 구문을 팔로워에게 전송 | - 서버 간의 비결정적 함수 결과값 차이 때문에 복제가 깨질 수 있다. (NOW(), RAND() 등은 복제 서버마다 다른 값을 생성할 가능성이 존재)

- 부수 효과 존재 구문(트리거, 스토어드 프로시저, 사용자 정의 함수) : 다른 결과 발생 가능성 존재

- 자동증가 칼럼 또는 DB의 데이터에 의존(update .. where …) 시 정확히 같은 순서 실행 보장되어야 함. |
| 애플리케이션의 관여 없이 DB 시스템에 의해 구현 | 쓰기 전 로그
(WAL, write-ahead log) 배송 | 로그 구조화 저장소 엔진의 경우 로그 자체가 저장소의 주요 부분. 로그 세그먼트는 작게 유지되고 백그라운드로 가비지 컬렉션. | - 개별 디스크 블록에 덮어쓰는 B 트리의 경우 모든 변경은 쓰기 전 로그(Write-ahead log, WAL)에 쓰기 때문에 고장 이후 일관성 있는 상태로 색인 복원 가능.
MySQL Inno DB 엔진에서의 WAL은 Redo Log

- 리더는 디스크에 로그 기록 + 팔로워에게 네트워크로 로그 전송. 팔로워는 해당 로그 처리 통해 리더와 동일한 복제본 생성.

(단점) 
로그가 제일 저수준의 데이터를 기술. 저장소 엔진에 의존적. 저장소 형식 변경 시 문제 발생. |
| 애플리케이션의 관여 없이 DB 시스템에 의해 구현 | 논리적(로우 기반) 로그 복제 | 로그를 저장소 엔진과 분리하기 위한 대안으로 복제와 저장소 엔진에 각기 다른 로그 형식을 사용한다. |  |
| 복제 방식에 유연성이 요구되며 애플리케이션이 관여 | 트리거 기반 복제 | - 사용자 정의 애플리케이션 코드를 등록할 수 있다.
- 데이터 변경 시(쓰기 트랜잭션) 자동으로 실행된다.
- 트리거를 통해 데이터 변경을 분리된 테이블에 로깅한다.
- 이 테이블에 기록된 데이터 변경을 외부 프로세스가 읽고 처리한다.
- 필요한 애플리케이션 로직 적용 후 다른 시스템에 데이터 변경을 복제한다.
ex. Oracle의 Databus, PostgresQL의 Bucardo |  |

# 2. **복제 지연 문제**

단일 노드에 쓰기 & 복제 노드에서 읽기 : 읽기 확장 아키텍처. 읽기 처리량을 증가시키는 방법. 사실상 **비동기 팔로워**에서만 동작 가능한 방법. 수많은 팔로워 노드 복제를 기다릴 수 없기 때문.

리더에서 팔로워 데이터 반영까지 지연이 있을 수 있음(**복제 지연**). 하지만 결국에는 일치. 
=> `최종적 일관성`.

> **최종적 일관성 (Eventual Consistency)**
분산 컴퓨팅 환경에서 사용되는 일관성 모델 중 하나. 일시적으로는 데이터의 일관성이 깨지는 것을 허용한다.그러나 최종적으로는 (데이터의 변경사항이 없다면) 데이터 대한 모든 접근들에 대해 마지막으로 갱신된 값을 반환하는 것을 보장한다.
> 

**복제 지현 발생 사례 세 가지**

1. 자신이 쓴 내용 읽기
2. 단조 읽기
3. 일관된 순서 읽기

# 3. **다중 리더 복제**

**다중 리더**

- 쓰기 처리를 하는 각 노드는 데이터 변경을 모든 노드에 전달하는데 이를 다중 리더 설정 (마스터 마스터, 액티브/액티브 복제라고도 함)
- 여기서 각 리더는 동시에 다른 리더의 팔로워 역할도함
- 모든 쓰기를 해당 리더를 거쳐야 하고, 리더 연결이 불가능한 경우 쓰기 불가능한 단점 보완

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/894a0a8f-101c-4b85-98e9-c81ab05c0d6a/Untitled.png)

- 각 데이터센터마다 리더 존재
- 단점
    - 동일 데이터를 다른 두 개의 데이터센터에서 동일 변경 가능 -> 쓰기 충돌 반드시 해소해야하는 문제
    - 자동 증가 키, 트리거, 무결성 제약 등 문제 소지 가능성 부분 존재
- 다중 데이터센터에서의 단일 리더 설정과 다중 리더 설정
    
    
    |  | 단일리더 | 다중리더 |
    | --- | --- | --- |
    | 성능 | 쓰기 지연 ⬆ | 지연 ⬇ (성능 Good) |
    | 데이터센터 중단내성 | 다른 데이터센터 팔로워의 리더 승진 | 데이터센터 리더 간 독립성으로 상호 영향 X |
    | 네트워크 | 데이터센터 내 연결에 민감(동기식 사용) | 네트워크 민감성 떨어짐(비동기 사용) |

# 4. 리더 없는 복제

- 일부 데이터 저장소 시스템은 리더의 개념을 버리고 모든 복제 서버가 클라이언트로부터 쓰기를 직접 하는 방식을 사용하기도 함
- 다이나모 스타일 DB로 리악, 카산드라, 볼드모트 등 오픈소스 데이터스토어가 있음
- 일부 리더 없는 복제 구현에서는 클라이언트가 여러 복제 서버에 쓰기를 직접 전송하는 반면 코디네이터 노드가 클라이언트를 대신해 이를 수행하기도 함
