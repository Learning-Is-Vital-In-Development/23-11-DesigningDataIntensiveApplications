# 05장. 복제

## 서론

복제란 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미다.

복제에서 인기 있는 알고리즘  세 가지가 있으며 이는 각 `단일리더`, `다중리더`, `리더없는`복제 이다.

복제에는 고려해야 할 많은 트레이드오프가 있으며, 이런 트레이드오프는 대개 데이터베이스의 설정 옵션이다.

## 리더와 팔로워

데이터베이스의 복사본을 저장하는 각 노드를 `복제 서버(replica)` 라고 한다.

데이터베이스의 모든 쓰기는 모든 복제 서버에서 처리돼야 하며, 그렇지 않으면 복제 서버는 더 이상 동일한 데이터를 유지할 수 없다.

이 문제를 위한 가장 일반적인 해결책은 리더 기반 복제(`능동/수동`, `마스터 슬레이브`)라고 한다.

복제 서버 중 하나를 리더로 지정하며, 클라이언트가 데이터베이스에 쓰기를 할 때 클라이언트는 요청을 리더에게 보내야 한다.

다른 복제 서버는 `팔로워` 라고 하며, 리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 `복제로그` 나 `변경 스트림` 의 일부로 팔로워에게 전송한다. 각 팔로워가 리도로부터 로그를 받으면, 리더가 처리한 것과 동일한 순서로 모든 쓰기를 적용해 갱신한다.

## 동기식 대 비동기식 복제

복제 시스템의 중요한 사항은 복제가 `동기식`으로 발생하는지 `비동기식`으로 발생하는지 여부다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/71249347/4c08d5dc-601f-4bae-881f-03a5d2cb9582)

**동기식**

리더는 팔로워 1이 쓰기를 수신했는지 확인해 줄 때까지 기다린다. 이후 확인이 끝나면 사용자에게

성공을 보고하고 다른 클라이언트에게 해당 쓰기를 보여준다.

**비동기식**

리더는 메시지를 전송하지만 팔로워의 응답을 기다리지 않는다.

동기식 복제의 `장점은`팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장한다.

갑자기 리더가 작동하지 않아도 데이터는 팔로워에서 계속 사용할 수 있음을 확인할 수 있다.

`단점은` 동기 팔로워가 응답하지 않는다면 쓰기 자체가 처리될 수 없다는 것이다.

위의 이유로 사실 모든 팔로워가 동기식인 상황은 비현실적이다. 임의 한 노드의 장애가 전체 시스템에 영향을 주게 된다.

현실적으로 데이터베이스에서 동기식 복제를 사용하려면 보통 팔로워 하나는 동기식으로 하고, 그 밖에는 비동기식으로 하여 동기식 팔로워의 장애를 대처할 수 있도록 `반동기식`으로 구성한다.

반면 비동기식의 경우 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속 할 수 있는 장점이있다.

단점으로는 리더가 잘못되고 복구할 수  없으면 팔로워에 아직 복제되지 않은 모든 쓰기는 유실된다.

## 새로운 팔로워 설정

새로운 팔로워를 추가한다고 가정했을때, 해당 팔로워가 리더의 데이터 복제본을 정확히 가지고 있다는 보장을 어떻게 할 수 있을까

데이터베이스를 잠가서(쓰기가 불가능) 디스크의 파일을 일관성 있게 만들 수 있지만 고 가용성의 목표에 부합하진 않는다. 팔로워는 대개 중단시간 없이 수행 가능하기 때문에 아래와 같은 과정의 개념으로 수행 가능하다.

- 가능하다면 전체 데이터베이스를 잠그지 않고 스냅숏을 일정 시점에 가져온다.
- 스냅숏을 새로운 팔로워 노드에 복사한다.
- 팔로워는 리더에 연결해 스냅숏 이후 발생한 모든 데이터 변경을 요청한다.
- 팔로워가 스냅숏 이후 데이터 변경의 미처리분을 모두 처리했을때 따라잡았다고 말한다.

보통 스냅숏을 복사하기 위해선 리더의 복제 로그의 정확한 위치에 연관돼야 하며, 이위치의 명칭은 다양하다.(MySQL - 이진로그 좌표, PostgreSQL - 로그 일련번호)

## 팔로워 장애: 따라잡기 복구

팔로워가 죽어 재시작 하거나 리더와 팔로워 사이의 네트워크가 일시적으로 중단된다면 팔로워는 보관된 로그에서 결함이 발생하기 전에 처리한 마지막 트랜잭션을 기준으로 리더에 연결해 끊어진 동안 발생한 모든 데이터 변경을 요청할 수 있다.

## 리더 장애: 장애 복구

만일 리더가 장애가 생겼다면 어떻게 처리할까, 팔로워 중 하나를 새로운 리더로 승격해야하며, 클라이언트는 새로운 리더로 쓰기를 전송하기 위해 재설정이 필요하고, 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작해야 한다. 이 과정을 `장애복구(failover)` 라 한다.

자동 장애 복구는 보통 아래와 같은 단계로 구성된다.

1. 리더가 장애인지 판단한다.(대부분의 시스템은 단순히 타임아웃으로 체크한다.)
2. 새로운 리더를 선택한다.(복제 서버들의 투표로 이루어짐 ex. `vote-for-leader`)
3. 새로운 리더 사용을 위해 시스템을 재설정 한다.

장애 복구 과정은 잘못될 수 있는 것 투성이다.

- 비동기식 복제 경우 새 리더는 이전 리더가 실패하기 전 쓰기를 수신하지 못할 수 있다.
- 쓰기를 폐기하는 방법은 외부 다른 저장소가 데이터베이스 내용에 맞춰 조정돼야 하면 위험하다.
- 특정 결함 시나리오에서 두 노드가 자신이 리더라고 믿는 `스플릿 브레인`이 발생할 수 있다.
- 리더가 분명히 죽었다고 판단 가능한 타임아웃에 대한 결정이 어렵다.