# 02장. 데이터 모델과 질의언어(데이터를 위한 질의 언어)

## 데이터를 위한 질의 언어

SQL은 `선언형` 질의언어인 반면 IMS와 코다실은 `명령형` 코드를 사용해 데이터베이스에 질의 한다.

명령형 언어는 목표를 달성하기 위한 `방법` 을 컴퓨터에게 지시한다.(특정 순서로 특정 연산을 수행하도록) 그 반대로 SQL 등의 선언형 질의 언어에서는 데이터의 패턴, 즉 `결과가 충족해야 하는 조건`과 데이터를 어떻게 변환(정렬, 그룹화)할지 지정하기만 하며 된다.(실제 방법은 최적화기가 진행함)

선언형 질의어는 명령형 질의어에 비해 `기능적으로 더 제한적` 이지만, 이는 데이터베이스에게 자동으로 최적화할 수 있는 여지를 더 많이 주며, 데이터의 변화에 영향을 받지 않는다.

추가로, 선언형 언어는 방법이 아닌 결과의 패턴을 지정하기 때문에 병렬 실행에 적합하지만 명령형의 경우 명령어를 특정 순서로 수행하게 끔 지정하기 때문에 병렬 처리가 어렵다.

### 웹에서의 선언형 질의

선언형 질의 언어의 장점은 웹에서도 찾아 볼 수 있다. 웹 브라우저에서 선언형 CSS 스타일을 사용하는 편이 JavaScript에서 명령형으로 스타일을 다루기보다 훨씬 낫다.

### 맵리듀스 질의

`맵리듀스`는 많은 컴퓨터에서 대량의 데이터를 처리하기 위한 프로그래밍 모델로, `몽고DB` 와 `카우치 DB`를 포함한 일부 `NoSQL` 데이터 저장소에서 지원한다.

맵리듀스는 선언형과 명령형 그 중간 정도에 있다.  원하는 결과를 달성하는 방법을 지정하지 않는 다는 부분에서 `선언형` 이지만, 데이터를 처리하는 명시적인 단계를 정의하는 부분에선 `명령형` 적인 부분이 있다.

```jsx
db.observations.mapReduce(
    function map() { 
        var year  = this.observationTimestamp.getFullYear();
        var month = this.observationTimestamp.getMonth() + 1;
        emit(year + "-" + month, this.numAnimals); 
    },
    function reduce(key, values) { 
        return Array.sum(values); 
    },
    {
        query: { family: "Sharks" }, 
        out: "monthlySharkReport" 
    }
);
```

맵리듀스는 의 두 함수(`map` , `reduce` )는 순수 해야한다는 제약사항이 있으며, 이로 인해 데이터베이스가 임의 순서로 해당 함수를 실행할 수 있고, 장애가 발생해도 재실행 할 수 있다.

맵리듀스의 사용성 문제는 연계된 두 함수(map, reduce)를 신중하게 작성해야 한다는 점이며 이는 하나의 질의를 작성하는 것보다 어렵다. 이러한 이유로 몽고DB 2.2는 `집계 파이프라인` 이라 부르는 선언형 질의 언어 지원이 추가되었다.

```jsx
db.observations.aggregate([
    { $match: { family: "Sharks" } },
    { $group: {
        _id: {
            year:  { $year:  "$observationTimestamp" },
            month: { $month: "$observationTimestamp" }
        },
        totalAnimals: { $sum: "$numAnimals" }
    } }
]);
```

### 그래프형 데이터 모델

다대다 관계처럼 데이터 간 연결이 더 복잡해지면 그래프로 데이터를 모델링하기 시작하는 편이 더 자연스럽다.

그래프는  `정점(노드, 엔티티)` 과 `간선(관계, 호)` 두 유형의 객체로 이뤄진다. 그래프는 `동종` 데이터에 국한되지 않으며, 그래프를 동종 데이터와 마찬가지 방식으로 사용하면 단일 데이터 저장소에  완전히 다른 유형의 객체를 일관성 있게 저장할 수 있는 방법을 제공한다.
(예를 들어 페이스북은 다른 여러 유형의 정점과 간선을 단일 그래프로 유지한다.)

![image](https://github.com/akfls221/23-11-DesigningDataIntensiveApplications/assets/71249347/b962192d-ff73-481b-a1ec-42733399561e)

### 속성 그래프

속성 그래프 모델에서 각 정점은 `고유한 식별자`  `유출 간선 집합` `유입 간선집합` `속성 컬렉션`

으로 구성되어 있으며, 간선은 `고유한 식별자` `간선이 시작하는 정점` `간선이 끝나는 정점` `두 정점 간 관계 유형을 설명하는 레이블` `속성 컬렉션` 으로 구성되어 있다.

이 모델의 몇가지 중요한 면은 아래와 같다.

- 정점은 다른 정점과 간선으로 연결된다.(특정 유형과 관련 여부를 제한하는 스키마는 없다.)
- 정점이 주어지면 정점의 유입과 유출 간선을 효율적으로 찾을 수 있고 그래프를 순회할 수 있다.
- 다른 유형의 관계에 서러 다른 레이블을 사용하면 단일 그래프에 다른 유형의 정보를 저장하면서도 데이터 모델을 깔끔하게 유지할 수 있다.

그래프는 데이터 모델링을 위한 많은 유연성을 제공하며, 이는 애플리케이션의 기능을 추가하는 경우 애플리케이션의 데이터 구조 변경을 수용하게끔 그래프를 쉽게 확장할 수 있다.

### 사이퍼 질의 언어

`사이퍼`는 속성 그래프를 위한 선언형 질의 언어로, 네오포제이, 그래프 데이터베이스용으로 만들어 졌다.

```sql
MATCH
(person) -[:BORN_IN]-> () -[:WITHIN*0..]-> (USA:Location {name:’United States’}),
(person) -[:LIVES_IN]-> () -[:WITHIN*0..]-> (EU:Location {name:’Europe’})
RETURN person.name
```

보통 선언형 질의 언어는 질의를 작성할 때 수행에 대해 자세히 지정할 필요가 없으며, 그 이유는 질의 최적화기가 가장 효율적이라고 예측한 전략을 자동으로 선택하기 때문에 작성자는 나머지 애플리케이션만 작성하면 된다.