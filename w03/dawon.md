# 2**. 데이터를 위한 질의 언어**

> 관계형 모델의 등장 → 데이터를 **질의하는 새로운 방법** 도 등장
> 
- **`선언형** 질의언어` (SQL, 관계대수)
    - 결과가 **충족해야하는 조건** + 데이터를 **어떻게 변환**할지 지정 (정렬, 그룹화, 집계, ..)
    - 어떻게 실행할지는 Optimizer(쿼리 최적화)의 몫
- **`명령형** 코드` (IBM, 코다실(네트워크 모델))
    - 특정 순서로 특정 연산을 수행하게끔 컴퓨터에게 지시
    - 목표를 달성하기 위한 **방법**
- `선언형`의 장점
    - 선언형은 명령형에 비해 **더 간결하고 쉬운 작업**
        - 데이터베이스 엔진의 상세 구현이 숨겨져 있어 질의를 변경하지 않고도 성능을 향상 시킬 수 있음
        - 기능적으로 더 제한적 ↔ 자동 최적화
    - 종종 병렬 작업에 적합 (순서 의존 x)
        - 결과를 결정하기 위한 알고리즘이 아니라 패턴만 지정하기 때문

### **웹에서의 선언형 질의**

> CSS, XSL (`선언형`) vs JS의 코어 DOM API (`명령형`)
> 

`**선언형**`의 **장점**은 **DB**에만 국한되지 않는다. 
예) CSS를 사용하여 선택자에 특정 디자인(패턴)을 일괄 적용할 수 있으며 이는 `선언형 방식`이다.

`명령형`의 **단점**
예) JS에서 DOM API를 사용하여 구현
→ 문제사항 2가지 

- 새로운 API 개발 시 코드를 재작성 필요
(선언형인 CSS의 경우 호환성을 깨뜨리지 않음)
- 클래스 삭제 감지가 되지 않아, 특정 작업이 수행되면 전체 페이지가 로딩될때까지 유지된다. 
(선언형인 CSS는 자동으로 감지해서 삭제되자마자 같이 삭제한다)

***결론*** →  웹에서도 명령형 DOM API보다 선언형 CSS를 더 추천하는 것처럼, DB에서도 **`선언형 질의언어` SQL 등등이 명령형 질의 API보다 더욱 추천**된다.

### **맵리듀스 질의 (MapReduce)**

> 맵리듀스(MapReduce)란?
> 
- 많은 컴퓨터에서 대량의 데이터를 처리하기 위한 프로그래밍 모델
- 구글에 의해 널리 알려졌다.

> NOSQL 데이터 저장소
> 
- 제한된 형태인 맵리듀스를 지원
- 이 매커니즘은 많은 문서를 대상으로`읽기 전용(read-only)질의`를 수행할 때 사용
- 예)  MongoDB, CouchDB 등등

> MongoDB의 맵리듀스 (MongoDB의 모델 사용법)
> 
- **선언형 질의도 완전한 명령형 질의API도 아닌 그 중간**
    - 맵리듀스는 여러 ***FP***(Functional Programming) 언어에 `map (collect)` & `reduce (fold/inject)` 함수 기반
        - 단, **순수 함수 (pure function)** 여야함 (side-effect X)
        - 임의 순서로 실행 가능, 재실행 가능
    - **`집계 파이프라인`(aggregation pipeline) →** 선언형 질의 언어 지원
        - SQL의 부분집합과 유사하지만 `JSON 기반 구문`
        - 맵리듀스 함수 작성의 어려움 해소를 위함
        - 선언형 질의 언어는 질의 최적화(Optimizer)가 질의 성능을 높일 수 있는 기회를 제공

> `맵리듀스` (low-level) vs `SQL` (high-level)
> 
> - 반대 개념이 아님. 분산 SQL 구현도 가능하고, MR 사용한/사용하지 않은 구현 모두 O
> - 질의 중간에 자바스크립트 사용/확장 가능 (MR, 일부 SQL)

# **3. 그래프형 데이터 모델**

> 1:N (트리구조), 레코드간 관계 X → `문서모델`
N:1, N:M 관계 → `관계형 모델`
복잡한 N:M 관계 → **`그래프형 모델`**
> 

다대다 관계가 일반적일 경우, 또 데이터 간 연결이 더 복잡해지면 **그래프로 데이터를 모델링 하기 시작하는 편**이 더 자연스럽다

그래프는 **`정점(vertax)`과 `간선(edge)`**로 이루어지는데, 동종 데이터에 국한 되지 않는다

- ex) 페이스북의 정점은 사람, 장소, 체크인, 코멘트 등 여러가지가 될 수 있음

그래프에서 데이터를 구조화하고 질의하는 몇가지 방법과 언어를 설명할 것

### **속성 그래프**

> **정점**(vertex)의 **구성요소**
> 
> - 고유한 식별자
> - 유출(outgoing) 간선 집합
> - 유입(incoming) 간선 집합
> - 속성 컬렉션(key-value)
> 

> **간선**(edge) 의 **구성요소**
> 
> - 고유한 식별자
> - 간선이 시작하는 정점 (**꼬리 정점**)
> - 간선이 끝나는 정점 (**머리 정점**)
> - 두 정점 간의 관계 유형을 설명하는 레이블
> - 속성 컬렉션(key-value)

속성 그래프의 특징은 다음과 같다.

- 정점은 다른 정점과 간선으로 연결된다. 특정 유형과 관련 여부를 **제한하는 스키마는 없다**
- 정점이 주어지면, 정점의 유입과 유출 간선을 효율적으로 찾을 수 있으며, **그래프 순회가 가능**하다.
- 다른 유형의 관계에 서로 다른 레이블을 사용하면, 단일 그래프에 다른 유형의 정보를 저장하면서도 모델을 **깔끔히 유지**할 수 있다

***결론** →*  **그래프**는 **데이터 모델링을 위한 많은** `유연성을 제공`한다. 

- 기능 추가시 쉬운 확장
- 구조 다르거나 `데이터 입도(granularity)`가 달라도 됨

***데이터 입도**: 데이터가 얼마나 자세히 분할되었는가

### **사이퍼 질의 언어**

- 사이퍼(Cypher)
    - 속성 그래프를 위한 `**선언형** 질의 언어`
    - Neo4j 그래프 DB용으로 만들어 졌다.

> 사이퍼 질의 언어의 **장점**
선언형 질의 언어는 질의를 작성 시 수행에 대해 자세히 지정 X
→  질의 최적화기가 가장 효율적이라고 예측한 전략을 자동으로 선택하기 때문
> 

### **SQL의 그래프 질의 언어**

> 그래프를 관계형 구조로 넣어도 SQL을 사용하여 질의할 수 있을까?
> 
> 
> > 정답 → 할 수 있지만 어렵다.
> *관계형을 그래프로 표현할 수 있으며, 그래프도 관계형으로 표현할 수 있지만 후자는 어렵다.*
> > 
> 
> > 이유 → `그래프 질의`에서는 **찾고자 하는 정점을 찾기 전** **가변적인 간선을 순회**해야 하고, **미리 조인 수를 고정할 수 없기 때문** (관계형은 질의에 필요한 조인 미리 파악 가능하다.)
> ***반면에**! `사이퍼`에서는 매우 간결히 표시 가능하다.*
> > 

**재귀 공통 테이블 식 (recursive common table expression)**

- `WITH RECURSIVE` 문
- 1999 이후, 관계형 DB에서도 가변 순회 경로에 대한 질의 표현 가능
- 하지만! 문법이 사이퍼에 비해 어렵다.

### **트리플 저장소와 스파클**

`트리플 저장소 모델`은 `속성 그래프 모델`과 거의 동등하다.

- 차이점
    - 정보 저장 형식 
    `트리플 저장소`는 모든 정보를 주어, 서술어, 목적어 처럼 매우 간단한 **세부분(**three-part statements)**의 구문 형식으로 저장**한다.

**시맨틱 웹**

- 트리플 저장소 데이터 모델은 시맨틱 웹과 완전 독립적이지만, 많은 사람들이 이 둘은 밀접한 관계가 있다고 생각한다. 시맨틱 웹은 웹 사이트는 사람이 이미 읽을 수 있는 정보를 게시하고 있으니, 컴퓨터가 읽게끔 기계가 판독 가능한 데이터로도 정보를 게시하자는 생각이다. 하지만 현실에 실현된 흔적이 없으며, 부정적 견해를 보이는 사람이 많다

**RDF 데이터 모델 (자원 기술 프레임워크** (**RDF**, Resource Description Framework))

- RDF는 서로 다른 웹 사이트가 일관된 형식으로 데이터를 게시하기 위한 방법 제안

**스파클 질의 언어** (**SPARQL**, SPARQL Protocol And RDF Query Language)

- 스파클(SPARQL)은 RDF 데이터 모델을 사용한 `트리플 저장소` `선언형 질의 언어`
- 사이퍼와 유사하지만 사이퍼보다 스파클을 사용하면 때로 질의문이 더 간결해진다.

> **그래프 데이터베이스 vs 네트워크 모델**
> 
- 스키마
    - 코다실 : 다른 레코드 타입, 중첩가능 레코드 타입 지정하는 스키마 존재
    - 그래프 : 제한 x → 유연성이 더 크다.
- 접근 방식
    - 코다실 : 접근 경로 중 하나를 탐색해야 특정 레코드에 도달 가능
    - 그래프 : 고유 ID로 정점 직접 참조 / 색인으로 빠르게 찾기
- 정렬
    - 코다실 : 레코드 하위 항목은 정렬된 집합 (신규 삽입시 위치 고려)
    - 그래프 : 정점 & 간선 정렬 x. 질의 시에만 결과 정렬
- 질의
    - 코다실 : 명령형 질의 사용. 스키마 변경 시 질의 쉽게 손상
    - 그래프 : 대부분 고수준 선언형 질의언어 사용. (명령형도 가능은 o)

### **초석: 데이터로그 (Datalog)**

데이터로그 (Datalog)

- 스파클이나 사이퍼보다 훨씬 오래된 언어로 이후의 **질의 언어의 기반이 되는 초석을 제공**하기에 중요하다.
- 데이터로그의 데이터 모델은 **트리플 저장소 모델과 유사**하지만, 조금 더 `일반화` 됐다.
    - (주어, 서술어, 목적어)로 트리플을 작성하는 대신 서술어(주어, 목적어)로 작성한다.
    - `서술어(predicate)` (`주어(subject)`, `목적어(object)`)
