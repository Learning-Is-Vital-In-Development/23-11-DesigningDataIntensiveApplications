# Ch4 부호화와 발전 (데이터 플로 모드, 고부하로 확장)

## 데이터플로 모드

- 데이터베이스를 통해
- 서비스 호출을 통해
- 비동기 메시지 전달을 통해

### 데이터베이스를 통한 데이터플로

데이터베이스에 기록하는 프로세스는 데이터를 부호화하고 데이터베이스에서 읽는 프로세스는 데이터를 복호화한다. 데이터베이스에서 읽는 행위는 가장 최신 버전의 데이터를 복호화 하는 것이라고 할 수 있다. 이 경우 데이터베이스에 뭔가를 저장한다는 것은, 데이터를 읽을 미래의 누군가에게 메세지를 전달한다고 할 수 있다.

여기서 하위 호환성이 필요하다. 그렇지 않으면 기록한 내용을 미래의 누군가가 읽지(=복호화) 못할 수 있다.

동시에 많은 접근이 발생할 경우, 데이터베이스 내 값이 새로운 버전의 코드로 기록된 다음 현재 수행 중인 예전 버전의 코드로 그 값을 읽을 가능성이 있다. 따라서 데이터베이스에서 상위 호환성도 대개 필요하다.

레코드 스키마에 필드를 추가하고 새로운 코드는 새로운 필드를 위한 값을 데이터베이스에 기록한다고 하자. 이어 (새로운 필드에 대해 아직 알지 못하는) 예전 버전의 코드가 레코드를 읽고 갱신한 후 갱신한 값을 다시 기록한다고 하자. 이런 상황에서 바람직한 동작은 보통 예전 코드가 해석할 수 없더라도 새로운 필드를 그대로 유지하는 것이다.

앞서 설명한 여러 부호화 형식은 이런 방식의 알지 못하는(unknown) 필드 보존은 지원하지만 때로는 애플리케이션 차원에서 신경 써야 하는 사례도 있다.

### 서비스를 통한 데이터플로: REST 와 RPC

서비스 지향 및 마이크로서비스 아키텍처의 핵심 설계 목표는 서비스를 배포와 변경에 독립적으로 만들어 애플리케이션 변경과 유지보수를 더 쉽게 할 수 있게 만드는 것이다.

#### 웹 서비스

REST 는 프로토콜이 아니라 HTTP 의 원칙을 토대로 한 설계 철학이다. REST 원칙에 따라 설계된 API 를 RESTful 이라고 한다.

#### 원격 프로시저 호출(RPC) 문제

RPC 모델은 원격 네트워크 서비스 요청을 같은 프로세스 안에서 특정 프로그래밍 언어의 함수나 메서드를 호출하는 것과 동일하게 사용 가능하게 해준다. RPC 가 처음에는 편리한 것 같지만 RPC 접근 방식은 근본적으로 결함이 있다. 네트워크 호출은 로컬 호출과는 매우 다르다.

네트워크에서 발생하는 오류는 예측하기 어려우며 막을 수 없다. 반면 로컬 호출은 예측 가능하며 디버깅 또한 유리하다.

#### RPC 의 현재 방향

이런 문제에도 RPC 는 사라지지 않는다. gRPC 는 프로토콜 버퍼를 이용한 RPC 의 구현이며 하나의 요청과 하나의 응답 뿐만 아니라 시간에 따른 일련의 요청과 응답으로 구성된 스트림을 지원한다.

#### 데이터 부호화와 RPC 의 발전

RPC 가 종종 조직 경계를 넘나드는 통신에 사용된다는 사실은 서비스 호환성 유지를 더욱 어렵게 한다. 서비스 제공자는 클라이언트를 보통 제어할 수 없고 강제로 업그레이드도 할 수 없기 때문에 호환성은 오랜 시간 동안 유지돼야 한다.

### 메시지 전달 데이터플로

REST 와 RPC 는 하나의 프로세스가 네트워크를 통해 다른 프로세스로 요청을 전송하고 가능한 빠른 응답을 기대하는 방식이다. 데이터베이스는 하나의 프로ㅔㅅ스가 부호화한 데이터를 기록하고 다른 프로세스가 언젠가 그 데이터를 다시 읽는 방식을 사용한다.

비동기 메시지 전달 시스템을 간단히 살펴보자.

메시지 브로커를 사용하는 방식은 직접 RPC 를 사용하는 방식과 비교했을 때 여러 장점이 있다.

- 수신자(recipient)가 사용 불가능하거나 과부하 상태라면 메시지 브로커가 버퍼처럼 동작할 수 있기 때문에 시스템 안정성이 향상된다.
- 죽었던 프로세스에 메시지를 다시 전달할 수 있기 때문에 메시지 유실을 방지할 수 있다.
- 송신자가 수신자의 IP 주소나 포트 번호를 알 필요가 없다.
- 하나의 메시지를 여러 수신자로 전송할 수 있다.
- 논리적으로 송신자는 수신자와 분리된다.

#### 메시지 브로커

대중화된 서비스

- RabbitMQ
- Apache Kafka
- HornetQ
- NATS

프로세스 하나가 메시지를 이름이 지정된 큐나 토픽으로 전송하고 브로커는 해당 큐나 토픽 하나 이상의 소비자 또는 구독자에게 메시지를 전달한다. 동일한 토픽에 여러 생산자와 소비자가 있을 수 있다.

#### 분산 액터 프레임워크

액터 모델은 단일 프로세스 안에서 동시성을 위한 프로그래밍 모델이다. 스레드를 직접 처리하는 대신 로직이 액터에 캡슐화된다. 보통 각 액터는 하나의 클라이언트나 엔티티를 나타낸다. 각 액터 프로세스는 한 번에 하나의 메시지만 처리하기 때문에 스레드에 대해 걱정할 필요가 없고 각 액터는 프레임워크와 독립적으로 실행할 수 있다.

액터 모델은 단일 프로세스 안에서도 메시지가 유실될 수 있다고 이미 가정하기 때문에 위치 투명성은 RPC 보다 액터 모델에서 더 잘 동작한다. 네트워크를 통한 지연 시간이 동일한 프로세스 안에서 보다 더 높을 수 있지만 액터 모델을 사용한 경우 로컬과 원격 통신 간 근본적인 불일치가 적다.

## 고부하로 확장

### 비공유 아키텍처

### 복제 대 파티셔닝
