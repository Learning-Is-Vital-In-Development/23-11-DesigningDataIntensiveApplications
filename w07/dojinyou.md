# 부호화와 발전(part2)

# 데이터플로 모드

메모리를 공유하지 않는 다른 프로세스와의 통신을 위해서는 바이트열로 부호화 해야한다. 이를 위한 일반적인 방법 3가지(데이터베이스를 통해서, 서비스 호출을 통해서, 비동기 메세지 전달을 통해서)를 소개한다.

## 데이터베이스를 통한 데이터플로

데이터 베이스에 데이터를 저장하는 행위는 미래에 자신에게 메세지를 보내는 행위처럼 생각할 수 있다. 이 경우 하위 호환성은 반드시 보장되어야 한다. 뿐만 아니라 상위 호환성 역시 고려해야 한다. 새로운 스키마로 글을 쓰고 이전 스키마의 어플리케이션 모델을 쓰는 어플리케이션이를 이를 읽을 수 있다. 이때 알지 못한 필드들을 무시할 수 있고 이러한 처리는 일반적으로 잘 되어있다. 하지만 이 어플리케이션에서 다시 데이터를 저장할 때는 무시된 필드들이 사라질 수 있다. 이런 문제를 해결하는 것은 어렵지 않으니 이러한 사실을 잘 알고 있으면 된다.

### 다양한 시점에 기록된 다양한 값

데이터가 기록된 이후 일반적으로는 별도로 재 작성하지 않고 스키마가 변경되더라도 기존 데이터의 부호화를 유지하며 부족한 필드에 대해서 null값으로 처리한다. 이러한 현상을 두고 **데이터가 코드보다 오래 산다(data outlives code)** 라고 한다. 따라서 스키마가 발전하더라도 여러 버전으로 부호화된 데이터를 두고 하나의 스키마인 것처럼 표현된다.

### 보관 장소

백업이나 분석으로 스냅샷을 뜰 경우에 보통 최신의 스키마로 뜨기 때문에 동일한 부호화 형태로 저장되는 편이다. 또한 분석을 위해 데이터 저장 형식을 변경하여 부호화할 수 있다.

## 서비스를 통한 데이터플로: REST와 RPC

가장 일반적으로 클라이언트/서버로 구성된 역할로 통신을 구성한다. 클라이언트는 서버에 API 요청을 하고 그 응답을 받는다. 이때 서버가 공개한 API를 **서비스**라고 한다.

서비스를 통한 데이터플로어에서 데이터 부호화는 결국 API의 버전 간 호환 가능성이 가장 중요하다.

### 웹 서비스

HTTP 프로토콜을 통해 통신할 경우 웹 서비스라고 한다. 웹 서비스의 대중적인 방법은 REST와 SOAP이 있다.

REST는 HTTP 원칙을 토대로한 설계 철학이다. 이러한 설계 원칙을 따른 서비스를 RESTful 하다고 한다. 오픈 API(OpenAPI) 같은 정의 형식을 사용해 RESTful API와 제품 문서를 기술하는 데 사용할 수 있다.

### 원격 프로시저 호출(RPC) 문제

RPC 모델은 원격 네트워크 서비스 요청을 같은 프로세스 안에서 특정 프로그래밍 언어의 함수나 메서드 호출하는 것처럼 동일하게 사용하도록 해준다. 이런 추상화를 위치 투명성(location transparency) 라고 한다.

로컬함수와 RPC는 매우 다르다. 아래 표를 보자.

|  | RPC | Local Method |
| --- | --- | --- |
| 응답 결과 | 결과 반환/예외 등 제한적 | 결과 반환/예외 반환 외 타임아웃 존재 |
| 응답 유실 | X | O(재시도를 위한 멱등성 보장필요) |
| 소요 시간 | 대게 일정 | 네트워크 상황에 따라 매우 다름 |
| 데이터 전달 | 메모리 참조를 통한 효율적 전달 | 바이트열 부호화 필요 |
| 구현 언어 | 클라이언트/서버 동일 | 다를 수 있음. |

### RPC의 현재 방향

최근에 나오는 프레임워크들은 위 단점들을 잘 고려해서 나온다.

### 데이터 부호화와 RPC의 발전

발전성을 가지기 위해선 서버와 클라는 분리되어 배포(발전)할 수 있어야 한다. RPC는 요청에서는 하위호환성을, 응답에서는 상위호환성을 가지고 있어야 한다. 서비스 제공자는 클라이언트를 강제로 업그레이드 할 수 없기 때문에 호환성을 깨는 변경을 해야할 경우에는 버전을 변경하여 여러 버전의 API를 유지해야 한다.

## 메시지 전달 데이터플로

비동기 메세지 전달 시스템(Asynchronous message passing system)에서 클라이언트의 요청을 메세지라고 한다. 메세지를 낮은 지연시간으로 전달하며 메세지 브로커(message broker) 혹은 메세지 큐(message queue) 등에게 전달한다.

메세지 전달 시스템은 단방향이라는 점에서 RPC와 다르다. 또한 아래와 같은 특징들을 가진다.

- 수신자가 전달 받을 수 없는 상태더라도 버퍼처럼 동작하여 안정성을 높인다.
- 죽었던 프로세스에게 다시 전달할 수 있기 때문에 메세지 유실을 방지할 수 있다.
- 하나의 메세지를 여러 수신자가 소비할 수 있다.
- 송신자가 수신자에 대한 정보를 몰라도 된다. 따라서 논리적으로 송, 수신자가 분리되어 결합도가 낮아진다.

송신자는 수신자의 응답을 기다리지 않고 메세지를 보내고 잊는다. 이러한 통신패턴이 비동기다.

### 메세지 브로커

프로세스 하나가 메세지를 이름이 붙은 큐나 토픽으로 전송한다. 브로커는 전송 받은 메세지를 해당 큐나 토픽을 소비, 구독하는 수신자에게 전달한다. 하나의 큐나 토픽에는 여러명의 송신자와 수신자가 있을 수 있다.

토픽은 단방향 데이터 플로우만 제공하고 있다. 따라서 응답을 전달하기 위해서는 송신자가 수신하는 다른 큐나 토픽에 메세지를 전달하여야 한다.

### 분산 액터 프레임워크

액터 모델(actor model)은 프로세스 내에서 동시성 해결을 위한 모델이다. 액터는 보통 클라이언트나 엔티티를 나타내고 1개씩 메세지를 처리해 동시성 무넺를 해결한다. 분산 액터 프레임워크는 이러한 액터 모델을 노드 간의 애플리케이션 환경으로 확장한 것이다.

# Part 2 분산데이터

여러 장비간 분산 데이터베이스를 필요로 하는 이유는 다음과 같다.

1. 확장성
    - 데이터 볼륨, 읽기와 쓰기 부하 등의 양이 커지면 단일 장비로 처리할 수 없어 다른 장비로 부하를 분산
2. 내결함성/고가용성
    - 기존 장비가 장애를 겪더라도 지속적으로 서비스를 제공하기 위해서는 여러 장비에 하여 동작하며 다른 장비가 대체하여 지속적으로 운영되어야 한다.
3. 지연 시간
    - 전 세계의 사용자가 있다면 지리적으로 가까운 곳에 서버를 두어서 네트워크 시간을 최소화할 수 있다

## 고부하로 확장

가장 간단한 방법은 수직적 확장이다. 하지만 문제는 비용이 선형적으로 증가하지 않는다는 점이다. 또한 병목 현상으로 스펙이 2배가 되어도 성능이 2배가 되진 않는다는 점이다.

다른 접근 방식으로는 공유 디스크 아키텍처가 있다. 별도로 분리된 장비들과 하나의 저장 공간을 공유하고 고속 네트워크로 구성한다. 잠금 경합과 오버헤드가 확장성을 제한한다.

## 비공유 아키텍처

수평 확장(비공유 확장, shared nothing)은 매우 인기가 많다. 특별한 하드웨어를 필요로 하지 않기 때문에 성능이 가장 좋은 시스템을 사용할 수 있다. 또한 지리적으로도 분리할 수 있다.

비공유 아키텍처는 반드시 주의해야할 점이 있다. 노드를 여러 개로 분산하려면 제약조건과 트레이드 오프를 알고 있어야 한다.

## 복제 대 파티셔닝

여러 노드에 데이터를 분산하는 방법은 일반적으로 복제와 파티셔닝 2가지 방법이다. 복제는 같은 데이터의 복사본을 다른 위치에 있는 여러 노드에 유지한다. 복제는 중복성을 제공한다. 파티셔닝은 파티션이라는 작은 서브셋으로 나누고 각 파티션을 서로 다른 노드에 할당한다(샤딩). 이러한 개념을 이해하면 분산 시스템에서 필요한 어려운 트레이드 오프를 이해할 수 있다.
