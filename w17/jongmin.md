
# 10장 일괄 처리

한 사람의 영향도가 너무 큰 시스템은 성공하기 어렵다. 초기 설계가 완료되고 상당히 견고해지면 여러 사람이 다양한 관점을 가지고 각각 실험을 진행하면서 실제 테스트가 시작된다.
- 도널드 크누스

기존 1 ~ 2부에서는 시스템에 데이터를 요청하거나 지시를 보낸 후 잠시 뒤에 해당시스템으로 결과를 반환 받는 시스템을 다뤘다.
- 요청 -> 응답
- 질의 -> 결과

3가지 데이터 시스템

| 항목 | 내용 |
| --- | --- |
| 서비스(온라인 시스템) | 서비스는 클라이언트로부터 요청이나 지시가 올때까지 기다린다. 요청 하나가 들어오면 서비스는 가능한 빨리 요청을 처리해서 응답을 되돌려 보내려 한다. 응답 시간은 서비스 성능을 측정할ㄷ 때 중요한 지표다. 때론 가용성이 매우 중요한데 클라이언트가 서비스에 접근하지 못하면 사용자는 오류 메시지를 받을지 모른다. |
| 일괄 처리 시스템(오프라인 시스템) | 일괄 처리 시스템은 매우 큰 입력 데이터를 처리하는 작업을 수행하고 결과 데이터를 생산한다. 일괄 처리 작업은 수 분에서 때론 수 일이 걸리기 때문에 대개 사용자가 작업이 끝날 때까지 대기하지 않는다. 대신 대부분 하루에 한번 수행과 같이 반복적인 일정으로 수행한다. 일괄 처리 작업의 주요 성능 지표로는 처리량이 대표적인다. 처리량은 입력 데이터 중 특정 크기만큼 처리할 때 걸리는 시간으로 나타낸다. 이번 장에서는 일괄 처리 시스템에 대해 논의한다. |
| 스트림 처리 시스템(준실시간 시스템) | 스트림 처리는 온라인가ㅗ 오프라인/일괄 처리 사이의 어딘가에 있기 때문에 때론 준실시간 처리라 불린다. 스트림 처리 시스템은 일괄 처리 시스템과 마찬가지로 요청에 대해 응답하지 않으며 입력 데이터를 소비하고 출력 데이터를 생산한다. 그러나 일괄 처리 작업은 정해진 크기의 입력 데이터를 대상으로 작동하지만 스트림 처리는 입력 이벤트가 발생한 후 직후 바로 작동한다. 이런 차이 때문에 스트림 처리 시스템은 같은 작업을 하는 일괄 처리 시스템보다 지연 시간이 낮다. 스트림 처리는 일괄 처리를 기반으로 하므로 11장에서 다룬다. |

이번 장에서 살펴보겠지만 **일괄 처리는 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션을 구축하는 데 매우 중요한 구성요소**다.

예를 들면 2004년에 발표된 일괄 처리 알고리즘인 MapReduce는 다소 과한 면이 있지만 "구글을 대규모로 확장 가능하게 만든 알고리즘"으로 불렸다.

맵리듀스는 이전에 데이터 웨어하우스용으로 개발했던 병렬 처리 시스템보다 상당히 저수준 프로그래밍 모델이다. 그러나 **범용 하드웨어만을 사용해 처리한 데이터 규모 면에서 상당히 진보**했다. 지금은 **맵리듀스의 중요성이 떨어지고 있지만** 왜 **일괄 처리가 유용한지 명확하게 그림을 그려주기 때문에 맵리듀스를 이해할 가치는 충분**하다.


## 10.1. 유닉스 도구로 일괄 처리하기

### 10.1.1. 단순 로그 분석
#### 10.1.1.1. 인쇄 명령 대 맞춤형 프로그램
#### 10.1.1.2. 정렬 대 인메모리 집계

### 10.1.2. 유닉스 철학
#### 10.1.2.1. 동일 인터페이스
#### 10.1.2.2. 로직과 연결의 분리

#### 10.1.2.3. 투명성과 실험

## 10.2. 맵리듀스와 분산 파일 시스템
- 매퍼가 키를 기준으로 데이터를 파티셔닝해서 리듀서에게 전달함
- 특정 키에 데이터가 쏠려 있다면 특정 리듀서에게 작업이 몰릴 수 있기에 대책이 필요함
- 여러번의 맵-리듀스 작업이 반복되어 워크플로가 만들어질 수 있음
- 각 맵-리듀스 작업별로 데이터 파일이 디스크에 저장됨
### 10.2.1. 맵리듀스 작업 실행하기

매퍼(Mapper)
- 0
리듀서(Reducer)
- 0
#### 10.2.1.1. 맵리듀스의 분산 실행
#### 10.2.1.2. 맵리듀스 워크플로

### 10.2.2. 리듀스 사이드 조인과 그룹화

### 10.2.3. 사용자 활동 이벤트 분석 예제

#### 10.2.3.1. 정렬 병합 조인
#### 10.2.3.2. 같은 곳으로 연관된 데이터 가져오기
#### 10.2.3.3. 같은 곳으로 연관된 데이터 가져오기

#### 10.2.3.4. 그룹화

#### 10.2.3.5. 쏠림 다루기

### 10.2.4. 맵 사이드 조인

#### 10.2.4.1. 브로드캐스트 해시 조인
#### 10.2.4.2. 파티션 해시 조인

#### 10.2.4.3. 맵 사이드 병합 조인

#### 10.2.4.4. 맵 사이드 조인을 사용하는 맵리듀스 워크플로

### 10.2.5. 일괄 처리 워크플로의 출력

#### 10.2.5.1. 검색 색인 구축

#### 10.2.5.2. 일괄 처리의 출력으로 키-값을 저장

#### 10.2.5.3. 일괄 처리 출력에 관한 철학

### 10.2.6. 하둡과 분산 데이터베이스의 비교

#### 10.2.6.1. 저장소의 다양성

#### 10.2.6.2. 처리 모델의 다양성

#### 10.2.6.3. 빈번하게 발생하는 결함을 줄이는 설계

- 맵리듀스와 MPP 데이터베이스를 비교할 때 설계 방식에서 큰 차이점 두가지가 두드러진다.
- 결함을 다루는 방식과 메모리 및 디스크를 사용하는 방식이 그 두 가지다.

일괄 처리 작업은 사실상 "식탁 아래에서 조각들을 모은다", 우선순위가 높은 프로세스가 필요한 작업을 수행한 뒤에 남은 자원을 사용해 연산을 수행한다.


## 10.3. 맵리듀스를 넘어

### 10.3.1. 중간 상태 구체화

#### 10.3.1.1. 데이터플로 엔진

#### 10.3.1.2. 내결함성

#### 10.3.1.3. 구체화에 대한 논의

### 10.3.2. 그래프와 반복 처리

- 전체 그래프에서 오프라인으로 처리를 수행하거나 분석을 하는 등 일괄 처리 맥락에서 그래프를 살펴보는 것도 흥미롭다.
- 추천 엔진 같은 머신러닝이다 랭킹 시스템 분야에서도 그래프 처리의 필요성이 떠오르고 있다. 예를 들면 가장 유명한 그래프 분석 알고리즘 중 하나인 페이지랭크를 들 수 있다.

#### 10.3.2.1. 프리글 처리 모델

#### 10.3.2.2. 내결함성

#### 10.3.2.3. 병렬 실행


### 10.3.3. 고수준 API와 언어

#### 10.3.3.1. 선언형 질의 언어로 전환

#### 10.3.3.2. 다양한 분야를 지원하기 위한 전문화


## 정리

분산 일괄 처리 프레임워크가 해결해야 할 두 가지 중요한 문제가 있다.
- 파티셔닝
- 내결함성

맵리듀스에서 사용하는 몇 가지 조인 알고리즘
- 정렬 병합 조인
- 브로드캐스트 해시 조인
- 파티션 해지 조인

일괄처리 시스템은 입력을 그대로 두고 출력만 만들기에 재시작하기 쉽고 쉽게 적용할 수 있다.