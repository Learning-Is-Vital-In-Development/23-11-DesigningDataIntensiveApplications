# 03장. 저장소와 검색

- 데이터베이스가 데이터를 저장하는 방법과 데이터를 요청했을 때 다시 찾을 수 있는 방법 설정
- 사용 가능한 여러 저장소 엔진 중에 애플리케이션에 적합한 엔진을 선택하는 작업이 필요
- RDB VS NoSQL 설명
- 로그 구조(log-structured) 계졀 저장소 엔진 vs 페이지 지향(page-oriented) 계열 저장소 엔진 컴토

# 데이터베이스를 강력하게 만드는 데이터 구조

기본적인 저장소 형식

- 매 라인마다 쉼표로 구분된 키-값 쌍을 포함한 텍스트 파일(CSV 파일과 유사)
- 파일의 끝에 추가하므로 키를 여러번 갱신해도 예전 버전을 덮어쓰지 않음.
- 최신값을 찾기 위해서는 파일에서 키의 마지막 항목을 찾는다.

많은 데이터베이스는 내부적으로 추가 전용(append-only) 데이터 파일인 로그(log)를 사용한다. 로그는 믿기지 않을 정도로 유용하다. 실제 데이터 베이스는 로그에서 다양한 문제(동시성, 디스크 공간 회수, 오류 처리, 부분적으로 기록된 레코드 처리)등을 해결한다.

- 매번 키를 찾을 때마다 db_get은 키가 있는지 찾기 위해 전체 데이터베이스 파일을 처음부터 끝까지 스캔해야 한다. O(n)
- 특정 키의 값을 효율적으로 찾기 위해서는 다른 데이터 구조가 필요하다. 그것이 바로 색인(index)이다.

색인의 일반적인 개념은 어떤 부가적인 메타데이터를 유지하는 것이다. 이 메타데이터는 이정표 역할을 해서 원하는 데이터의 위치를 찾는데 도움이 된다. 동일한 데이터를 여러가지 다양한 방법으로 검색하고 자한다면 데이터의 각 부분에 여러가지 다양한 색인이 필요하다.

어떤 종류의 색인이라도 대개 쓰기 속도를 느리게 만든다. 데이터를 쓸 때마다 색인도 갱신해야 하기 때문이다. 색인을 잘 선택했다면 읽기 질의 속도가 향상된다. 하지만 모든 색인은 쓰기 속도를 떨어트린다.

## 해시 색인

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/13ef4b3b-e9cd-4319-81e2-2900a3e57f3a)

- 키-값 데이터는 사전 타입(dictionary type)과 유사핟. 보통 해시 맵(hash map), 해시 테이블(hash table)로 구현한다.
- 가장 간단한 색인 전략은 키를 데이터 파일의 바이트 오프셋에 매핑해 인메모리 해시 맵을 유지하는 전략이다.
- 바이트 오프셋은 로그의 각 바이트의 길이에 따른 위치를 가지고 있어서 키를 통해 그 위치로 즉시 이동하는 방법이다.
- 만약 데이터 파일의 일부가 이미 파일 시스템 캐시에 있다면 읽기에 디스크 입출력이 필요하지 않다.
- 추가만 된다면 결국 디스크 공간이 부족해진다.
    - 특정 크기의 세그먼트(segment)로 로그를 나누는 방식을 사용할 수 있다.
    - 세그먼트 파일들에 대해 컴팩션(compaction)을 수행할 수 있다. 컴팩션은 로그에서 중복된 키를 버리고 각 키의 최신 갱신 값만 유지하는 것을 의미한다.

구현시 고려사항

1. 파일형식
2. 레코드 삭제
3. 고장(Crash) 복구
4. 부분적으로 레코드 쓰기
5. 동시성 제어

   
