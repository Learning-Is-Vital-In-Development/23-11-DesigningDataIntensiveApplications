


# 3장 저장소와 검색

들어가며
- 데이터베이스의 기본적인 작업 2가지
	- 데이터를 저장한다
	- 데이터를 제공한다.

- 애플리케이션 개발자는 적합한 저장소 엔진을 고르는 작업이 필요하다.
- 적합한 저장소 엔진이 특정 작업 부하(Workload) 유형에서 좋은 성능을 내게끔 저장소 엔진을 조정하며 사용하려면 내부에서 수행되는 작업에 대해 대략적으로라도 이해하면 좋다.

- 특히 트랜잭션 작업부하에 맞춰 최적화된 저장소 엔진과 분석을 위해 최적화된 엔진간에는 큰 차이가 있다.

- RDBMS, NoSQL
- 로그 구조(Log-Structured), B-Tree (Page-oriented)

```text
Log: 연속된 추가 전용 레코드 (애플리케인셔 무슨일이 일어났는지 기술한 텍스트를 넘어 보다 일반적인 의미)
```


## 3.1. 데이터베이스를 강력하게 만드는 데이터 구조


```bash
#!/bin/bash

db_set() {
	echo "$1,$2" >> database
}

db_get() {
	grep "^$1," database | sed -e "s/^$1,//" | tail -n 1
}

```

- db_set: Append-only로 저장 시 좋은 성능을 보여준다.
- db_get: 파일 전체를 확인 해야 한다, 시간 복잡도: O(n) 

- db_get()의 성능을 개선하기 위해 다른 데이터 구조가 필요하다. (색인)
- 색인은 기본데이터에서 파생된 추가적인 구조다.
	1. 색인은 기존 데이터베이스의 내용에는 영향을 미치지 않는다.
	2. 기존 데이터의 변경 시 색인도 갱신해야 하기에 오버헤드가 발생하고 쓰기 속도가 느려진다.
- 색인을 잘 설정하면 읽기 속도가 빨라지지만 저장 속도는 느려지는 것: `저장소 시스템의 중요한 트레이드오프`


### 3.1.1. 해시 색인

Key-Value 형태로 색인 하는 것
- 프로그래밍 언어의 Dictionary Type과 유사

- 데이터 파일 세그먼트를 생성해서 데이터를 추가전용 로그로 저장한다
```
account_no, amount, date
1, -100, 2023-01-01
1, +100, 2023-01-02
1, +100, ...
1, -150,
1, +200,
1, -300,
1, +500,
```
- 생성한 데이터 파일 세그먼트를 주기적으로 병합한다.


추가전용 로그 구조의 장점
- 예전 값을 새로운 값으로 덮어서 정해진 자리의 내용을 갱신하는 것보다 빠르다.
- 동시성과 고장 복구가 간단하다. (갱신되기 전의 이전 값이 그대로 있기에 이전 값을 읽으며 복구하면 된다)

해시 테이블 색인의 제한 사항
- 해시 테이블은 메모리에 저장해야 효율적이므로 키가 너무 많으면 문제가 됩니다. (디스크에 해시테이블을 유지하면 성능이 안좋다고 합니다.)
- 해시 테이블은 범위 질의 (Range Scan)에 효율적이지 않습니다. (1~99999)


### 3.1.2. SS테이블과 LSM 트리

- SS(Sorted String) Table

#### 3.1.2.1. SS테이블 생성과 유지

#### 3.1.2.2. SS테이블에서 LSM 트리 만들기

- LSM(Log-Structured Merge-Tree)

#### 3.1.2.3. 성능 최적화

- 존재하지 않는 키를 찾는 경우 느리다: 맴테이블 확인 후 가장 오래된 세그먼트까지 모두 확인해서 키의 존재 유무를 파악한다. (블룸 필터로 극복)
- SS테이블을 압축하고 병합하는 순서와 시기를 결정하는 전략
	- 크기 계층
	- 레벨 컴팩션
- LSM 트리는 백그라운드에서 연쇄적으로 SS테이블을 지속적으로 병합한다.

### 3.1.3. B 트리

- 가장 많이 사용되는 색인 구조는 B-Tree 구조로 Log-Structured 색인과는 상당히 다르다.

- 로그 구조화 색인
	- 데이터베이스를 수 메가바이트 이상의 가변 크기를 가진 세그먼트로 나누고 항상 순차적으로 세그먼트를 기록한다.
- B-Tree 색인
	- 일반적으로 4KB크기의 고정 크기 블록이나 페이지로 데이터를 나누고 한번에 하나의 페이지에 읽기 또는 쓰기를 한다.
	- 데이터를 업데이트 할 때 데이터가 저장된 페이지를 찾아가 업데이트 한다. (이전 값을 잃어버릴 수 있다.)

#### 3.1.3.1. 신뢰할 수 있는 B 트리 만들기

- B트리의 기본적인 쓰기 동작은 새로운 데이터를 디스크 상의 페이지에 덮어쓴다.
- 여러 페이지에 덮어쓰기를 하다 일부 페이지만 기록하고 서버 장애가 발생한다면 ?
	- 장애가 발생하기 이전 시점으로 돌리기 힘들다.
	- 장애 복구를 위해 일반적으로 디스크상에 로그를 먼저 저장한다 (Write-Ahad Log, WAL).
		- Log라는 이름에서 유추할 수 있듯 변경 전 데이터를 저장하는 추가 전용 파일이다.
- 다중 스레드가 동시에 B트리에 접근해서 수정하려고 한다면?
	- 주의 깊은 동시성 제어가 필요하다.
	- 동시성은 보통 Latch(래치) 라는 가벼운 잠금으로 제어한다.

#### 3.1.3.2. B 트리 최적화

- 페이지 엎어 쓰기와 고장 복구를 위한 WAL 유지 대신, 여러 버전의 페이지를 가지고 있기 (MVCC?)
- 페이지에 전체 키를 저장하는게 아니라 키를 축약해서 쓰고 공간을 절약한다. 트리의 분기계수를 높이고 깊이 수준을 낮출 수 있다. (분기계수를 높인다: 한 페이지에 보다 많은 키값을 저장한다.)
- 페이지는 디스크상 어디에나 위치할 수 있다. 연속된 데이터 스캔시 이는 비효율적이기에 페이지의 데이터를 모으는 로직이 있다.
- 트리의 리프에 포인터를 추가해 양쪽 형제페이지 간 이동할 수 있다 (트리를 타지 않고 레인지 스캔 가능)
- 프랙탈 트리: B 트리 변형, 디스크 찾기를 줄인다?


### 3.1.4. B 트리와 LSM 트리 비교

- LSM 트리는 쓰기에서 빠른 반면 (로그)
- B 트리는 읽기에서 빠르다고 여긴다.
- LSM 트리가 읽기에서 더 느린 이유는 각 컴팩션 단계에 있는 여러가지 데이터 구조와 SS테이블을 확인해야 하기 때문이다.

#### 3.1.4.1. LSM 트리의 장점

#### 3.1.4.2. LSM 트리의 단점



### 3.1.5. 기타 색인 구조


#### 3.1.5.1. 색인 안에 값 저장하기

- 커버링 인덱스, 클러스터링 인덱스
- 색인안에 Row의 모든 값을 저장해서 바로바로 사용한다.

#### 3.1.5.2. 다중 컬럼 색인

#### 3.1.5.3. 전문 검색과 퍼지 색인

#### 3.1.5.4. 모든 것을 메모리에 보관

## 3.2. 트랜잭션 처리나 분석?

- 보통 애플리리케이션은 인덱스를 이용해 데이터 저장소에서 적은 수의 레코드를 찾는다.
```sql
select * from orders where id = 12345
```

- OLTP: 일반적인 애플리케이션
- OLAP: 데이터 분석 환경 


### 3.2.1. 데이터 웨어하우징

- 여러 도메인, 서비스의 데이터를 변환해서 한 곳에 모으고 분석한다.

#### 3.2.1.1. 데이터베이스와 데이터 웨어하수의 차이점



#### 3.2.2. 분석용 스키마: 별 모양 스키마와 눈꽃송이 모양 스키마

## 3.3. 컬럼 지향 저장소

### 3.3.1. 컬럼 압축

### 3.3.2. 컬럼 저장소의 순서 정렬

### 3.3.3. 컬럼 지향 저장소에 쓰기

### 3.3.4. 집계: 데이터 큐브와 구체화 뷰

## 3.4. 정리
