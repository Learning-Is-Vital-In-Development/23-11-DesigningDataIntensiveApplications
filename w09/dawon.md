# 3. 리더 없는 복제

지금까지 살펴 본 복제 접근 방식은 클라이언트가 **쓰기 요청을 한 노드(리더)에 전송**한 뒤 **데이터베이스 시스템이 쓰기를 다른 복제 서버에 복사 처리**하는 아이디어 기반

리더 없는 복제는 **리더의 개념을 버리고 모든 복제 서버가 쓰기 작업을 할 수 있게 허용하는 방식**

**리더없는 복제** (`다이나모 스타일`)

- 일부 데이터 저장소 시스템은 **리더의 개념을 버리고 모든 복제 서버가 클라이언트로부터 쓰기를** 직접 하는 방식
- 초기 복제 데이터 시스템은 대부분 리더가 없었다. 이 개념은 관계형 데이터베이스가 우세한 시대에는 인기가 없다가 
아마존이 내부 다이나모 시스템에서 사용한 후 다시 데이터베이스용 아키텍처로 유행했다.
- 다이나모 스타일 DB 
→  리악, 카산드라, 볼드모트 등 오픈소스 데이터스토어가 있음
- 일부 리더 없는 복제 구현에서는 클라이언트가 여러 복제 서버에 쓰기를 직접 전송하는 반면 **`코디네이터 노드(coordinator node)`가 클라이언트를 대신해 이를 수행**하기도 함

## 3-1. 노드가 다운 됐을 때 데이터베이스 쓰기

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/fe5d7f0e-3b33-4513-9b73-373a7fef9157/93157b6c-3b04-4f72-badc-40bc9e5d73a9/Untitled.png)

리더 기반 설정에서 쓰기 처리를 계속 하려면 장애 복구를 실행해야한다. 하지만 **리더가 없는 설정에서는 장애 복구가 필요하지 않다.**

- 클라이언트가 쓰기를 세개의 모든 복제 서버에 병렬로 전송한다.
- 사용 가능한 두개의 복제 서버는 쓰기를 받았지만 사용 불가능한 복제써버는 쓰기를 놓쳤다.
- (3개 복제서버 중 2개의 복제서버가 쓰기를 확인하면 충분하다고 가정해보자) 두개의 응답을 받은 사용자는 쓰기가 성공한 것으로 간주한다.
- 클라이언트는 복제 서버중 하나가 쓰기를 놓친 사실을 무시한다.
- 이때 다시 다운된 복제 서버가 살아난다면, 그동아느이 쓰기는 해당 노드에서 누락됐기 때문에 클라이언트의 읽기 요청에 오래된(outdated) 값을 반환할 수 있음
- 이를 해결하기 위해 **읽기 요청을 병렬로 여러 노드에 전송**하는 방식을 취함. 두 리턴 값에 대한 버전 숫자를 활용해 최신값을 반환

## 3-2. **읽기 복구와 안티 에트로피**

**사용 불가능한 노드가 온라인 상태가 된 후 누락된 쓰기를 어떻게 따라잡아야할까?** 

**다이나모 스타일 데이터스토어**는 아래 **두가지 매커니즘**을 주로 사용한다. 

→ 볼드모트는 현재 안티 엔트로피 처리를 하지 않는데, 처리가 없으면 읽기 복구는 애플리케이션 값을 읽는 경우에만 수행되기 때문에 거의 읽지 않는 값은 일부 복제본에서 누락된다. (내구성 ▼)

> 읽기 복구
> 
- 클라이언트가 여러 노드에서 병렬로 읽기를 수행하면 오래된 응답을 감지할 수 있다.
- 오래된 값이라는 사실을 알게되면 해당 복제서버에 새로운 값으 ㄹ다시 기록한다. → 이 접근 방식은 값을 자주 읽는 상황에 적합하다.

> 안티 엔트로피 처리
> 
- 일부 데이터 스토어는 백그라운드 프로세스를 두고 복제 서버간 **데이터 차이를 지속적으로 찾아 누락된 데이터를 하나의 복제 서버에서 다른 서버로 복사**한다.
- 리더 기반 복제에서의 복제로그와 달리 이 안티 엔트로피 처리는 **특성 순서로 쓰기를 복사**하기 때문에 데이터 복사까지 상당한 **지연시간 발생이 가능**하다.

## 3-3. 읽기와 쓰기를 위한 정족수

![정족수가 w + r > n 인 환경의 읽기/쓰기](https://prod-files-secure.s3.us-west-2.amazonaws.com/fe5d7f0e-3b33-4513-9b73-373a7fef9157/e8b1a96d-cf09-4c15-99f6-efb03b51a6bb/Untitled.png)

정족수가 w + r > n 인 환경의 읽기/쓰기

**이전에 복제 서버 3개 중 2개에서만 처리해도 성공한 것으로 간주했다. 3개의 복제 서버중 1개만 쓰기를 허용한다면 어떻게 해야될까? (범위 허용을 어디까지?)**

- `**n개**의 복제 서버`가 있을 때 **모든 쓰기**는 `**w**개의 노드`에서 성공해야 쓰기가 확정되고 **모든 읽기**는 최소한 `**r**개의 노드`에 질의해야 한다.
→ 예시 : 복제서버) **n=3**, 
              쓰기)**w=2**, 
              읽기) **r=2**
    - w+r > n : 읽을 때 최신 값을 얻을 것으로 기대한다. 최소한 r개의 노드 중 하나에서 최신 값을 얻을 수 있기 때문
    - 이런 w와 r을 따르는 읽기와 쓰기를 `정족수 읽기와 쓰기`라고 부른다. → 유효한 읽기와 쓰기를 위해 필요한 최소 투표수를 r과 w로 생각할 수 있다.
        
        > *정족수(**Quorum)**란? 
        쿼럼은 좁은 의미에서는 어떤 동작을 하기 위해서 필요한 최소한의, 동등한 무언가들의 찬성표 개수를 뜻한다. 
        넓은 의미에서는 특정 행위를 하기 위해서 정족수가 필요하다는 규칙을 가리킨다.
        > 
- 다이나모 스타일 데이터베이스에서는 n,w,r 파라미터는 대게 설정 가능하다.
    - ***n은 홀수(3|5) , w = r = (n + 1) / 2 (반올림)***
- 정족수 조건이 w+r>n 이면 다음과 같이 사용 불가능한 노드를 용인한다.
    - w < n이면 노드 하나를 사용할 수 없어도 여전히 쓰기를 처리할 수 있다.
    - r < n이면 노드 하나를 사용할 수 없어도 여전히 읽기를 처리할 수 있다.
    - n = 3, w = 2, r = 2이면 사용 불가능한 노드 하나를 용인한다.
    - n = 5, w = 3, r = 3이면 사용 불가능한 노드 둘을 용인한다.
    - 일반적으로 읽기와 쓰기는 항상 모든 n개의 복제 서버에 병렬로 전송한다.

## 3-4. ****정족수 일관성의 한계****

n개의 복제 서버가 있고, w+r > n 이 되게끔 w와 r을 선택한다면 일반적으로 모든 읽기는 키의 최신 값을 반환할 것을 기대한다. 
이는 쓰기를 하는 노드 셋과 읽기를 하는 노드 셋이 겹치기 때문이다. (읽은 노드 중 최신값 가진 노드가 하나 이상 있어야함)

정족수가 읽기 시 최근에 쓴 값을 반환하게끔 보장하지만 실제로는 그렇게 간단하지 않다. 매개변수 w와 r로 오래된 값을 읽는 확률을 조정할 수 있지만 이를 절대적으로 보장할 수는 없다.

읽기, 쓰기 정족수가 w + r > n 을 만족하는 경우에도 오래된 값을 반환하는 **에지 케이스**가 있다.

- **느슨한 정족수**를 사용할 경우 쓰기가 완료된 노드와 읽기 대상 노드가 겹치지 않을 수 있다. 즉, **r개의 노드와 w개의 노드가 겹치지 않는 것을 보장하지 않는다.**
- 동시에 두 개의 쓰기가 발생할 경우 쓰기 순서가 불분명하다.
    - 안전 해결책은 동시 쓰기를 합치는 방법이다. 만약 타임스탬프를 기준으로 순서를 정하면(최종쓰기 승리,LWW), 시계 스큐(clock skew)로 인해 쓰기가 유실될 수 있다.
- 읽기와 쓰기가 동시에 발생하면, 쓰기는 일부 복제 서버에만 반영될 수 있다. 이 경우 읽기가 최신 값을 반환하는지 여부가 분명하지 않다.
- 쓰기가 일부 성공 일부 실패로 설정한 w 수보다 성공 서버가 낮을 경우
    - 성공한 복제 서버에서는 롤백하지 않는다. 쓰기가 실패한 것으로 보고될 경우 이어지는 읽기에 해당 쓰기 값이 반환될 수도 아닐 수도 있다.
- 새 값을 전달하는 노드가 고장날 경우
    - 예전 값을 가진 노드에서 데이터가 복원되고, 새로운 값을 저장한 노드 수가 W보다 낮아져 정족수 조건이 깨질 수 있다.
- 모든 과정이 정상 동작해도 **시점**의 문제로 에지 케이스가 있을 수 있다. (331pg 선형성과 정족수에서 살펴봄)

### **최신성 모니터링**

운영 관점에서 DB가 최신 결과를 반환하는지 모니터링하는 것은 매우 중요하다. → 복제가 늦춰진다면 원인(예를 들어 네트워크 문제나 과부하 노드)를 조사할 수 있게 알려줘야하기 때문

**리더 기반 복제**

- 복제 지연에 대한 지표를 노출하며 모니터링 시스템에 제공된다.
    - 모든 쓰기가 리더를 통하기에 가능한 구조이다.
    - 리더의 현재 위치에서 팔로워의 현재 위치를 빼면 복제 지연량 체크도 가능하다.

**리더 없는 복제**

- 쓰기가 적용된 순서를 고정할 수 없기 때문에 모니터링이 더 어렵다.
- 읽기 복구만 사용(안티 엔트로피)하는 경우 읽기가 드문 값은
    - 얼마나 오래된 값인지 제한이 없어 아주 오래된 값일 수 있다.
- (일반적 사례는 아님) 복제 서버의 오래됨(staleness)을 측정하고 매개변수 n,w,r에 따라 오래된 값을 읽는 비율을 예측하는 연구가 있었다.
    - 데이터 베이스를 위한 표준 지표 셋에 오래됨을 측정하게끔 추가하는 작업(시도)였기 때문에 긍정적인 방안이다.
    - 최종적 일관성은 의도적으로 모호한 보장이지만 운용성을 위해서는 ‘최종적’을 정량화할 수 있어야한다.

[data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==](data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==)

## 3-5. **느슨한 정족수와 암시된 핸드오프**

적절히 설정된 정족수가 있는 데이터베이스는 장애 복구 없이 개별 노드 장애를 용인한다.

하지만 지금까지 설명한 대로 정족수는 `내결함성`이 없다. 
네트워크 중단으로 다수의 데이터베이스 노드와 클라이언트는 쉽게 연결이 끊어질 수 있다. DB노드들이 모두 정상이라 할지라도 DB 노드들이 모두 죽은 것과 동일하다.

노드가 n개 이상인 대규모 클러스터에서 클라이언트는 네트워크 장애 상황에서 일부 데이터베이스 노드(특정 값을 위한 정족수 구성에 들어가지 않는 노드)에 연결될 가능성이 있다.

- w나 r 노드 정족수를 만족하지 않는 모든 요청에 오류를 반환하는 편이 좋을까? (일반적)
- 아니면 일단 쓰기를 받아들이고 값이 보통 저장되는 n개 노드에 속하지는 않지만 연결할 수 있는 노드에 기록할까? **(`느슨한 정족수`)**
    
    > * `느슨한 정족수`→  비유하자면, 내 집 문에 잠겼을 때 옆 집 문을 두드려 소파에 잠시 머물 수 있는지 묻는 것
    > 
    > - **쓰기 가용성을 높히는데 특히 유용하다.**
    > - **암시된 핸드오프**가 완료될 때까진 r노드의 읽기가 저장된 데이터를 본다는 보장이 없다.
    > - 모든 일반적인 다이나모 구현에서 선택사항이다.
    >     - 리악에서는 기본적으로 활성화
    >     - 카산드라, 볼드모트는 비활성화

쓰기와 읽기는 여전히 w와 r의 성공 응답이 필요하지만 값을 위해 지정된 n개의 "홈" 노드에 없는 노드가 포함될 수 있다.

네트워크 장애 상황이 해제되면 한 노드가 다른 노드를 위해 일시적으로 수용한 모든 쓰기를 해당 "홈" 노드로 전송하게 되는데 이를 **`암시된 핸드오프`** 라 한다.

### 다중 데이터 센터 운영

**리더 없는 복제**도 동시 쓰기 충돌, 네트워크 중단, 지연 시간 급증을 허용하기 때문에 다중 데이터센터 운영에 적합하다.

여러 DB 시스템은 각각의 방식으로 다중 데이터 센터 지원을 구현했는데,

- 카산드라 & 볼드모트
    - n 개의 복제 서버 수에는 모든 데이터센터의 노드가 포함되고, 설정에서 각 데이터센터마다 n개의 복제 서버 중 몇개를 보유할지 지정할 수 있다.
    - 클라이언트의 각 쓰기는 데이터 센터 상관없이 모든 복제 서버에 전송되지만,
    - 클라이언트는 로컬 데이터센터 안에서 정족수 노드의 확인 응답을 기다리기에 데이터센터간 연결의 지연과 중단에 영향을 받지 않는다
    - 다른 데이터센터에 대한 높은 지연 시간의 쓰기는 대게 비동기로 발생하게끔 설정한다.
- 리악
    - 클라이언트와 DB간 연결이 하나의 데이터센터에서 이뤄지기 때문에, n은 하나의 데이터센터 안에 있는 복제 서버 수를 나타낸다.
    - DB 클러스터의 데이터센터간 복제는 백그라운드에서 비동기로 일어나고 다중 리더 복제 방식과 유사하다.

## 3-6. **동시 쓰기 감지**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/fe5d7f0e-3b33-4513-9b73-373a7fef9157/6e5d15f3-ba6a-427a-b5a7-1e217700c765/Untitled.png)

다이나모 스타일 데이터베이스는 여러 클라이언트가 동시에 같은 키에 쓰는 것을 허용하기 때문에 충돌이 발생한다. 그렇기에 엄격한 정족수를 사용해도 충돌이 발생할 수 있다.

최종적 일관성을 달성하기 위해 복제본들은 동일한 값이 돼야 한다.

### **최종 쓰기 승리(LWW)**

각 복제본이 가진 "예전" 값을 버리고 가장 "최신" 값으로 덮어쓰는 방법이 있다. → 가장 최신 값으로 모든 복제 서버를 덮어쓰는 방식

여기서 최신 값이 무엇인지 이벤트 순서가 정해지지 않았기에 알 수 없지만, 임의로 순서를 정할 수 있다. 

이때 쓰기에 타임스탬프를 붙여 가장 "최신"이라는 의미로 제일 큰 타임스탬프를 선택하고 예전 타임스탬프를 가진 쓰기는 무시하는 충돌해소 알고리즘을 `최종 쓰기 승리(LWW)`라 부른다.

> `최종 쓰기 승리(LWW)`
> 
> - 최종적 수렴 달성이 목표지만, 지속성을 희생한다.
> - 손실 데이터를 허용하지 않는다면 LWW가 충돌 해소에 적합하지 않다.
>     - 캐싱과 같이 손실된 쓰기를 허용하는 사오항이 있다. 키를 최초 쓰기 후 **불변 값(immutable variable)**으로 다룸으로써 안전하게 사용할 수 있다.

### **"이전 발생" 관계와 동시성**

작업 B가 작업 A에 대해서 알거나 A에 의존적이거나 어떤 방식으로든 A를 기반으로 한다면 작업 A는 작업 B의 **happens-before**이다.

작업이 다른 작업보다 먼저 발생하지 않으면 **동시 작업**이라고 말한다.

작업이 동시에 발생한 것을 어떻게 알 수 있을까?

![B가 증가시키는 값(value + 1)은 A가 삽입한 값이기에 순서가 있다. 
B는 A에 `인과성이 있다(causally dependent)`고 한다](https://prod-files-secure.s3.us-west-2.amazonaws.com/fe5d7f0e-3b33-4513-9b73-373a7fef9157/7176426c-0e63-4582-ace2-e68a61efd911/Untitled.png)

B가 증가시키는 값(value + 1)은 A가 삽입한 값이기에 순서가 있다. 
B는 A에 `인과성이 있다(causally dependent)`고 한다

작업 A와 B가 있다고 할때 

`이전 발생(**happens-before)**`

- 작업 A와 B가 있다고 할때  B가
A를 알거나, A에 의존적이거나, A를 기반으로 한다면 A는 B작업의 이전 발생이다.
- 한 작업이 다른 작업 이전에 발생했는지가 동시성의 의미를 정의하는 핵심이다.

`동시 작업`

- 작업 A와 B가 서로에 대해, 알지도 못하고 의존하지도 않고 기반으로 하지도 않는다면 동시작업이라 칭한다.

![각 클라이언트가 작업을 시작할 때 모두 동일한 키에 작업을 수행했는지 알 수 없다. 따라서 작업 간에 **`인과성이 없다.`**](https://prod-files-secure.s3.us-west-2.amazonaws.com/fe5d7f0e-3b33-4513-9b73-373a7fef9157/06c2d7b7-a756-4137-8158-07f2d676e290/Untitled.png)

각 클라이언트가 작업을 시작할 때 모두 동일한 키에 작업을 수행했는지 알 수 없다. 따라서 작업 간에 **`인과성이 없다.`**

### **이전 발생(happens-before) 관계 파악하기**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/fe5d7f0e-3b33-4513-9b73-373a7fef9157/c98cca3b-87f1-48a7-839f-7375bd00d10a/Untitled.png)

- 서버가 모든 키에 대한 버전 번호를 유지하고 키를 기록할 때마다 버전 번호를 증가시킨다.
- 클라이언트가 키를 읽을 때는 서버는 최신 버전뿐만 아니라 덮어쓰지 않은 모든 값을 반환한다.
- 클라이언트가 키를 기록할 때는 이전 읽기의 버전 번호를 포함해야 하고 이전 읽기에서 받은 모든 값을 함께 합쳐야 한다.
- 서버가 특정 버전 번호를 가진 쓰기를 받을 때 해당 버전 이하 모든 값을 덮어쓸 수 있다.

쓰기가 이전 읽기의 버전 번호를 포함하면 쓰기가 수행되지 이전 상태를 알 수 있다.

버전 번호를 포함하지 않은 쓰기는 다른 쓰기와 동시에 수행된 것이므로 아무것도 덮어쓰지 않는다.

### **동시 값 병합**

여러 작업이 동시에 발생하면 클라이언트는 동시에 쓴 값을 합쳐 정리해야 한다.

형제 값 병합은 다중 리더 복제에서 충돌을 해소하는 문제와 본질적으로 같다.

형제를 병합할 때 삭제한 아이템이 합집합에서 재등장할 수 있기 때문에, 해당 버전 번호에 표시를 남겨둔다. **(툼스톤)**

애플리케이션 코드에서 형제 병합은 복잡하고 오류가 발생하기 쉽다.

자동 병합을 수행할 수 있게 데이터 구조를 설계하려는 노력이 있다. (CRDT)

### **버전 벡터**

지금까지는 단일 복제본을 가지고 얘기를 했지만, 복제본이 단일이 아닌 다중 복제본이 된다면, 단일 버전 번호만 가지고는 충분하지 않다. 키 뿐 아니라 **복제본당** 버전 번호도 사용해야 한다.

각 복제본은 쓰기를 처리할 때 자체 버전 번호를 증가시키고 각기 다른 복제본의 버전 번호도 계속 추적해야 한다.

이런 모든 복제본의 버전 번호 모음을  **버전 벡터(version vector)**라 부른다.

**버전 벡터는**

- 값을 읽을 때 DB 복제본에서 클라이언트로 보낸다.
- 값을 기록할 때 DB로 다시 전송해야 한다.
- 사용하기에 따라서 DB는 덮어쓰기와 동시 쓰기를 구분할 수 있게 된다.
- 형제 병합시
    - 하나의 복제본을 읽은 다음 다른 복제본에 다시 쓰는 작업이 안전함을 보장한다.
    - 형제가 올바르게 병합되는 한 데이터 손실은 없다.
