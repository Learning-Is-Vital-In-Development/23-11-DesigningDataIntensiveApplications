## 리더 없는 복제

일부 데이터 저장소 시스템은 리더의 개념을 버리고 모든 복제 서버가 클라이언트로부터 쓰기를 직접 받을 수 있게 허용하는 접근 방식을 사용하기도 한다.(다이나모DB, 카산드라 등)

이런 종류의 데이터베이스를 다이나모 스타일 이라 한다.

일부 리더 없는 복제 구현에서는 클라이언트가 여러 복제 서버에 쓰기를 직접 전송하는 반면 코디네이터 노드가 클라이언트를 대신해 이를 수행하기도 한다. 하지만 리더 데이터베이스와 달리 코디네이터 노드는 특정 순서로 쓰기를 수행하지 않는다.

## 노드가 다운됐을 때 데이터베이스에 쓰기

리더 없는 설정에서는 장애 복구가 필요하지 않다. 노드가 다운 되었다 다시 온라인 상태가 될 경우 다운된 동안 발행한 모든 쓰기는 누락되었지만, 이 문제를 해결하기 위해 클라이언트가 데이터베이스에서 읽을 때 하나의 복제 서버로 요청을 보내지 않고 읽기 요청을 병렬로 여러 노드에 전송한다.

한 노드에서 최신 값을 받고 다른 노드에서는 오래된 값을 받을 경우 버전 숫자를 활용해 최신 내용이 어떤 값인지 결정 한다.

## 읽기 복구와 안티 엔트로피

복제 계획은 최종적으로 모든 데이터가 모든 복제 서버에 복사된 것을 보장해야 한다. 그렇다면 사용 불가능한 노드가 온라인 상태가 된 후 누락된 쓰기를 어떻게 따라잡아야 할까

- 읽기복구 : 여러 노드에서 병렬로 읽기를 수행하면 오래된 데이터를 포함했는지 감지할 수 있으며, 오래된 데이터가 감지되면 복구를 수행한다.
- 안티 엔트로피 처리 : 백그라운드 프로세스를 두어 복제 서버 간 데이터 차이를 지속적으로 찾아 누락된 데이터를 하나의 복제 서버에서 다른 서버로 복사한다.(특성 순서로 쓰기를 복사하기 때문에 데이터가 복사되기까지 상당한 지연이 있을 수 있다.)

## 읽기와 쓰기를 위한 정족수

**n개의 복제 서버**가 있을 때 **w개의 노드**에 **쓰기 성공이 보장**되고 **읽기는 r개 노드**로 수행되는 경우에 `w + r > n`의 경우 항상 최신 값을 읽는 것을 기대한다.

이러한 r과 w를 따르는 읽기와 쓰기를 `정족수 읽기와 쓰기`라고 부른다.

다이나모 스타일 데이터베이스에서 n, w, r파라미터는 대개 설정이 가능하며, 각 상황에 맞게 설정하여 사용이 가능하다.

정족수 조건이 w+r > n이면 아래와 같이 사용불가능한 노드를 용인한다.

- w < n이면 노드 하나를 사용할 수 없어도 여전히 쓰기를 처리할 수 있다.
- r<n이면 노드 하나를 사용할 수 없어도 여전히 읽기를 처리할 수 있다.
- n=3, w=2, r=2이면 사용 불가능한 노드 하나를 용인한다.
- n=5, w=3, r=3 이면 사용 불가능한 노드 둘을 용인한다.

## 정족수 일관성의 한계

무조건 정족수가 다수일 필요는 없다. 읽기와 쓰기 동작에서 사용하는 노드 셋 중 적어도 하나의 노드만 겹치면 된다. 다른 정족수 할당이 가능하기 때문에 분산 알고리즘 설계에서 어느 정도 유연성을 허용한다.(w와 r을 더 작은 수로 설정해 w+ r ≤ n이 되게끔 설정할 수 도 있다. 이 경우에는 읽기와 쓰기를 계속 n개의 노드로 전송하지만 성공에 필요한 성공 응답의 수는 더 적다.)

w와 r이 작을수록 오래된 값을 읽을 확률이 높다. 최신 값을 가진 노드가 읽을 노드에 포함되지 않을 가능성이 높기 때문이다. 하지만, w+r>n인 경우에도 오래된 값을 반환하는 에지 케이스가 있다.

- 느슨한 정족수를 사용한다면, w개의 쓰기는 r개의 읽기와 다른 노드에서 수행될 수 있어 겹치는 것을 보장하지 않는다.
- 두 개의 쓰기가 동시에 발생하면 어떤 쓰기가 먼저 일어났는지 분명하지 않다.(동시 쓰기를 합치는 방법밖에 없다.)
- 쓰기와 읽기가 동시에 발생하는 경우 일부 복제 서버에만 반영이 되어있을 수도 있다. 이 경우 정족수 읽기는 최신 값을 반환하지 않을 수 있다.
- 쓰기가 일부 복제 서버에 성공했으나 w수를 만족하지 못해도 성공한 서버는 롤백하지 않는다. 클라이언트에게 쓰기가 실패했다고 보고되어도 이어지는 읽기에 새로 쓰인 값이 반환될 수도 있다.

## 최신성 모니터링

리더 기반 복제에서 데이터베이스는 일반적으로 복제 지연에 대한 지표를 노출한다. 이 지표는 모니터링 시스템에 제공된다. 이것은 쓰기가 리더에 적용되고 같은 순서로 팔로워에도 적용되고 각 노드가 복제 로그의 위치를 가지기 때문에 가능하다.

하지만 리더 없는 복제 시스템에서는 쓰기가 적용된 순서를 고정할 수 없어 모니터링이 조금 더 어렵다. 더욱이 데이터베이스가 읽기 복구만 사용 한다면 자주 읽히지 않는 값이 얼마나 오래 된 값인지에 대한 제한이 없다.(아주 오래된 값일 수 있다.)

- 실질적으로 모니터링에 대한 표준 모범 사례가 없는거 같다.

## 느슨한 정족수와 암시된 핸드오프

오래된 값 읽기를 허용하는 사용 사례에는 리더 없는 복제 기능을 가진 데이터베이스가 매력적이다.

하지만 정족수는 내결함성이 없다. 네트워크 중단으로 다수의 데이터베이스 노드와 클라이언트는 쉽게 연결이 끊어질 수 있다.

노드가 n개 이상인 대규모 클러스터에서 클라이언트는 네트워크 장애 상황에서 특정 값을 위한 정족수 구성에 들어가지 않는 노드에 연결될 가능성이 있으며 이 경우 데이터베이스 설계자는 트레이드오프에 직면한다.

노드가 n개 이상인 대규모 클러스터에서 특정 값을 위한 정족수가 충족되지 못하더라도 n에 포함되지 않은 다른 노드에 우선적으로 쓰기를 기록하는 방식을 **`느슨한 정족수`**라고 부른다.

- A, B, C, D 노드가 존재할 때 특정 값에 대한 복제 노드는 A, B, C(n=3)라고 하자. 이 경우 정족수는 2가 된다.
- 그런데 A, B 노드가 갑자기 다운되어 특정 값을 C노드에만 쓸 수 있는 경우 정족수를 충족시키지 못하므로 실패해야 한다.
- 여기서 n에 속하지 않은 D노드에 해당 쓰기를 임시적으로 수용하도록하고 B, C노드가 복구되면 해당 쓰기를 B, C노드로 전송하도록 한다.
- 이러한 방식을 `암시된 핸드오프`라고 부른다.

느슨한 정족수는 쓰기 가용성을 높이는데 유용하지만 `w + r > n`인 경우에도 강력한 일관성을 보장하지 않는다.

## 동시 쓰기 감지

다이나모 스타일 데이터베이스는 여러 클라이언트가 동시에 같은 키에 쓰는 것을 허용하기 때문에 엄격한 정족수를 사용하더라도 충돌이 발생한다.

![image](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/71249347/76c6844f-215d-44a0-8bb9-57818960acc6)

각 노드가 클라이언트로부터 쓰기 요청을 받을 때마다 키의 값을 단순하게 덮어 쓸경우 노드들은 영구적으로 일관성이 깨진다.

## 최종 쓰기 승리(동시 쓰기 버리기)

최종적으로 값을 수렴하기 위한 접근 방식 하나는 각 복제본이 가진 “예전” 값을 버리고 가장 “최신”값으로 덮어 쓰는 방법이다. 어떤 쓰기가 “최신”인지 명확하게 결정할 수 있는 한 모든 쓰기는 최종적으로 모든 복제 서버에 복사되므로 복제본은 최종적으로 동일한 값으로 수렴한다.

비록 쓰기는 자연적인 순서가 없지만 임의로 순서를 정할 수 있다. 타임스탬프를 붙여 가장 “최신”이라는 의미로 제일 큰 타임스탬프를 선택하고 예전 타임스탬프를 가진 쓰기는 무시한다. 이를 `최종 쓰기 승리(LWW)`라고 한다.

이 방식은 동시에 여러번이 쓰기가 있다하더라도 모든 클라이언트는 성공으로 응답을 받지만 결국 최종적으로 하나만 쓰고 나머지는 무시되므로 지속성이 희생된다.

LWW로 데이터베이스를 손실 없이 안전하게 사용하는 유일한 방법은 키를 한번만 쓰고 이후에는 불변 값으로 다루는 것이다.(ex. UUID)

### “이전 발생” 관계와 동시성

작업 B가 A에 대해서 알거나 A에 의존적이거나 어떤 방식으로든 A를 기반으로 한다면 작업 A는 작업 B의 `이전발생` 이다. 한 작업이 다른 작업 이전에 발생했는지가 동시성의 의미를 정의하는 핵심이다.

사실 작업이 다른 작업보다 먼저 발생하지 않으면 단순히 `동시 작업` 이라 말한다.
한 작업이 다른 작업 전에 발생한다면 나중 작업은 이전 작업을 덮어쓸 수 있지만 작업이 동시에 발생하면 충돌을 해소해야 한다.

### 이전 발생 관계 파악하기

![image](https://github.com/akfls221/23-11-DesigningDataIntensiveApplications/assets/71249347/050278ca-848d-432f-ade4-7460eb775eb0)

화살표는 어떤 작업이 다른 작업 이전에 발생했는지와 나중 작업이 이전에 수행된 작업을 알거나 의존했다는 사실을 나타낸다. 클라이언트는 서버 데이터와 동일한 최신 상태로로 유지하지 못하나 예전 버전의 값을 덮어쓰기 때문에 손실된 쓰기는 없다.

서버는 버전 번호를 보고 두 작업이 동시에 수행됐는지 여부를 결정할 수 있으므로 값 자체를 해석할 필요는 없다.

쓰기가 이전 읽기의 버전 번호를 포함하면 쓰기가 수행되기 이전 상태를 알 수 있으며, 버전 번호를 포함하지 않은 쓰기는 다른 쓰기와 동시에 수행된 것으로 아무것도 덮어쓰지 않는다.
