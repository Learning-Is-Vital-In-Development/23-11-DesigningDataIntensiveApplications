# 리더 없는 복제

일부 데이터 저장소는 리더를 버리고 모든 노드가 쓰기 작업을 할 수 있도록 했다. 이를 구현할 때는 클라이언트가 직접 노드에 쓰기 요청을 보낼 수도 있지만, 코디네이터를 통해서 보낼 수도 있다. 이러한 설계의 차이는 이후 데이터베이스 사용에 큰 차이가 있다.

## 노드가 다운됐을 때 데이터베이스에 쓰기

리더 기반 쓰기로 동작할 경우에는 하나의 노드가 다운됐을 때 복제 서버를 복구 처리해야 한다. 하지만 모든 서버에서 쓰기 처리할 경우에는 하나의 노드가 다운되더라도 클라이언트는 모든 노드에 병렬적으로 요청하기 때문에 나머지 노드들에서 정상적으로 쓰기가 될 경우에 정상적으로 동작합니다.

만약 노드가 부활한다면 별도의 복구 작업 없이 바로 동작하며 사용자가 읽기 요청을 할 경우 다운된 동안 추가된 데이터들은 누락되어 오래된 값을 반환할 수 있다. 하지만 다른 노드들에서 정상적인 값을 반환하면 값의 버전을 통해서 클라이언트에게 최신 값을 응답한다.

### 읽기 복구와 안티 엔트로피

복구된 노드의 데이터 누락을 복구하기 위한 두 가지 방법은 읽기 복구와 안티 엔트로피이다.

읽기 복구는 읽기 시에 최신 데이터를 반환하지 않는 노드에게 반환 받은 최신 데이터를 쓰기 처리해서 데이터 누락을 복구하는 전략이다. 데이터를 자주 읽는 상황에서 유용하다. 만약 데이자

### 읽기와 쓰기를 위한 정족수

전체 복제 서버의 수를 n이라고 하면 쓰기 작업을 성공했다고 판단하는 노드의 수를 w, 읽기 작업을 성공했다고 판단하는 노드의 수를 r이라고 할 수 있다.

이때 $w + r > n$  이라면 최신 값을 얻을 수 있다고 보장한다. 왜냐하면 최소 1개 이상 쓰기 처리된 데이터가 r개의 읽기 노드에 포함되기 때문이다. 보통 n은 홀수로 처리하고 w,r은 절반에서 반올림해서 처리한다. w < n, r < n 인 상황이라면 노드의 장애를 무시할 수 있다. 만약 이보다 작아진다면 에러를 반환해야 한다.

만약 쓰기보다 읽기가 압도적으로 많다면 w = n , r = 1 로 처리할 수 있다. 읽기 성능을 극단적으로 올릴 수 있다. 하지만 이럴 경우 1개 노드라도 문제가 생기면 쓰기 작업을 할 수 없다.

### 정족수 일관성의 한계

일반적으로 쓰기 정족수와 읽기 정족수의 합이 전체보다 크다면 최소 1개 이상의 최신 데이터를 가지는 노드가 존재하기 때문에 문제가 없다. 하지만 그럼에도 구현에 따라 다르지만 엣지케이스가 있다.

- 느슨한 정족수를 사용할 경우
- 동시에 2개의 쓰기가 발생했을 경우
- 쓰기와 읽기가 동시에 일어난 경우
- 쓰기가 일부 복제 노드에서만 성공하여 정족수를 못 채웠을 때에도 롤백하지 않았을 때, 읽기 과정에서 해당 쓰기 값이 반환될 수도 아닐 수도 있다는 의미다.
- 새 값을 전달하는 노드가 고장나면 예전 값을 가진 다른 복제 서버에서 해당 데이터가 복원되고 새로운 값을 저장한 복제 서버 수가 낮아져 정족수 조건이 깨진다.
- 선형성과 정족수

견고한 보장은 트랜잭션이나 합의가 필요하다.

### 최신성 모니터링

리더 기반 복제 쓰기 같은 경우에는 일반적으로 복제 지연에 대한 지표들을 노출하여 모니터링할 수 있도록 하고 있다. 하지만 쓰기 순서를 강제할 수 없고 읽기 복구만 사용한다면 자주 사용되지 않은 오래된 값들이 문제가 될 수 있다. 최종적 일관성은 모호한 보장이지만 최종적이라는 의미는 명확하게 정량화할 수 있어야 한다.

### 느슨한 정족수와 암시된 핸드오프

장애로 인해 응답가능한 노드의 수가 정족수(w,r)보다 적어질 수 있다. 이때 모든 정족수에 맞지 않는 요청에 대해서 오류를 반환하거나 일단 쓰기를 받고 저장되는 노드에 속하지는 않지만 연결 가능한 노드에 기록을 할지 선택하게 된다. 이때 후자를 선택하여 정족수 조건을 유지하는 것은 `느슨한 정족수`라고 한다.

느슨한 정족수는 여전히 w,r 의 정족수를 요구하지만, 저장 가능한 노드가 아닌 임시로 띄어진 노드가 정족수에 포함될 수 있다. 그리고 장애 해결 이후 한 노드가 그동안 수용한 모드 쓰기 동작을 저장 가능한 노드들에게 전파하는 것을 `암시된 핸드오프`라고 한다.

느슨한 정족수는 엄격한 의미의 정족수가 아니지만 이후에 다시 기록할 수 있는 어떤 노드에 저장되고 있다는 것을 의미한다.

### 다중 데이터센터 운영

카산드라와 볼드모트는 리더 없는 모델로 다중 데이터 센터를 구현하고 n개의 복제 노드 서버 수에 모든 데이터 센터의 노드가 포함된다. 각 데이터 센터마다 n개의 노드 중 몇개를 보유할 지 지정할 수 있다. 클라이언트의 쓰기는 모든 노드들에게 전파되지만 로컬 데이터 센터 안에서 정족수 노드의 확인 응답을 기다림으로서 다른 데이터 센터와의 통신을 최소화 한다.

리악은 클라이언트와 데이터베이스간 모든 연결이 하나의 데이터센터의 로컬에서 이뤄지기 떄문에  n개의 복제센터는 하나의 데이터 센터 로컬 서버 수를 의미한다. 복제는 백그라운드에서 비동기로 일어난다.

### 동시 쓰기 감지

다양한 네트워크 지연과 부분적인 장애로 인해서 각 노드에게 데이터는 다른 시간에 도착할 수 있다. 이때 동시에 같은 키에 대한 쓰기가 발생했을 경우 단순히 덮어 쓰기를 했을 때는 데이터의 정합성이 깨질 수 있다.

### 최종 쓰기 승리(동시 쓰기 버리기)

최종 쓰기 승리는 말 그대로 가장 최종적인 데이터를 쓰기 값으로 받아 드리는 것이다. 동시에 쓰기 때문에 명확하게 어떤 쓰기가 최종적인 것인지 말할 수 없다. 따라서 이를 정할 수 있는 명확한 기준을 정의하고 이 기준에 따라서 최종 쓰기를 판별하고 결정한다.

최종 쓰기 승리(LWW)은 최종적 수렴 달성이 목표지만 지속성을 희생한다. 동시 쓰기로 인해 버려지는 동작들도 w개 이상의 노드에게 응답을 받아 성공이라고 보고될 수 있기 때문이다.

손실된 데이터를 허용하지 않는다면 LWW은 적절한 충돌해소 방안이 아닐 수 있다.

### “이전 발생” 관계와 동시성

A,B라는 두 가지 행위에 대해서는 “A가 먼저, B가 먼저, 동시에”라는 3가지 선후 관계를 가진다. 선후관계를 결정할 때는 이전 발생여부를 확인하게 되는데 이는 하나의 행위가 다른 행위에 의존하고 있는 지 여부이다. 즉, 의존하고 있지 않다면 동시에 발생했다고 생각한다. 왜냐하면 분산시스템에서 시간을 통해 엄밀한 선후관계를 찾는 것이 매우 어렵기 때문이고 실제로 시간적 선후관계가 비즈니스의 의미적인 선후 관계가 아닐 수 있기 때문이다.

### 이전 발생 관계 파악하기

쓰기 버전을 만들고 이전 쓰기 버전을 주고 받음으로서 동시 쓰기를 관리한다. 데이터 베이스는 최신 버전과 덮어쓰여지지 않은 이전 버전을 보여준다.

### 동시 쓴 값 병합

여러 작업이 동시에 발생하면 클라이언트는 동시에 쓴 값(리악에서는 이를 형제(sibling)이라고 한다.)을 합쳐서 정리해야한다. 형제간 병합 과정에서 데이터가 삭제된다면 이를 병합과정에서 삭제했다고 표시를 남겨야 한다. 이를 툼스톤이라고 한다.

이러한 충돌을 자동으로 해소 할 수 있도록 데이터 구조를 잘 설계하는 것도 중요한다. 리악에서는 CRDT라는 데이터 구조군을 사용한다.

[CRDT vs OT (Channel Corp. Tech Blog)](https://channel.io/ko/blog/crdt_vs_ot)

### 버전 벡터

단일 복제본이 아닌 다중 복제본이라면 다양한 복제본에서 버전을 관리해야 한다. 모든 복제본의 버전 번호 모음을 버전 벡터(version vector)라고 한다.

리악에서는 [도티드 버전 벡터(dotted version vector)](https://riak.com/products/riak-kv/dotted-version-vectors/index.html?p=10941.html)를 사용한다. 이러한 버전 벡터를 주고 받음으로서 덮어쓰기와 동시 쓰기를 구분할 수 있다.
