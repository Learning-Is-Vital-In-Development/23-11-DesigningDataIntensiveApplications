# 리더 없는 복제

- 복제 접근 방식(단일 리더와 다중 리더 복제)은 클라이언트가 쓰기 요청을 한 노드(리더)에 전송한 뒤 데이터베이스 시스템이 쓰기를 다른 복제 서버에 복사를 처리하는 아이디어를 기반으로 한다. 리더는 쓰기를 처리하는 순서를 정하고 팔로워는 순서에 따라 리더의 쓰기를 적용한다.
- 리더의 개념이 없는 복제는 과거에 있었지만 RDB 우세로 인해 잊혀졌다. 리더 없는 복제는 아마존이 내부 다이나모(Dynamo) 시스템에서 사용한 후 다시 유명해졌다. 리악, 카산드라, 볼드모트는 다이나모에 영감을 얻은 리더 없는 복제 모델의 오픈소스 데이터스토어다. 이런 종류의 데이터베이스를 다이나모 스타일이라 한다.
- 코디네이터 노드(coordinator node)가 클라이언트를 대신해 이를 수행하기도 한다. 리더 데이터 베이스와 달리 코디네이터 노드는 특정 순서로 쓰기를 수행하지 않는다.

## 노드가 다운됐을 때 데이터베이스에 쓰기

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/465133d4-e4b6-4ae0-a37a-22dc6fcaa324)

- 노드가 다운된 동안 모든 쓰기 연산은 누락됐다. 리더없는 복제에서는 이를 무시한다.
- 클라이언트는 값을 읽을 대 읽기 요청을 병렬로 여러 노드에 전송한다. 이후 버전을 통해 최신 값을 받고 다른 노드의 오래된 값은 최신값으로 변경한다.

### 읽기 복구와 안티 엔트로피

**읽기복구**

- 클라이언트가 여러 노드에서 병렬로 읽기를 수행하면 오래된 응답을 감지할 수 있다.
- 클라이언트는 여러 노드의 응답을 통해 해당 값이 오래되었음을 알고 해당 노드에 새로운 값을 다시 기록한다.
- 값을 자주 읽는 상황에 적합하다.

**안티 엔트로피 처리**

- 일부 데이터 스토어는 백그라운 프로세스를 두고 복제 서버 간 데이터 차이를 지속적으로 찾아 누락된 데이터를 하나의 복제서버에서 다른 서버로 복사한다.
- 안티 엔트로피 처리는 특정 순서로 쓰기를 복사하기 때문에 데이터가 복사되기까지 상당한 지연이 있을 수 있다.

모든 시스템이 이 두가지 메커니즘을 구현하는 것은 아니다. 하지만 안티 엔트로피 처리가 없으면 읽기 복구는 애플리케이션이 값을 읽는 경우에만 수행되기 때문에 거의 읽지 않는 값은 일부 복제본에서 누락되게 된다.

### 읽기와 쓰기를 위한 정족수

- 모든 성공한 쓰기가 세 개의 복제 서버 중 적어도 두 개의 복제 서버에 존재하는 것을 보장하면 하나의 복제 서버가 오래된 데이터임을 의미한다. 적어도 두 개의 복제 서버에서 읽으면 두 개중 적어도 하나의 최신 값인지 확인할 수 있다.

> n개의 복제 서버가 있을 때 모든 쓰기는 w개의 노드에서 성공해야 쓰기가 확정되고 모든 읽기는 최소한 r개의 노드에 질의해야 한다.
> 
> `w + r > n`이면 읽을 때 최신 값을 얻는 것으로 기대한다.
> 
> 최소한 r개의 노드 중 하나에서 최신 값을 읽을 수 있기 때문이다. 이런 r과 w를 따르는 읽기와 쓰기를 정족수 읽기와 쓰기라고 부른다. 유효한 읽기와 쓰기를 위해 필요한 최소 투표수를 r과 w로 생각할 수 있다.

파라미터 설정은 일반적으로 다음과 같다.

- n은 홀수(보통 3 or 5)
- `w = r = (n + 1) / 2` (반올림)

정족수 조건이 w + r > n 이면 다음과 같이 사용 불가능한 노드를 용인한다.

- w < n이면 노드 하나를 사용할 수 없어도 여전히 쓰기를 처리할 수 있다.
- r < n이면 노드 하나를 사용할 수 없어도 여전히 읽기를 처리할 수 있다.
- n = 3, w = 2, r = 3이면 사용 불가능한 노드 하나를 용인한다.
- n = 5, w = 3, r = 3이면 사용 불가능한 노드 둘을 용인한다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/03efcef7-ec08-4b3c-96e6-c9ff018e5035)
w + r > n이면 읽은 r개의 복제 서버 중 최소한 하나는 가장 최근 성공한 쓰기를 알아야한다.

## 정족수 일관성의 한계

- w + r > n의 경우 모든 읽기가 최신 값을 반환하는 것을 기대하는 이유는 쓰기 노드 셋과 읽기 노드 셋이 겹치기 때문이다. 즉 읽기 노드 중에는 최신 값을 가진 노드가 하나 이상 있어야 한다.
- 보통 r과 w의 값으로 노드의 과반수(n/2 초과) 선택한다. n/2 노드 장애까지 허용해도 w + r > n이 보장되기 때문이다.
- w 와 r이 작을수록 오래된 값을 읽을 확률 이 높다.

❗w + r > n 에지 케이스

- 느슨한 정족수를 사용하면 w개의 쓰기는 r개의 읽기와 다른 노드에서 수행될 수 있으므로 r개의 노드와 w개의 노드가 겹치는 것을 보장하지 않는다.
- 두 개의 쓰기가 동시에 발생하면 어떤 쓰기가 먼저 일어났는지 분명하지 않다. 이 경우 안전한 해결책은 동시 쓰기를 합치는 방법밖에 없다. 승자가 타임 스탬프를 기반으로 결정되면 시계 스큐(clock skew)로 인해 쓰기가 유실될 수 있다.
    - 173p, 186p
- 쓰기가 읽기와 동시에 발생하면 쓰기는 일부 복제 서버에만 반영될 수 있다. 이 경우 읽기가 예전 값 또는 최신 값을 반환하는지 여부가 분명하지 않다.
- 쓰기가 일부 복제 서버에서는 성공했지만 다른 복제 서버에서 실패해 전체에서 성공한 서버가 w 복제 서버보다 적다면 성공한 복제 서버에서는 롤백하지 않는다. 이는 쓰기가 실패한 것으로 보고되면 이어지는 읽기에 해당 쓰기 값이 반환될 수 있고 아닐 수도 있다는 의미다.
- 새 값을 전달하는 노드가 고장나면 예전 값을 가진 다른 복제 서버에서 해당 데이터가 복원되고 새로운 값을 저장한 복제 서버 수가 w보다 낮아져 정족수 조건이 깨진다.
- 모든 과정이 올바르게 동작해도 시점 문제로 에지 케이스가 있을 수 있다.
    - 331p

정족수가 읽기 시 최근에 쓴 값을 반환하게끔 보장하지만 실제로 간단하지 않다. 다이나모 스타일 데이터베이스는 최종적 일관성을 허용하는 사용 사례에 맞게 최적화되었다. 매개변수 w와 r로 오래된 값을 읽는 확률을 줄일 수 있지만 절대적으로 보장할 수는 없다.

### 최신성 모니터링

- 운영관점에서 데이터베이스가 최신 결과를 반환하는지 여부를 모니터링 해야한다.
- 리더 기반 복제에는 일반적으로 복제 지연에 대한 지표를 노출한다. 이 지표는 모니터링 시스템에 제공된다.
- 리더 없는 복제 시스템에서는 쓰기가 적용된 순서를 고정할 수 없어 모니터링이 조금 더 어렵다. 더욱이 데이터베이스가 읽기 복구만 사용(안티 엔트로피 사용x)하면 오래된 복제 서버의 반환된 값은 오래된 값일수도 있다.
- 리더 없는 복제 데이터베이스에서 복제 서버의 오래됨(staleness)을 측정하고 매개변수 n, w, r에 따라 오래된 값을 읽는 비율을 예측하는 연구가 있다. 하지만 일반적인 사례는 아니다.
- 최종적 일관성은 의도적으로 모호한 보장이지만 운용성을 위해서는 ‘최종적’을 정량화할 수 있어야 한다.

## 느슨한 정족수와 암시된 핸드오프
- 적절히 설정된 정족수가 있는 데이터베이스는 장애 복구 없이 개별 노드 장애를 용인한다.
- 요청은 w나 r개 노드가 응답할 때 반환할 수 있어 모든 n개 노드가 응답할 때까지 기다릴 필요가 없기 때문에 개별 노드의 응답이 느려지는 것도 허용 가능하다.
- 높은 가용성과 낮은 지연 시간이 필요하다.
- 오래된값 읽기를 허용하는 사용 사례에는 리더 없는 복제 기능을 가진 데이터베이스가 매력적이다.

노드가 n개 이상인 대규모 클러스터에서 클라이언트는 네트워크 장애 상황에서 일부 데이터베이스 노드(특정 값을 위한 정족수 구성에 들어가지 않는 노드)에 연결될 가능성이 있다. 이 경우 트레이드 오프 상황에 직면한다.

- w나 r 노드 정족수를 만족하지 않는 모든 요청에 오류를 반환하는 편이 더 좋을까?
- 아니면 일단 쓰기를 받아들이고 값이 보통 저장되는 n개 노드에 속하지는 않지만 연결할 수 있는 노드에 기록할까? → **느슨한 정족수**
    - 쓰기와 읽기는 여전히 w와 r의 성공 응답이 필요하지만 값을 위해 지정된 N개의 ‘홈’ 노드에 없는 노드가 포함될 수 있다.
- 네트워크 장애 상황이 해제되면 한 노드가 다른 노드를 위해 일시적으로 수용한 모든 쓰기를 해당 ‘홈’노드로 전송한다. 이 방식을 **암시된 핸드오프**라 부른다.


### 다중 데이터센터 운영
- 다이나모 스타일 데이터베이스는 여러 클라이언트가 동시에 같은 키에 쓰는 것을 허용하기 때문에 엄격한 정족수를 사용하더라도 충돌이 발생한다. 다중 리더 복제와 유사하다.
    - 173p
- 다이나모 스타일 데이터베이스에서 충돌은 읽기 복구나 암시된 핸드 오프중에서도 발생할 수 있기는 하다.
- 다양한 네트워크 지연과 부분적인 장애 때문에 이벤트가 다른 노드에 다른 순서로 도착할 수 있다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/2185e965-db5f-4ad0-8558-147138929f9e)

- 노드 1은 A로부터의 쓰기를 받지만 순간적인 장애로 B로부터의 쓰기를 받지 못한다.
- 노드 2는 A로부터의 쓰기를 먼저 받고 그다음 B로부터의 쓰기를 받는다.
- 노드3은 B로부터의 쓰기를 먼저 받고 그다음 A로부터 쓰기를 받는다.

마지막 얻기 요청에서 볼 수 있듯이 노드들은 영구적으로 일관성이 깨진다. 얻기 요청에서 노드 2는 x의 최종값을 B라고 생각하는 반면 다른 노드들은 A라고 생각한다.

최종적 일관성을 달성하기 위해 복제본들은 동일한 값이 되어야 한다. 데이터 손실을 피하려면 데이터베이스 내부에서 충돌을 어떻게 다루는지 알아야 한다.

### 최종 쓰기 승리(동시 쓰기 버리기)
- 최종적으로 값을 수렴하기 위한 접근 방식 하나는 각 복제본이 가진 ‘예전’ 값을 버리고 가장 ‘최신’ 값으로 덮어쓰는 방법이다.
- 어떤 쓰기가 ‘최신’인지 명확하게 결정할 수 있는 한 모든 쓰기는 최종적으로 모든 복제 서버에 복사되므로 복사본은 최종적으로 동일한 값으로 수렴한다.
- 이벤트 순서가 정해지지 않기 때문에 동시 쓰기라고 해야한다.
- 쓰기는 자연적인 순서가 없지만 타임스탬프 등을 통해 순서를 정할 수 있다. 가장 최신의 쓰기 연산을 ‘최신’이라는 의미로 정의하면 최종쓰기승리(LWW)라 부르는 충돌 해소 알고리즘이 있다.
    - 이는 다만 지속성을 희생한다.
    - 손실된 쓰기를 허용하는 상황이 있다.

### ‘이전 발생’ 관계와 동시성
![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/0b0e1292-29e0-481c-aa99-1e9a636c4146)
- 두개의 쓰기는 동시에 수행되지 않는다. A의 삽입이 B의 증가 이전에 발생했다. B가 증가시킨 값은 A가 삽입한 값이기 때문이다. 즉, B 작업은 A 작업 기반이기 때문에 B 작업은 나중에 발생해야한다. 이를 B는 A에 인과성이 있다(causally dependent)라고 한다.
![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/a8b233c9-8a46-4d74-ba83-062c3f303f15)

- 두 개의 쓰기는 동시에 수행됐다. 각 클라이언트는 작업을 시작할 때 다른 클라이언트가 동일한 키에 대한 작업을 수행했는지 알 수 없다.

작업 B가 작업 A에 대해 알거나 의존적이거나 기반으로 한다면 작업 A는 작업 B의 **이전 발생(happends-before)**이다. 작업이 다른 작업보다 먼저 발생하지 않으면 단순히 **동시 작업**이라 말한다. 따라서 작업 A와 작업 B가 있다면 3가지 가능성이 있다. B 이전에 A가 발생하거나 B가 A 이전에 발생하거나 A와 B가 동시에 발생하는 것이다.

### 이전 발생 관계 파악하기
![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/fb0a6a7e-dc0d-4f25-af98-691c15f77e98)
- 화살표는 어떤 작업이 다른 작업 이전에 발생했는지와 나중 작업이 이전에 수행된 작업을 알거나 의존했다는 사실을 나타낸다.
![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/c157dc66-33a2-459b-ada0-c51b80268eae)
- 서버는 버전 번호를 보고 두 작업이 동시에 수행됐는지 여부를 결정할 수 있으므로 값 자체를 해석할 필요는 없다. 따라서 값을 데이터 구조로 사용할 수 있다.
    - 서버가 모든 키에 대한 버전 번호를 유지하고 키를 기록할 때마다 버전 번호를 증가시킨다. 기록한 값은 새로운 비전 번호를 가지고 저장된다.
    - 클라이언트가 키를 읽을 때는 서버는 최신 버전뿐만 아니라 덮어쓰지 않은 모든 값을 반환한다. 클라이언트는 쓰기 전에 키를 읽어야 한다.
    - 클라이언트가 키를 기록할 때는 이전 읽기의 버전 번호를 포함해야 하고 이전 읽기에서 받은 모든 값을 함께 합쳐야 한다.
    - 서버가 특정 버전 번호를 가진 쓰기를 받을 때 해당 버전 이하 모든 값을 덮어쓸 수 있다. 하지만 이보다 높은 버전 번호의 모든 값은 유지해야 한다. 이 값들은 유입 쓰기와 동시에 발생했기 때문이다.

쓰기가 이전 읽기의 버전 번호를 포함하면 쓰기가 수행되기 이전 상태를 알 수 있다. 버전 번호를 포함하지 않은 쓰기는 다른쓰기와 동시에 수행된 것이므로 아무것도 덮어쓰지 않는다.

### 동시에 쓴 값 병합

### 버전 백터
