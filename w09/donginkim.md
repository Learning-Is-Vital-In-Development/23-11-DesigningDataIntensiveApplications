# 리더 없는 복제

- 복제 접근 방식(단일 리더와 다중 리더 복제)은 클라이언트가 쓰기 요청을 한 노드(리더)에 전송한 뒤 데이터베이스 시스템이 쓰기를 다른 복제 서버에 복사를 처리하는 아이디어를 기반으로 한다. 리더는 쓰기를 처리하는 순서를 정하고 팔로워는 순서에 따라 리더의 쓰기를 적용한다.
- 리더의 개념이 없는 복제는 과거에 있었지만 RDB 우세로 인해 잊혀졌다. 리더 없는 복제는 아마존이 내부 다이나모(Dynamo) 시스템에서 사용한 후 다시 유명해졌다. 리악, 카산드라, 볼드모트는 다이나모에 영감을 얻은 리더 없는 복제 모델의 오픈소스 데이터스토어다. 이런 종류의 데이터베이스를 다이나모 스타일이라 한다.
- 코디네이터 노드(coordinator node)가 클라이언트를 대신해 이를 수행하기도 한다. 리더 데이터 베이스와 달리 코디네이터 노드는 특정 순서로 쓰기를 수행하지 않는다.

## 노드가 다운됐을 때 데이터베이스에 쓰기

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/465133d4-e4b6-4ae0-a37a-22dc6fcaa324)

- 노드가 다운된 동안 모든 쓰기 연산은 누락됐다. 리더없는 복제에서는 이를 무시한다.
- 클라이언트는 값을 읽을 대 읽기 요청을 병렬로 여러 노드에 전송한다. 이후 버전을 통해 최신 값을 받고 다른 노드의 오래된 값은 최신값으로 변경한다.

### 읽기 복구와 안티 엔트로피

**읽기복구**

- 클라이언트가 여러 노드에서 병렬로 읽기를 수행하면 오래된 응답을 감지할 수 있다.
- 클라이언트는 여러 노드의 응답을 통해 해당 값이 오래되었음을 알고 해당 노드에 새로운 값을 다시 기록한다.
- 값을 자주 읽는 상황에 적합하다.

**안티 엔트로피 처리**

- 일부 데이터 스토어는 백그라운 프로세스를 두고 복제 서버 간 데이터 차이를 지속적으로 찾아 누락된 데이터를 하나의 복제서버에서 다른 서버로 복사한다.
- 안티 엔트로피 처리는 특정 순서로 쓰기를 복사하기 때문에 데이터가 복사되기까지 상당한 지연이 있을 수 있다.

모든 시스템이 이 두가지 메커니즘을 구현하는 것은 아니다. 하지만 안티 엔트로피 처리가 없으면 읽기 복구는 애플리케이션이 값을 읽는 경우에만 수행되기 때문에 거의 읽지 않는 값은 일부 복제본에서 누락되게 된다.

### 읽기와 쓰기를 위한 정족수

- 모든 성공한 쓰기가 세 개의 복제 서버 중 적어도 두 개의 복제 서버에 존재하는 것을 보장하면 하나의 복제 서버가 오래된 데이터임을 의미한다. 적어도 두 개의 복제 서버에서 읽으면 두 개중 적어도 하나의 최신 값인지 확인할 수 있다.

> n개의 복제 서버가 있을 때 모든 쓰기는 w개의 노드에서 성공해야 쓰기가 확정되고 모든 읽기는 최소한 r개의 노드에 질의해야 한다.
> 
> `w + r > n`이면 읽을 때 최신 값을 얻는 것으로 기대한다.
> 
> 최소한 r개의 노드 중 하나에서 최신 값을 읽을 수 있기 때문이다. 이런 r과 w를 따르는 읽기와 쓰기를 정족수 읽기와 쓰기라고 부른다. 유효한 읽기와 쓰기를 위해 필요한 최소 투표수를 r과 w로 생각할 수 있다.

파라미터 설정은 일반적으로 다음과 같다.

- n은 홀수(보통 3 or 5)
- `w = r = (n + 1) / 2` (반올림)

정족수 조건이 w + r > n 이면 다음과 같이 사용 불가능한 노드를 용인한다.

- w < n이면 노드 하나를 사용할 수 없어도 여전히 쓰기를 처리할 수 있다.
- r < n이면 노드 하나를 사용할 수 없어도 여전히 읽기를 처리할 수 있다.
- n = 3, w = 2, r = 3이면 사용 불가능한 노드 하나를 용인한다.
- n = 5, w = 3, r = 3이면 사용 불가능한 노드 둘을 용인한다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/03efcef7-ec08-4b3c-96e6-c9ff018e5035)
w + r > n이면 읽은 r개의 복제 서버 중 최소한 하나는 가장 최근 성공한 쓰기를 알아야한다.

## 정족수 일관성의 한계

- w + r > n의 경우 모든 읽기가 최신 값을 반환하는 것을 기대하는 이유는 쓰기 노드 셋과 읽기 노드 셋이 겹치기 때문이다. 즉 읽기 노드 중에는 최신 값을 가진 노드가 하나 이상 있어야 한다.
- 보통 r과 w의 값으로 노드의 과반수(n/2 초과) 선택한다. n/2 노드 장애까지 허용해도 w + r > n이 보장되기 때문이다.
- w 와 r이 작을수록 오래된 값을 읽을 확률 이 높다.

❗w + r > n 에지 케이스

- 느슨한 정족수를 사용하면 w개의 쓰기는 r개의 읽기와 다른 노드에서 수행될 수 있으므로 r개의 노드와 w개의 노드가 겹치는 것을 보장하지 않는다.
- 두 개의 쓰기가 동시에 발생하면 어떤 쓰기가 먼저 일어났는지 분명하지 않다. 이 경우 안전한 해결책은 동시 쓰기를 합치는 방법밖에 없다. 승자가 타임 스탬프를 기반으로 결정되면 시계 스큐(clock skew)로 인해 쓰기가 유실될 수 있다.
    - 173p, 186p
- 쓰기가 읽기와 동시에 발생하면 쓰기는 일부 복제 서버에만 반영될 수 있다. 이 경우 읽기가 예전 값 또는 최신 값을 반환하는지 여부가 분명하지 않다.
- 쓰기가 일부 복제 서버에서는 성공했지만 다른 복제 서버에서 실패해 전체에서 성공한 서버가 w 복제 서버보다 적다면 성공한 복제 서버에서는 롤백하지 않는다. 이는 쓰기가 실패한 것으로 보고되면 이어지는 읽기에 해당 쓰기 값이 반환될 수 있고 아닐 수도 있다는 의미다.
- 새 값을 전달하는 노드가 고장나면 예전 값을 가진 다른 복제 서버에서 해당 데이터가 복원되고 새로운 값을 저장한 복제 서버 수가 w보다 낮아져 정족수 조건이 깨진다.
- 모든 과정이 올바르게 동작해도 시점 문제로 에지 케이스가 있을 수 있다.
    - 331p

정족수가 읽기 시 최근에 쓴 값을 반환하게끔 보장하지만 실제로 간단하지 않다. 다이나모 스타일 데이터베이스는 최종적 일관성을 허용하는 사용 사례에 맞게 최적화되었다. 매개변수 w와 r로 오래된 값을 읽는 확률을 줄일 수 있지만 절대적으로 보장할 수는 없다.

### 최신성 모니터링

- 운영관점에서 데이터베이스가 최신 결과를 반환하는지 여부를 모니터링 해야한다.
- 리더 기반 복제에는 일반적으로 복제 지연에 대한 지표를 노출한다. 이 지표는 모니터링 시스템에 제공된다.
- 리더 없는 복제 시스템에서는 쓰기가 적용된 순서를 고정할 수 없어 모니터링이 조금 더 어렵다. 더욱이 데이터베이스가 읽기 복구만 사용(안티 엔트로피 사용x)하면 오래된 복제 서버의 반환된 값은 오래된 값일수도 있다.
- 리더 없는 복제 데이터베이스에서 복제 서버의 오래됨(staleness)을 측정하고 매개변수 n, w, r에 따라 오래된 값을 읽는 비율을 예측하는 연구가 있다. 하지만 일반적인 사례는 아니다.
- 최종적 일관성은 의도적으로 모호한 보장이지만 운용성을 위해서는 ‘최종적’을 정량화할 수 있어야 한다.

## 느슨한 정족수와 암시된 핸드오프

### 다중 데이터센터 운영

## 동시 쓰기 감지

### 최종 쓰기 승리(동시 쓰기 버리기)

### 이전 발” 관계와 동시성

### 이전 발생 관계 파악하기

### 동시에 쓴 값 병합

### 버전 백터
