# 복제

> **복제란 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미**

복제가 필요한 이유

1. 지리적으로 사용자가 가깝게 데이터를 유지해 지연 시간을 줄인다.
2. 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성을 높인다.
3. 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다.

복제의 모든 어려움은 복제된 데이터의 변경에 있다.

노드간 복제를 위한 알고리즘

1. 단일 리더(Single-leader)
2. 다중 리더(Multi-leader)
3. 리더 없는(leaderless)

# 리더와 팔로워

**복제 서버(replica) = 데이터베이스의 복사본을 저장하는 각 노드**

리더 기반 복제를 통해 모든 복제 서버의 쓰기 처리.

1. 복제 서버 중 하나를 리더(혹은 마스터나 프라이머리)로 선정하고 클아이언트의 쓰기 요청은 항상 리더로 보낸다.
2. 리더는 로컬 저장소에 새로운 데이터를 기록한다.
3. 데이터 변경을 **복제 로그(replication log)** 또는 **변경 스트림(change stream)**의 일부로 팔로워에게 전송한다.
4. 각 팔로워가 리더로부터 로그를 받으면 리더가 처리한 것과 동일한 순서로 모든 쓰기를 적용하여 로컬 저장소를 갱신한다.

## 동기식 대 비동기식 복제

복제 시스템의 중요한 세부사항은 복제가 **동기식**으로 발생하는 지 **비동기식**으로 발생하는 지 여부다.

동기식 복제

- 장점: 일관성 있는 복사본 보장, 리더가 동작하지 않을 바로 팔로워에서 사용 가능
- 단점: 팔로워에 의해서 쓰기가 안될 수 있음

반동기식 복제

일부 동기식 노드와 일부 비동기식 노드를 혼합.

## 새로운 팔로워 설정

새로운 팔로워 추가 과정

1. 데이터 베이스의 일정 시점 스냅샷을 가져온다.
2. 새 노드에 스냅샷을 복사한다.
3. 스냅샷 이후 복제 로그를 요청한다. (이때 스냅샷과 리더의 복제 로그의 정확한 위치와 연관되어야 한다.)
4. 복제 로그를 모두 반영한다.

## 노드 중단 처리

시스템의 모든 노드는 장애로 인해 예기치 않게 중단될 수 있지만 계획된 유지보수로 인해 중단될 수도 있다. 중단 시간 없이 개별 노드를 재부팅할 수 있다는 점은 운영과 유지 보수의 큰 장점이다.

### 팔로워 장애: 따라잡기 복구

1. 보관된 로그에서 결함이 발생하기 전에 처리한 마지막 트랜잭션을 알아낸다.
2. 이후 변경에 대해서 다시 리더에게 요청한다.
3. 변경 사항을 반영한다.

### 리더 장애: 장애 복구

리더 장애 복구는 까다롭고 이 전체 과정을 장애 복구(failover)라고 한다.

리더 장애복구 과정

1. 리더 장애인지 판단한다.
    - 주로 타임아웃을 통해 판단하며 일정 시간 응답이 없다면 죽은 것으로 간주한다.
2. 새로운 리더를 선택한다.
    - 새로운 리더로 가장 적합한 후보는 보통 이전 리더의 최신 데이터 변경 사항을 가진 복제 서버이다. 합의 과정을 통해 선출될 수 있다.
3. 새로운 리더 사용을 위해 시스템을 재설정한다.
    - 클라이언트는 이제 새로운 쓰기 요청을 새로운 리더에게 보내야 한다. 이전 리더가 복구 되어 리더라고 판단할 수 있으며 시스템이 새로운 리더를 인식할 수 있도록 해야 한다.

리더 장애 복구의 어려움

- 비동기 복제 시에 새로운 리더는 이전 리더의 쓰기를 일부 수신하지 못할 수 있다. 가장 일반적인 해결책은 수신하지 못한 쓰기 작업을 폐기하는 것으로 클라이언트의 내구성에 대한 기대를 저버린다.
- 두 노드가 모두 자신이 리더라고 믿을 수 있는 **스플릿 브레인(split brain)**이 발생할 수 있다. 두 리더가 쓰기를 받으면 충돌을 해소하는 과정을 거치지 않는 다면 데이터가 유실되거나 오염될 수 있다. 두 리더가 감지되면 하나의 리더를 종료 시키는 로직 역시 주의 깊게 설계하지 않으면 두 노드가 모두 종료될 수 있다.

이러한 문제의 쉬운 해결책은 없다. 경우에 따라서 수동 복구를 선호할 수 있다.

## 복제 로그 구현

### 구문 기반 복제

리더는 모든 쓰기 요청(구문, statement)을 기록하고 쓰기를 실행한 다음에 구문 로그를 팔로워에게 전송한다.

복제가 깨질 수 있는 다양한 사례

- 비결정적 함수를 호출하는 모든 구분은 실행 시점에 따라 결과가 달라진다.
- 자동증가 컬럼을 사용하는 구문이나 데이터 베이스에 의존하는 구문은 정확히 같은 순서로 실행되어야 한다. 이것은 여러 트랜잭션을 동시에 수행하는 것을 어렵게 한다.
- 부수 효과까지 완벽하게 결정적이지 않으면 각 복제 서버에서 다른 부수 효과가 발생할 수 있다.

이러한 문제를 해결하기 위해 결정적인 값을 넣어 구문을 반환할 수 있다.

### 쓰기 전 로그 배송

일반적으로 모든 쓰기는 로그에 기록한다. 팔로워가 이 로그를 처리하면 리더에서 있는 것과 정확히 동일한 데이터 구조의 복제를 할 수 있다.

가장 큰 단점은 제일 저수준의 데이터를 기술한다는 점이다. 대게 리더와 팔로워의 소포트웨어 버전을 다르게 할 수 없다. 따라서 DB를 업데이틑 하기 위해서는 중단시간이 필요하다.

### 논리적(로우 기반) 로그 복제

복제 로그를 저장소 엔진 내부와 분리하기 위한 대안으로는 저장소 엔진과는 다른 형식의 로그 형식을 사용하는 것으로 **논리적 로그(logical log)**라고 부른다.

관계형 데이터베이스용 논리적 로그는 대게 로구 단위로 데이터베이스 테이블에 쓰기를 기술한 레코드 열이다. 여러 로우를 수정하는 트랜잭션은 여러 로그 레코드와 트랜잭션이 커밋되었음을 표시한다.

### 트리거 기반 복제

조금 더 유연성이 필요한 몇 가지 상황에서 사용된다. 트리거는 사용자 정의 애플리케이션 코드를 등록할 수 있게 한다. 데이터 베이스의 데이터 변경(쓰기)되면 자동으로 실행된다. 트리거는 데이터의 변경을 분리된 테이블에 로깅할 수 있는 기회를 가진다. 일반적으로 트리거 복제는 다른 복제 방식보다 오버헤드가 많이 있다.

# 복제 지연 문제

복제는 단순히 노드의 분산 뿐만 아니라 가용성 측면에서도 도움이 된다. 하지만 실제로 이렇게 복제 노드를 증가 시키기 위해서는 비동기적 복제를 해야 한다. 동기적 복제를 할 경우 장애에 취약하며 성능적으로 불안정 하다.

하지만 비동기적 복제 특성 상 데이터를 동기화 하는데 시간이 걸려 동기화가 되고 이것을 최종적 일관성이라고 한다. 따라서 이 딜레이 때문에 과거 데이터를 읽을 수 있는 문제가 있다.

### 자신이 쓴 내용 읽기

본인이 쓴 내용을 읽었을 때 일반적인 데이터 접근처럼 접근할 경우 복제 지연으로 자신이 작성한 글이 조회 되지 않을 수 있다. 이 경우 사용자는 자신의 데이터가 유실 되었다고 생각할 수 있다.

따라서 자신이 수정한 데이터에 대해서는 일관된 읽기를 제공하는 **쓰기 후 읽기 일관성**을 제공해야 한다. 이를 위해 다음과 같은 방법을 사용할 수 있다.

1. 자신에 대한 데이터 조회는 리더에서 읽는다.
2. 마지막 업데이트 이후 일정 시간동안 리더에서 읽도록 한다. 이 경우 서버 간 시계를 일치 시켜야 한다.
3. 마지막 수정의 타임 테임프를 이용해서 복제 서버의 동기화를 체크하고 동기화 되지 않았다면 질의를 대기 시킨다.

뿐만 아니라 사용자가 여러 디바이스로 접근할 수 있다. 이럴 경우 디바이스 간 쓰기 읽관성을 제공해야 한다.

### 단조 읽기

사용자가 여러 복제 서버에 읽기 요청을 할 경우 복제 지연에 따른 시간 역행 현상을 경험할 수 있다. 예를 들어 사용자가 데이터를 읽었지만 다음 조회 시에 다른 서버에서는 아직 복제 지연으로 데이터가 없어 조회 되지 않는 현상이다.

이러한 현상을 막기 위해서는 **단조 읽기(monotonic read)**를 지원해야 한다. 간단히 같은 유저에 대해서는 같은 replication server가 응답하도록 하는 것이다. 이를 위해서는 식별자를 활용하여 특정 서버에 요청이 되도록 해야 한다.

### 일관된 순서로 읽기

단조 읽기와 유사하게 논리적인 순서와 다르게 읽기가 발생할 수 있다. 파티셔닝된 저장소에 복제 지연의 차이로 인해서 질문보다 답이 먼저 조회되고 질문은 추후에 복제되어 늦게 읽히듯 말이다.

이러한 현상을 방지하기 위해서는 논리적인 읽기에 대해서는 같은 파티셔닝된 데이터베이스를 읽어야 한다. 하지만 논리적으로 같은 지를 알기가 어렵다.

### 복제 지연을 위한 해결책

최종적 일관성 시스템의 작업에서 복제 지연이 몇 분 혹은 몇 시간으로 길어질 때 서비스에 대해서 고려해야 한다. 문제가 없다면 다행이겠지만 대부분은 수많은 문제를 마주하게 될 것이다.

이를 해결하기 위한 방법은 **트랜잭션**이다. 단일 노드에 대해서는 오랜 전부터 트랜잭션이 지원해왔지만 분산, 파티셔닝 된 시스템에서는 성능과 가용성 측면에서 너무 비싸고 확장 가능 시스템에서는 결국 최종적 일관성을 써야 하는 주장을 한다. 이 주장의 일부는 사실이고 일부는 거짓이다.

# 다중 리더 복제

단일 리더 아키텍처만 고려해왔다. 단일 리더의 경우 리더의 장애가 생길 경우 쓰기를 할 수 없는 치명적인 문제점을 앉고 있다. 이를 해결하기 위해서는 리더를 하나 이상 두는 것으로 확장된다. 이를 엑티브/엑티브 복제라고 한다. 각 리더는 리더이면서 동시에 다른 리더의 팔로워 역할을 수행한다.

## 다중 리더 복제의 사용 사례

### 다중 데이터 센터 운영

여러 데이터 센터를 운영할 경우 단일 리더는 여러 가지 문제점을 발생 시킬 수 있다.

성능적으로도 쓰기 요청과 멀리 떨어져 있더라도 리더가 속한 데이터 센터까지 통신을 하기 때문에 통신 비용이 사용된다. 또한 리더가 포함된 데이터 센터가 속한 지역의 문제가 있거나 고장이 나게 되면 다른 지역에도 문제가 생긴다. 마지막으로 네트워크 문제에 따른 일시적인 쓰기 불가이다.

하지만 이런 다중 리더 복제의 경우 **쓰기 충돌**이라는 필연적인 문제를 해결 해야 한다.

### 오프라인 작업하는 클라이언트

다양한 디바이스를 이용할 경우 사용자가 오프라인에 있더라도 다른 디바이스에 의해 발생한 변경이 반영되어야 한다. 이를 해결하기 위해서 개별 클라이언트에 개별 리더 노드를 추가하여 쓰기 작업을 받아서 쓰기 처리를 한다. 카우치 DB가 이런 종류의 리더 설정을 손쉽게 할 수 있도록 도와준다.

### 협업 편집

현업 편집은 데이터 베이스의 복제 문제라고 생각하지 않지만 오프라인 작업과 유사한 성격을 가지고 있다. 쓰기 작업을 위한 권한을 얻어서 쓰는 식으로 트랜잭션을 제어할 수도 있지만 아주 작은 단위의 작업을 분할하고 가용성을 올리고 작은 작업을 효율적으로 처리할 수 있을 것이다.

## 쓰기 충돌 다루기

다중 리더 복제는 필연적으로 쓰기 충돌이 발생하고 복제 지연으로 인해 복제 시점에 충돌 여부를 알게 된다.

### 동기 대 비동기 충돌 감지

단일 리더 데이터베이스의 경우 트랜잭션을 통해 쓰기 순서를 제어하지만 다중 리더의 경우 두 쓰기를 모두 성공하고 이후에 비동기적으로 충돌을 처리한다. 동기적으로 처리할 수 있지만 이럴 경우 단일 리더 데이터베이스와 다를 바가 없어질 것이다.

### 충돌 회피

충돌 처리의 가장 간단한 전략을 충돌 자체를 회피하는 것이다. 이를 위해서 각 지역 별로 리더들은 특정 레코드에 대해서 담당할 수 있다. 이 경우 특정 레코드에 대해서는 단일 리더 형태로 구성되어 충돌을 회피할 수 있다. 하지만 리더가 장애가 발생해서 다른 리더로 이동 해야 했을 때 문제가 생길 수 있다.

### 일관된 상태 수렴

단일 리더 데이터베이스의 쓰기는 순차적으로 진행된다. 하지만 다중 리더 쓰기는 순서가 없어 일관성이 없는 상태가 될 수 있다. 모든 복제 서버가 복제를 성공했을 때 동일한 상태를 가지고 있는 것이 일관된 상태 수렴이라고 할 수 있다.

- 각 쓰기에 고유ID를 부여하고 가장 높은 ID를 가진 쓰기만 고르고 다른 쓰기를 지운다. 이 경우 데이터가 유실될 수 있다.
- 고유 ID를 부여하고 쓰기가 낮은 숫자의 복제 서버에서 생긴 쓰기보다 항상 우선 적용한다. 이 경우 역시 데이터 유실될 수 있다.
- 어떻게든 값을 병합한다. 사전순으로 정렬하여 붙이는 등
- 명시적 데이터 구조에 충돌 기록을 모두 기록하고 추후에 사용자에게 해결을 요청한다.

### 사용자 정의 충돌 해소 로직

충돌을 해소하는 가장 좋은 방법은 애플리케이션에 따라 다르다. 따라서 애플리케이션 코드를 사용해 충돌 해소 로직을 작성한다.

쓰기 수행 중에는 충돌을 감지하자 마자 충돌 핸들러를 호출한다. 핸들러를 통해 적절하게 충돌을 백그라운드에서 처리하고 사용자에게 알리지 않는다.

읽기 수행 중에 충돌 시에 모든 충돌 쓰기를 저장하고 사용자에게 충돌을 보여주거나 직접 해결할 수 있다.

> 자동 충돌 해소
충돌 해소 규칙은 빠르게 복잡해질 수 있고 맞춤형 코드는 오류가 발생할 수 있다.
> - 충돌 없는 복제 데이터 타입: 데이터 구조를 집합으로 동시에 여러 사용자가 편집해도 합리적으로 충돌해소
> - 병합 가능한 영속 데이터 구조: git과 유사하게 명시적으로 히스토리를 추적하고 삼중 병합
> - 운영 변환: 협업 편집 애플리케이션의 충돌 해소 알고리즘

## 다중 리더 복제 토폴로지

복제 토폴로지는 복제 데이터를 전송하는 통로를 의미한다. 크게 3가지 형태로 구성되는데 원형, 별형, 전체 연결형이 있다.

원형은 단일 토폴로지를 통해 노드가 쓰고 다시 단일 토폴로지를 통해 다른 노드에게 복제 데이터를 전달하는 식으로 구성 되어 있다. 별 형은 트리 형으로 일반화 될 수 있으며 루트 노드가 자식 노드에게 복제 데이터를 전달하는 식으로 구성되어 있다. 이러한 형태의 토폴로지는 특정 노드에 장애 발생 시 전체 노드가 복제 데이터를 전달 받지 못할 수 있다. 또한 순환이 발생할 수 있음으로 이를 방지하기 위해 노드는 식별자가 있고 이를 태그해서 이미 도달한 노드에는 더 이상 전달 되지 않도록 한다.

반면 전체 연결형의 경우 모든 노드가 서로 연결되어 있기 때문에 장애의 전파가 되지 않는 내결함성을 더 좋다. 하지만 이 경우 네트워크 혼잡에 따라 복제 메세지가 추월하는 경우가 발생할 수 있다. 일관된 순서로 읽기 문제에서 본 인과성 문제가 발생한다. 이를 해결하기 위해서 버전 벡터(version vector)를 기법을 사용할 수 있다.
