## 복제

복제중인 데이터가 시간이 지나도 변경되지 않는 데이터(`immutable`) : 그냥 모든 노드에 데이터를 복사하면 끝<br>
데이터가 변경될 수 있는 데이터(`mutable`) : 복제된 데이터의 변경 처리도 책임져야 하는 어려움이 있다

노드 간 변경을 복제하기 위한 알고리즘
- 단일 리더(single-leader) 복제
- 다중 리더(multi-leader) 복제
- 리더 없는(leaderless) 복제


### 리더와 팔로워

#### 복제 서버(replica)
데이터베이스의 복사본을 저장하는 각 노드를 복제 서버(replica)라 부른다. 
어떻게 모든 복제 서버에 동일한 데이터를 유지할 수 있을까? 

#### 리더 기반 복제
![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/87d7aec7-e674-4d48-b37b-71f822d3ac4c)

복제 서버 중 하나를 리더(leader/master/primary)로 지정한다. 
- 클라이언트는 쓰기 질의 요청을 리더에게 보내야 한다. 
- 리더는 먼저 로컬 저장소에 새로운 데이터를 기록한다.

  
다른 복제 서버는 팔로워(follower/읽기 복제 서버(read replica), Slave, secondary, hot standby)라고 한다. 
- 리더가 로컬 저장소에 변경을 기록하면 이를 **복제 로그(replication log**)나 **변경 스트림(change stream)**의 일부로 팔로워에게 전송한다. 
- 팔로워는 전달받은 로그를 기반으로 리더가 처리한 것과 동일한 순서로 모든 쓰기를 적용해 로컬 복사본을 갱신한다.

이러한 복제 모드는 postgreSQL(v9.0~), MySQL, 오라클 데이터 가드, SQL 서버의 상시 가용성 그룹과 같은 여러 관계형 데이터베이스에 내장된 기능이다.
(몽고DB, 리싱크DB, 에스프레소같은 일부 비관계형 데이터베이스에서도 사용)
더하여, 꼭 데이터베이스뿐 아니라 분산 메세지 브로커에서도 사용되며, 일부 네트워크 파일 시스템, 복제 블럭 디바이스에서도 유사하게 사용된다. 


#### sync vs async 복제

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/b7844798-7e2d-45ac-8717-0bffab060a4f)

||동기식 복제|비동기식 복제|
|:--:|:--:|:--:|
|예시|팔로워1|팔로워2|
|복제방식|리더는 팔로워의 응답을 기다린다<br>팔로워가 응답을 하지 않을 경우 리더는 모든 쓰기를 차단(block)하고 기다린다| 리더는 메시지를 전송하지만 응답을 기다리지 않는다<br>팔로워가 변경 내용을 적용하기까지 시간을 보장할 수 없다. (Ex: 팔로워가 장애 복구 중, 네트워크 문제 등)|
|장점| 팔로워와 리더가 일관성있게 최신 데이터 복사본을 가지는 것을 보장|팔로워가 잘못되더라도 리더가 쓰기처리를 계속할 수 있다|
