## 복제

복제중인 데이터가 시간이 지나도 변경되지 않는 데이터(`immutable`) : 그냥 모든 노드에 데이터를 복사하면 끝<br>
데이터가 변경될 수 있는 데이터(`mutable`) : 복제된 데이터의 변경 처리도 책임져야 하는 어려움이 있다

노드 간 변경을 복제하기 위한 알고리즘
- 단일 리더(single-leader) 복제
- 다중 리더(multi-leader) 복제
- 리더 없는(leaderless) 복제


### 리더와 팔로워

#### 복제 서버(replica)
데이터베이스의 복사본을 저장하는 각 노드를 복제 서버(replica)라 부른다. 
어떻게 모든 복제 서버에 동일한 데이터를 유지할 수 있을까? 

#### 리더 기반 복제
![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/87d7aec7-e674-4d48-b37b-71f822d3ac4c)

복제 서버 중 하나를 리더(leader/master/primary)로 지정한다. 
- 클라이언트는 쓰기 질의 요청을 리더에게 보내야 한다. 
- 리더는 먼저 로컬 저장소에 새로운 데이터를 기록한다.

  
다른 복제 서버는 팔로워(follower/읽기 복제 서버(read replica), Slave, secondary, hot standby)라고 한다. 
- 리더가 로컬 저장소에 변경을 기록하면 이를 **복제 로그(replication log**)나 **변경 스트림(change stream)**의 일부로 팔로워에게 전송한다. 
- 팔로워는 전달받은 로그를 기반으로 리더가 처리한 것과 동일한 순서로 모든 쓰기를 적용해 로컬 복사본을 갱신한다.

이러한 복제 모드는 postgreSQL(v9.0~), MySQL, 오라클 데이터 가드, SQL 서버의 상시 가용성 그룹과 같은 여러 관계형 데이터베이스에 내장된 기능이다.
(몽고DB, 리싱크DB, 에스프레소같은 일부 비관계형 데이터베이스에서도 사용)
더하여, 꼭 데이터베이스뿐 아니라 분산 메세지 브로커에서도 사용되며, 일부 네트워크 파일 시스템, 복제 블럭 디바이스에서도 유사하게 사용된다. 


#### sync vs async 복제

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/b7844798-7e2d-45ac-8717-0bffab060a4f)

||동기식 복제|비동기식 복제|반동기식 복제|
|:--:|:--:|:--:|:--:|
|예시|팔로워1|팔로워2|-|
|복제방식|리더는 팔로워의 응답을 기다린다<br>팔로워가 응답을 하지 않을 경우 리더는 모든 쓰기를 차단(block)하고 기다린다| 리더는 메시지를 전송하지만 응답을 기다리지 않는다<br>팔로워가 변경 내용을 적용하기까지 시간을 보장할 수 없다. (Ex: 팔로워가 장애 복구 중, 네트워크 문제 등)|모든 팔로워가 동기식이라면 임의 한노드의 장애는 전체 시스템을 멈출 수 있다.<br> 팔로워 하나는 동기식으로 하고 그 밖에는 비동기식으로 하는 방법|
|장점| 팔로워와 리더가 일관성있게 최신 데이터 복사본을 가지는 것을 보장|팔로워가 잘못되더라도 리더가 쓰기처리를 계속할 수 있다|최소 두 노드(리더 + 팔로우 1개)에 데이터의 최신 복사본이 있는 것을 보장한다.|


#### 새로운 팔로워 설정


데이터베이스를 잠근 후 복제를 할 경우 일관성은 확보할 수 있지만, 가용성 목표를 놓치게 된다. 
그렇기에 중단없이 팔로워 설정을 할 수 있어야 하는데 다음과 같이 할 수 있다. 

- DB를 잠그지 않고 리더의 DB 스냅숏을 가져온다.
- 스냅숏을 새로운 팔로워 노드에 복사한다.
- 팔로워는 리더와 연결해 스냅숏 이후 발생한 데이터 변경을 요청한다.
- 팔로워가 스냅숏 이후의 변경을 모두 처리했을 때 따라잡았다고 말한다.


### 노드 중단 처리

별도의 중단시간 없이 개별 노드를 재부팅할 수 있다면 운영 및 유지보스 측면에서 큰 장점이다. 

개별 노드의 장애에도 전체 시스템을 정상적으로 유지하고 노드 중단의 영향을 최소화해야한다.

#### 팔로워 장애: 따라잡기 복구

팔로워 장애 복구는 매우 쉽게 복구가능하다. 

- 결함 발생 직전 최종 수행 트랜잭션을 알아낸다.
- 리더와 연결한 뒤 연결이 끊어진 동안 발생한 데이터 변경을 모두 요청한다.
- 미처리 변경을 모두 적용하여 리더를 따라잡으면 복구 해결

#### 리더 장애: 장애 복구

리더의 장애를 처리하는건 매우 까다로운 장애 복구(failover) 과정을 거쳐야 한다.

- 리더 장애 판단: : 리더가 일정 시간 동안 응답하지 않을 경우(timeout) 죽은 것으로 간주한다.
- 새로운 리더 선택 : 합의(Ex: 복제 서버 다수결) 혹은 선출된 제어 노드에 의해 새로운 리더가 선정될 수 있다. 
- 시스템 재설정 : 리더가 새로 선정되었으면 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비해야 한다.


> 장애 복구 과정에서 발생할 수 있는 문제점
- 비동기식 복제를 할 경우 이전 리더의 쓰기 데이터 유실 가능성
  - 이전 리더가 처리하지 못한 쓰기를 모두 폐기해 해결할 수 있지만, 내구성이 떨어지게 된다.
- 개인 정보 유출
  - 이전 리더가 데이터베이스의 새로운 로우의 기본키 할당을 위해 자동증가 카운터를 사용했는데, 새로운 리더는 이전 리더의 쓰기가 유실된 경우 이 사실을 알 수 없기에 예전에 할당한 기본키를 재사용하게 되는데, 이 경우 불일치가 발생하여 개인정보가 잘못된 사용자에게 공개될 수 있다. 
- 스플릿 브레인(split brain)
  - 두 노드가 모두 자신이 리더라고 믿는 상황
  - 두 리더가 쓰기를 받으면서 충돌을 해결하는 과정을 거치지 않으면 데이터가 유실 혹은 오염될 수 있다. 
- 불필요한 장애 복구
  - 리더가 죽었다고 판단하는 타입아웃 시간을 너무 길게하면 리더가 작동하지 않은 시간부터 복구까지 시간이 오래걸린다.
  - 그렇다고 너무 짧은 타임아웃 시간은 불필요한 장애 복구가 있을 수 있다. 


### 복제 로그 구현 

#### 구문 기반 복제 과정

리더는 쓰기 요청(statement)을 수행 후 해당 구문 로그를 팔로워에게 전송한다. RDB는 전달받은 SQL문을 파싱하고 실행한다.

**복제가 깨질 수 있는 사례**

- 구문에서 비결정적 함수(`NOW()`, `RAND()`)를 사용하는 경우 복제서버마다 다른 값을 생성할 가능성이 있다.
- AutoIncrement를 사용하는 경우 각각의 복제 서버들은 모두가 동일한 순서로 실행되야 하고 이는 여러 트랜잭션이 동시에 수행되는 것을 제한한다
- 부수효과를 가진 구문( Trigger, Stored Procedure, 사용자 정의 함수)은 부수 효과가 완벽하게 결정적이지 않으면 각 복제서버에서 다른 사이드 이펙트가 발생할 수 있다.

**해결책**

- 구문 기반 복제
    - Leader는 구문을 기록할 때, 모든 비결정적 함수 호출을 고정 값을 반환하게끔 대체한다.
    - VoltDB, MySQL 5.1 미만
- 로우 기반 복제
    - MySQL 5.1 이상 

#### 쓰기 전 로그 배송(Write-ahead log, WAL)

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/c3fb385f-c63d-4196-b7fd-46550c461662)


로그 구조화 저장소 엔진이나 B 트리의 경우 모두 로그는 데이터베이스의 모든 쓰기를 포함하는 추가 전용(append-only) 바이트열이다.<br>
팔로워가 이 로그를 처리하면 리더와 동일한 데이터 구조의 복제본이 만들어 진다.

단점은 로그가 제일 저수준의 데이터를 기술한다는 점이다.

WAL은 어떤 디스크 블록에서 어떤 바이트를 변경했는지와 같은 상세정보도 포함하기 때문에 복제가 저장소 엔진과 의존성이 생기게 된다.<br>
그렇기에 리더와 팔로워의 DB 버전을 다르게 가져갈 수 없는 등의 문제가 생긴다.

> 해결 방법 : 팔로워를 리더보다 먼저 새로운 소프트웨어 버전을 사용하게끔 허용하여 팔로워를 먼저 업그레이드하면 중단없이 업그레이드가 가능하다.

#### 논리적(로우 기반) 로그 복제

복제 로그를 저장소 엔진의 물리적 데이터 표현과 구별하기 위해 논리적 로그라고 부른다.<br>
RDB용 논리적 로그는 보통 로우 단위로 데이터베이스 테이블에 쓰기를 기술한 레코드 열이다. 

- 삽입된 로우의 로그는 모든 칼럼의 새로운 값을 포함한다.
- 삭제된 로우의 로그는 식별 정보를 포함한다. (Ex: Primary Key)
- 갱신된 로우의 로그는 식별 정보와 새로운 값을 포함한다.

> 데이터 캡쳐(change data capture, CDC)
논리적 로그를 저장소 엔진과 분리했기 때문에 리더와 팔로우 사이 하위호환성 유지가 쉽고, 논리적 로그 형식은 외부 애플리케이션이 파싱하기 쉽기 때문에 데이터 웨어하우스 같은 외부 시스템에 데이터베이스의 내용을 전송하고자 할 때 유용하다.


#### 트리거 기반 복제

일반적으로 오버헤드, 버그, 제한사항이 더 많지만 데이터베이스 서브셋 복제, 다른 데이터베이스로 복제, 충돌 해소 등 조금 더 유연성이 필요한 상황에 유용하다.<br>
오라클의 골든게이터(GoldenGate), 트리거, 스토어드 프로시저를 사용한다.

- 트리거는 사용자 정의 애플리케이션 코드를 등록할 수 있게 한다.
- 트리거는 데이터 변경을 분리된 테이블에 로깅한다.
- 이 테이블로부터 데이터 변경을 외부 프로세스가 읽는다.
- 외부 프로세스는 필요한 애플리케이션 로직을 적용해 다른 시스템으로 데이터 변경을 복제한다.

### 복제 지연 문제

리더에서 일어난 쓰기와 팔로워에서 반영 사이에 지연시간을 의미한다.

애플리케이션이 비동기 팔로워에서 데이터를 읽을 때 팔로워가 뒤처진다면 지난 정보를 볼 수도 있다.

read-scaling 아키텍처에서는 실제로는 비동기만 가능

팔로워는 결국 리더를 따라잡는 것을 최종적 일관성(eventual consistency)이라고 한다.


#### 자신이 쓴 내용 읽기 (Reading Your Own Writes)

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/a91069b1-abbb-4049-abc4-e23a64358d91)


사용자가 쓰기를 수행한 직후 데이터를 본다면 새로운 데이터는 아직 복제 서버에 반영되지 않을 수 있다.<br>
이것은 사용자에게 제출된 데이터가 유실된 것처럼 보이기 때문에 불만족스러운 동작이다.<br>
그렇기에 리더 기반 복제 시스템에서는 **쓰기 후 읽기(read-after-write)** 일관성이 필요하다.<br>
사용자가 페이지를 재로딩했을 떄 항상 자신이 제출한 모든 갱신을 볼 수 있음을 보장하며 다른 사용자에 대해서는 보장하지 않는다.

- 사용자가 수정한 내용을 읽을 때는 리더에서 읽는다. 애플리케이션 내 대 부분 내용을 사용자가 편집한다면 read-scaling 이점을 무효화한다.
- 리더에서 읽을지 말지 결정하기 위해 ‘마지막 갱신 후 1분동안 리더에서 모든 읽기’, ‘리더보다 1분 이상 늦은 모든 팔로워에 질의 금지’ 등 기준을 적용한다.
- 클라이언트가 가장 최근 쓰기의 타임스탬프를 기억한다. 그러면 시스템은 사용자 읽기를 위한 복제 서버가 최소한 해당 타임스탬프까지 갱신을 반영하게 할 수 있다. 동일한 사용자가 여러 디바이스로 서비스를 접근할 때 또 다른 문제가 발생한다.
- 복제서버가 여러 데이터센터에 분산됐다면 복잡도가 증가한다. 리더가 제공해야하는 모든 요청은 리더가 포함된 데이터 센터로 라우팅돼야 한다.

#### 단조읽기 (Monotonic Reads)

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/15322634-dc43-45f2-855c-144b7ffedca9)


이전에 새로운 데이터를 읽은 후에는 예전 데이터를 읽지 않음을 보장한다.<br>
각 사용자의 읽기가 항상 동일한 복제 서버에서 수행되도록 사용자 ID의 해시를 기반으로 복제 서버를 선택하도록 할 수 있다. 

#### 일관된 순서로 읽기 (Consistent Prefix Reads)

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/627a89ce-7bf6-45f2-bee5-92458caca6c0)


사용자가 데이터베이스를 읽을 때 예전 상태의 일부와 새로운 상태의 일부를 함께 볼수 있다. 이는 파티셔닝된 데이터베이스에서 발생하는 특징적인 문제이다.<br>
일련의 쓰기가 특정 순서로 발생한다면 이 쓰기를 읽는 모든 사용자는 같은 순서로 쓰여진 내용을 보게 됨을 보장한다.<br>
한가지 해결책은 서로 인과성이 있는 쓰기가 동일한 파티션에 기록되게끔 하는 방법이다.<br>

#### 복제 지연을 위한 해결책

애플리케이션이 기본데이터베이스보다 더 강력한 보장을 제공하는 방법은 너무 복잡해서 잘못되기 쉽다.<br>
트랜잭션은 애플리케이션이 더 단순해지기 위해 데이터베이스가 더 강력한 보장을 제공하는 방법이다.<br>
분산(복제되고 파티셔닝된) 데이터베이스로 전환하는 과정에서 최종적 일관성이 아닌 더 높은 보장을 하는 여러 대안 매커니즘이 있다.
