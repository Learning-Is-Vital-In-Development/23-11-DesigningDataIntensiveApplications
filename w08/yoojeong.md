## 복제

복제중인 데이터가 시간이 지나도 변경되지 않는 데이터(`immutable`) : 그냥 모든 노드에 데이터를 복사하면 끝<br>
데이터가 변경될 수 있는 데이터(`mutable`) : 복제된 데이터의 변경 처리도 책임져야 하는 어려움이 있다

노드 간 변경을 복제하기 위한 알고리즘
- 단일 리더(single-leader) 복제
- 다중 리더(multi-leader) 복제
- 리더 없는(leaderless) 복제


### 리더와 팔로워

#### 복제 서버(replica)
데이터베이스의 복사본을 저장하는 각 노드를 복제 서버(replica)라 부른다. 
어떻게 모든 복제 서버에 동일한 데이터를 유지할 수 있을까? 

#### 리더 기반 복제
![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/87d7aec7-e674-4d48-b37b-71f822d3ac4c)

복제 서버 중 하나를 리더(leader/master/primary)로 지정한다. 
- 클라이언트는 쓰기 질의 요청을 리더에게 보내야 한다. 
- 리더는 먼저 로컬 저장소에 새로운 데이터를 기록한다.

  
다른 복제 서버는 팔로워(follower/읽기 복제 서버(read replica), Slave, secondary, hot standby)라고 한다. 
- 리더가 로컬 저장소에 변경을 기록하면 이를 **복제 로그(replication log**)나 **변경 스트림(change stream)**의 일부로 팔로워에게 전송한다. 
- 팔로워는 전달받은 로그를 기반으로 리더가 처리한 것과 동일한 순서로 모든 쓰기를 적용해 로컬 복사본을 갱신한다.

이러한 복제 모드는 postgreSQL(v9.0~), MySQL, 오라클 데이터 가드, SQL 서버의 상시 가용성 그룹과 같은 여러 관계형 데이터베이스에 내장된 기능이다.
(몽고DB, 리싱크DB, 에스프레소같은 일부 비관계형 데이터베이스에서도 사용)
더하여, 꼭 데이터베이스뿐 아니라 분산 메세지 브로커에서도 사용되며, 일부 네트워크 파일 시스템, 복제 블럭 디바이스에서도 유사하게 사용된다. 


#### sync vs async 복제

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/b7844798-7e2d-45ac-8717-0bffab060a4f)

||동기식 복제|비동기식 복제|반동기식 복제|
|:--:|:--:|:--:|:--:|
|예시|팔로워1|팔로워2|-|
|복제방식|리더는 팔로워의 응답을 기다린다<br>팔로워가 응답을 하지 않을 경우 리더는 모든 쓰기를 차단(block)하고 기다린다| 리더는 메시지를 전송하지만 응답을 기다리지 않는다<br>팔로워가 변경 내용을 적용하기까지 시간을 보장할 수 없다. (Ex: 팔로워가 장애 복구 중, 네트워크 문제 등)|모든 팔로워가 동기식이라면 임의 한노드의 장애는 전체 시스템을 멈출 수 있다.<br> 팔로워 하나는 동기식으로 하고 그 밖에는 비동기식으로 하는 방법|
|장점| 팔로워와 리더가 일관성있게 최신 데이터 복사본을 가지는 것을 보장|팔로워가 잘못되더라도 리더가 쓰기처리를 계속할 수 있다|최소 두 노드(리더 + 팔로우 1개)에 데이터의 최신 복사본이 있는 것을 보장한다.|


#### 새로운 팔로워 설정


데이터베이스를 잠근 후 복제를 할 경우 일관성은 확보할 수 있지만, 가용성 목표를 놓치게 된다. 
그렇기에 중단없이 팔로워 설정을 할 수 있어야 하는데 다음과 같이 할 수 있다. 

- DB를 잠그지 않고 리더의 DB 스냅숏을 가져온다.
- 스냅숏을 새로운 팔로워 노드에 복사한다.
- 팔로워는 리더와 연결해 스냅숏 이후 발생한 데이터 변경을 요청한다.
- 팔로워가 스냅숏 이후의 변경을 모두 처리했을 때 따라잡았다고 말한다.


### 노드 중단 처리

별도의 중단시간 없이 개별 노드를 재부팅할 수 있다면 운영 및 유지보스 측면에서 큰 장점이다. 

개별 노드의 장애에도 전체 시스템을 정상적으로 유지하고 노드 중단의 영향을 최소화해야한다.

#### 팔로워 장애: 따라잡기 복구

팔로워 장애 복구는 매우 쉽게 복구가능하다. 

- 결함 발생 직전 최종 수행 트랜잭션을 알아낸다.
- 리더와 연결한 뒤 연결이 끊어진 동안 발생한 데이터 변경을 모두 요청한다.
- 미처리 변경을 모두 적용하여 리더를 따라잡으면 복구 해결

#### 리더 장애: 장애 복구

리더의 장애를 처리하는건 매우 까다로운 장애 복구(failover) 과정을 거쳐야 한다.

- 리더 장애 판단: : 리더가 일정 시간 동안 응답하지 않을 경우(timeout) 죽은 것으로 간주한다.
- 새로운 리더 선택 : 합의(Ex: 복제 서버 다수결) 혹은 선출된 제어 노드에 의해 새로운 리더가 선정될 수 있다. 
- 시스템 재설정 : 리더가 새로 선정되었으면 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비해야 한다.


> 장애 복구 과정에서 발생할 수 있는 문제점
- 비동기식 복제를 할 경우 이전 리더의 쓰기 데이터 유실 가능성
  - 이전 리더가 처리하지 못한 쓰기를 모두 폐기해 해결할 수 있지만, 내구성이 떨어지게 된다.
- 개인 정보 유출
  - 이전 리더가 데이터베이스의 새로운 로우의 기본키 할당을 위해 자동증가 카운터를 사용했는데, 새로운 리더는 이전 리더의 쓰기가 유실된 경우 이 사실을 알 수 없기에 예전에 할당한 기본키를 재사용하게 되는데, 이 경우 불일치가 발생하여 개인정보가 잘못된 사용자에게 공개될 수 있다. 
- 스플릿 브레인(split brain)
  - 두 노드가 모두 자신이 리더라고 믿는 상황
  - 두 리더가 쓰기를 받으면서 충돌을 해결하는 과정을 거치지 않으면 데이터가 유실 혹은 오염될 수 있다. 
- 불필요한 장애 복구
  - 리더가 죽었다고 판단하는 타입아웃 시간을 너무 길게하면 리더가 작동하지 않은 시간부터 복구까지 시간이 오래걸린다.
  - 그렇다고 너무 짧은 타임아웃 시간은 불필요한 장애 복구가 있을 수 있다. 


### 복제 로그 구현 

#### 구문 기반 복제 과정

리더는 쓰기 요청(statement)을 수행 후 해당 구문 로그를 팔로워에게 전송한다. RDB는 전달받은 SQL문을 파싱하고 실행한다.

**복제가 깨질 수 있는 사례**

- 구문에서 비결정적 함수(`NOW()`, `RAND()`)를 사용하는 경우 복제서버마다 다른 값을 생성할 가능성이 있다.
- AutoIncrement를 사용하는 경우 각각의 복제 서버들은 모두가 동일한 순서로 실행되야 하고 이는 여러 트랜잭션이 동시에 수행되는 것을 제한한다
- 부수효과를 가진 구문( Trigger, Stored Procedure, 사용자 정의 함수)은 부수 효과가 완벽하게 결정적이지 않으면 각 복제서버에서 다른 사이드 이펙트가 발생할 수 있다.

**해결책**

- 구문 기반 복제
    - Leader는 구문을 기록할 때, 모든 비결정적 함수 호출을 고정 값을 반환하게끔 대체한다.
    - VoltDB, MySQL 5.1 미만
- 로우 기반 복제
    - MySQL 5.1 이상 

#### 쓰기 전 로그 배송(Write-ahead log, WAL)

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/c3fb385f-c63d-4196-b7fd-46550c461662)


로그 구조화 저장소 엔진이나 B 트리의 경우 모두 로그는 데이터베이스의 모든 쓰기를 포함하는 추가 전용(append-only) 바이트열이다.<br>
팔로워가 이 로그를 처리하면 리더와 동일한 데이터 구조의 복제본이 만들어 진다.

단점은 로그가 제일 저수준의 데이터를 기술한다는 점이다.

WAL은 어떤 디스크 블록에서 어떤 바이트를 변경했는지와 같은 상세정보도 포함하기 때문에 복제가 저장소 엔진과 의존성이 생기게 된다.<br>
그렇기에 리더와 팔로워의 DB 버전을 다르게 가져갈 수 없는 등의 문제가 생긴다.

> 해결 방법 : 팔로워를 리더보다 먼저 새로운 소프트웨어 버전을 사용하게끔 허용하여 팔로워를 먼저 업그레이드하면 중단없이 업그레이드가 가능하다.

#### 논리적(로우 기반) 로그 복제

복제 로그를 저장소 엔진의 물리적 데이터 표현과 구별하기 위해 논리적 로그라고 부른다.<br>
RDB용 논리적 로그는 보통 로우 단위로 데이터베이스 테이블에 쓰기를 기술한 레코드 열이다. 

- 삽입된 로우의 로그는 모든 칼럼의 새로운 값을 포함한다.
- 삭제된 로우의 로그는 식별 정보를 포함한다. (Ex: Primary Key)
- 갱신된 로우의 로그는 식별 정보와 새로운 값을 포함한다.

> 데이터 캡쳐(change data capture, CDC)
논리적 로그를 저장소 엔진과 분리했기 때문에 리더와 팔로우 사이 하위호환성 유지가 쉽고, 논리적 로그 형식은 외부 애플리케이션이 파싱하기 쉽기 때문에 데이터 웨어하우스 같은 외부 시스템에 데이터베이스의 내용을 전송하고자 할 때 유용하다.


#### 트리거 기반 복제

데이터의 서브셋만 복제하거나, 다른 종류의 데이터베이스로 복제해야 하거나, 충돌을 해소하기 위한 로직이 필요하다면 복제를 어플리케이션 레이어로 옮겨야 한다.

트리거는 사용자 정의 애플리케이션 코드를 등록해서 데이터베이스 시스템에서 데이터 변경이 감지되면 자동으로 분리된 테이블에 로깅하는 등 등록된 코드를 실행하도록 할 수 있다.<br>
다만, 트리거 기반 복제는 다른 방식에 비해 오버헤드가 더 많고, 버그나 제한 사항이 더 많이 발생한다. 하지만 유연성 측면에서 매우 유용하다.

### 복제 지연 문제
