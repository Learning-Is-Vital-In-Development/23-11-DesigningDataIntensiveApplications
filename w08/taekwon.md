# 05장. 복제

## 서론

복제란 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미다.

복제에서 인기 있는 알고리즘  세 가지가 있으며 이는 각 `단일리더`, `다중리더`, `리더없는`복제 이다.

복제에는 고려해야 할 많은 트레이드오프가 있으며, 이런 트레이드오프는 대개 데이터베이스의 설정 옵션이다.

## 리더와 팔로워

데이터베이스의 복사본을 저장하는 각 노드를 `복제 서버(replica)` ****라고 한다.

데이터베이스의 모든 쓰기는 모든 복제 서버에서 처리돼야 하며, 그렇지 않으면 복제 서버는 더 이상 동일한 데이터를 유지할 수 없다.

이 문제를 위한 가장 일반적인 해결책은 리더 기반 복제(`능동/수동`, `마스터 슬레이브`)라고 한다.

복제 서버 중 하나를 리더로 지정하며, 클라이언트가 데이터베이스에 쓰기를 할 때 클라이언트는 요청을 리더에게 보내야 한다.

다른 복제 서버는 `팔로워` 라고 하며, 리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 `복제로그` 나 `변경 스트림` 의 일부로 팔로워에게 전송한다. 각 팔로워가 리도로부터 로그를 받으면, 리더가 처리한 것과 동일한 순서로 모든 쓰기를 적용해 갱신한다.

## 동기식 대 비동기식 복제

복제 시스템의 중요한 사항은 복제가 `동기식`으로 발생하는지 `비동기식`으로 발생하는지 여부다.

![image](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/71249347/23f6c963-d624-498c-a94b-3fee78386833)

**동기식**

리더는 팔로워 1이 쓰기를 수신했는지 확인해 줄 때까지 기다린다. 이후 확인이 끝나면 사용자에게

성공을 보고하고 다른 클라이언트에게 해당 쓰기를 보여준다.

**비동기식**

리더는 메시지를 전송하지만 팔로워의 응답을 기다리지 않는다.

동기식 복제의 `장점은`팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장한다.

갑자기 리더가 작동하지 않아도 데이터는 팔로워에서 계속 사용할 수 있음을 확인할 수 있다.

`단점은` 동기 팔로워가 응답하지 않는다면 쓰기 자체가 처리될 수 없다는 것이다.

위의 이유로 사실 모든 팔로워가 동기식인 상황은 비현실적이다. 임의 한 노드의 장애가 전체 시스템에 영향을 주게 된다.

현실적으로 데이터베이스에서 동기식 복제를 사용하려면 보통 팔로워 하나는 동기식으로 하고, 그 밖에는 비동기식으로 하여 동기식 팔로워의 장애를 대처할 수 있도록 `반동기식`으로 구성한다.

반면 비동기식의 경우 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속 할 수 있는 장점이있다.

단점으로는 리더가 잘못되고 복구할 수  없으면 팔로워에 아직 복제되지 않은 모든 쓰기는 유실된다.

## 새로운 팔로워 설정

새로운 팔로워를 추가한다고 가정했을때, 해당 팔로워가 리더의 데이터 복제본을 정확히 가지고 있다는 보장을 어떻게 할 수 있을까

데이터베이스를 잠가서(쓰기가 불가능) 디스크의 파일을 일관성 있게 만들 수 있지만 고 가용성의 목표에 부합하진 않는다. 팔로워는 대개 중단시간 없이 수행 가능하기 때문에 아래와 같은 과정의 개념으로 수행 가능하다.

- 가능하다면 전체 데이터베이스를 잠그지 않고 스냅숏을 일정 시점에 가져온다.
- 스냅숏을 새로운 팔로워 노드에 복사한다.
- 팔로워는 리더에 연결해 스냅숏 이후 발생한 모든 데이터 변경을 요청한다.
- 팔로워가 스냅숏 이후 데이터 변경의 미처리분을 모두 처리했을때 따라잡았다고 말한다.

보통 스냅숏을 복사하기 위해선 리더의 복제 로그의 정확한 위치에 연관돼야 하며, 이위치의 명칭은 다양하다.(MySQL - 이진로그 좌표, PostgreSQL - 로그 일련번호)

## 팔로워 장애: 따라잡기 복구

팔로워가 죽어 재시작 하거나 리더와 팔로워 사이의 네트워크가 일시적으로 중단된다면 팔로워는 보관된 로그에서 결함이 발생하기 전에 처리한 마지막 트랜잭션을 기준으로 리더에 연결해 끊어진 동안 발생한 모든 데이터 변경을 요청할 수 있다.

## 리더 장애: 장애 복구

만일 리더가 장애가 생겼다면 어떻게 처리할까, 팔로워 중 하나를 새로운 리더로 승격해야하며, 클라이언트는 새로운 리더로 쓰기를 전송하기 위해 재설정이 필요하고, 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작해야 한다. 이 과정을 `장애복구(failover)` 라 한다.

자동 장애 복구는 보통 아래와 같은 단계로 구성된다.

1. 리더가 장애인지 판단한다.(대부분의 시스템은 단순히 타임아웃으로 체크한다.)
2. 새로운 리더를 선택한다.(복제 서버들의 투표로 이루어짐 ex. `정족수 합의`)
3. 새로운 리더 사용을 위해 시스템을 재설정 한다.

장애 복구 과정은 잘못될 수 있는 것 투성이다.

- 비동기식 복제 경우 새 리더는 이전 리더가 실패하기 전 쓰기를 수신하지 못할 수 있다.
- 쓰기를 폐기하는 방법은 외부 다른 저장소가 데이터베이스 내용에 맞춰 조정돼야 하면 위험하다.
- 특정 결함 시나리오에서 두 노드가 자신이 리더라고 믿는 `스플릿 브레인`이 발생할 수 있다.
- 리더가 분명히 죽었다고 판단 가능한 타임아웃에 대한 결정이 어렵다.

## 구문 기반 복제

리더는 모든 쓰기 요청(구문)을 기록하고 쓰기를 실행한 다음 구문 로그를 팔로워에게 전송한다.

각 팔로워는 클라이언트에서 직접받은 것처럼 SQL구문을 파싱하고 실행한다.

합리적으로 보이는 이 접근법에도 복제가 깨줄수 있는 다양한 사례가 있다.

- 현재 시간을 얻기 위한 NOW()나 RAND() 같은 구문은 각 서버마다 다른 값을 생성할 수 있다.
- 자동증가 칼럼을 사용하는 구문이나 데이터베이스에 있는 데이터에 의존한다면 정확히

  같은 순서로 실행돼야 한다.

- 부수 효과를 가진 구문(트리거, 사용자 정의 함수)은 완벽하게 결정적이지 않으면 각 복제 서버에서 다른 부수 효과가 발생한다.

## 쓰기 전 로그 배송

앞에서 봤던 SS테이블, LSM트리 혹은 B트리 모두 데이터베이스의 모든 쓰기를 포함하는 추가전용(append-only) 바이트 열이다. 완전히 동일한 로그를 사용해 다른 노드에서 복제 서버를 구축할수있지만 가장 큰 단점은 로그가 제일 저 수준의 데이터를 기술한다는 점이다.

WAL은 어떤 디스크 블록에서 어떤 바이트를 변경했는지와 같은 상세 정보를 포함하여, 복제가 저장소 엔진과 밀접하게 엮인다. 데이터베이스가 저장소 형식을 다른 버전으로 변경한다면, 리더와 팔로워 간의 데이터베이스 소프트웨어 버전을 다르게 실행할 수 없다.

## 논리적(로우기반) 로그 복제

그렇다면 복제로그를 저장소 엔진 내부와 분리하기 위한 대안은 뭐가 있을까

복제와 저장소 엔진을 다른 로그형식으로 관리하는 것이다. 이 같은 종류의 복제 로그를 저장소 엔진의(물리적) 데이터 표현과 구별하기 위해 `논리적 로그`(logical log)라고 부른다.

- 삽입된 로우의 로그는 모든 칼럼의 새로운 값을 포함한다.
- 삭제된 로우의 로그는 로우를 고유하게 식별하는데 필요한 정보를 포함한다.(ex pk)
- 갱신된 로우의 로그는 고유하게 식별하는 데 필요한 정보와 모든 칼럼의 새로운 값을 포함한다.

논리적 로그는 저장소 엔진 내부와 분리했기 때문에 하위 호환성을 더 쉽게 유지할 수 있고 리더와 팔로워에서 다른 버전의 소프트웨어 및 다른 저장소 엔진을 실행할 수 있다.

또한 외부 애플리케이션이 파싱하기 더 쉬우며 이러 한 측면은 사용자 정의 색인과 캐시 구축을 위해 데이터 웨어하우스 같은 외부 시스템에 내용을 전송하고자 할 때 유용하다.

## 트리거 기반 복제

이전 복제 접근 방식과 다르게 데이터의 서브셋만 복제하거나 다른 종류의 데이터베이스로 복제해야 하거나 충돌 해소 로직이 필요하다면 복제를 애플리케이션 층으로 옮겨야 한다.

이중 많은 관계형 데이터베이스에서 사용할 수 있는 기능인 `트리거`나 `스토어드 프로시저`를 사용한다. 트리거는 데이터베이스 시스템에서 데이터가 변경되면(쓰기 트랜잭션) 자동으로 실행되어 데이터 변경을 분리된 테이블에 로깅할 수 있는 기회를 가진다.

일반적으로 트리거 기반 복제는 많은 오버헤드가 있지만, 유연성 때문에 매우 유용하다.

## 복제 지연 문제

리더 기반 복제는 모든 쓰기가 단일 노드를 거쳐야 하지만, 읽기 전용 질의의 경우 어떤 복제 서버에서도 가능하다. 많은 팔로워를 만들어 팔로워 간 읽기 요청을 분산하는 매력적인 옵션인 읽기 확장 아키텍처에서는 간단히 팔로워를 더 추가함으로써 읽기 전용 요청을 처리하기 위한 용량을 느릴 수 있다.

보통 위와 같은 방법은 비동기식 복제에서만 동작하는데 이런 경우 비동기 팔로워가 뒤처진다면 지난 정보를 볼 수도 있다. 다만 이러한 문제는 일시적으로 리더와 팔로워에 동일한 질의를 수행하면 모든 쓰기가 팔로워에 반영되지 않았기 때문에 불일치가 발생할 수 있다. 사실 데이터베이스에 쓰기를 머추고 잠시 기다리면 팔로워는 리더와 일치하게 되는데 이런 효과를 최종적 일관성 이라고한다.

그러나 일반적으로 복제 서버가 얼마나 뒤처질 수 있는 지에 대한 제한은 없다. 시스템이 가용량 근처에서 동작하거나, 네트워크 문제가 있으면 지연은 쉽게 수 초에서 수 분으로 증가할 수 있다.

**[자신이 쓴 내용 읽기]**

비동기식 복제에서는 사용자가 쓰기를 수행한 직후 데이터를 볼 때 아직 복제 서버에 반영되지 않을 수 있어 데이터가 유실된 것처럼 보일 수 있다.

![image](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/71249347/83343f7c-2726-43ff-87bf-c7502d310dc9)

이런 상황에서는 쓰기 후 읽기 일관성이 필요하다.

- 사용자가 수정한 내용을 읽을 때는 리더에서 읽는다, 그 밖에는 팔로워에서 읽는다.
- 애플리케이션 내 대부분이 사용자가 편집할 가능성이 있다면, 마지막 갱신 시각을 찾아 갱신 후 1분 동안은 리더에서 모든 읽기를 수행한다. 또한 팔로워에서 복제 지연을 모니터링해 1분보다 늦은 팔로워에 대한 질의를 금지한다.
- 가장 최근 쓰기의 타임스탬프를 기억하여 사용자 읽기를 위한 복제 서버가 최소한 해당 타임스탬프까지 갱신을 반영하게 할 수 있다.
- 리더가 제공해야 하는 모든 요청은 리더가 포함된 데이터센터로 라우팅 한다.

**[단조읽기]**

비동기식 팔로워에서 읽을 때 발생할 수 있는 두 번째 이상 현상으로 사용자가 시간이 거꾸로 흐르는 현상을 목격할 수 있다는 것이다.

![image](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/71249347/f66f18cc-591b-41bf-9799-d7d96d7247cd)

단조 읽기는 이런 현상이 발생하지 않음을 보장한다.

단조 읽기를 달성하는 한 방법은 각 사용자의 읽기가 항상 동일한 복제 서버에서 수행 되게끔 하는 것이다. 예를 들어 임의 선택보다는 해시를 기반으로 복제서버를 선택하여 저장한다.

**[일관된 순서로 읽기]**

이번엔 관찰자가 정상적인 순서로 데이터를 읽는 것이 아닌 뒤죽박죽의 순서로 데이터를 읽는 현상이 있다.

![image](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/71249347/52c5314d-cd1d-4ef2-b3ab-633e0673ee3a)

이런 종류의 이상 현상을 방지하려면 일관된 순서로 읽기 같은 또 다른 유형의 보장이 필요하다.

일관된 순서로 읽기는 일련의 쓰기가 특정 순서로 발생한다면 이 쓰기를 읽는 모든 사용자는 같은 순서로 쓰여진 내용을 보게 됨을 보장한다.

이는 파티셔닝된(샤딩된) 데이터베이스에서 발생하는 특징으로, 많은 분산 데이터베이스에서 서로 다른 파티션은 독립적으로 동작하기 때문에 쓰기의 전역 순서가 없어 사용자가 데이터베이스에서 읽을 때 예전 상태의 일부와 새로운 상태의 일부를 함께 볼 수 있다.

이는 서로 인과성이 있는 쓰기가 동일한 파티션에 기록되게끔 하는 방법이있다, 하지만 일부 애플리케이션에는 효율적이지 않다.

## 복제 지연을 위한 해결책

사실은 복제가 비동기식으로 동작하지만 동기식으로 동작하는 척하는 것이 문제 해결방안이다.

애플리케이션이 기본 데이터베이스보다 더 강력한 보장을 제공하는 방법이 있지만, 이 문제를 다루기에는 너무 복잡해서 잘못되기 쉽다.

이에, 데이터베이스를 신뢰 하도록 트랜잭션이 존재한다. 그러나 분산 데이터베이스로 전환 하는 과정에서 많은 시스템이 트랜잭션을 포기했다. 트랜잭션이 성능과 가용성 측면에서 너무 비싸고 확장 가능 시스템에서는 어쩔 수 없이 최종적 일관성을 사용해야 한다는 주장도 있다.

## 다중 리더 복제

리더 기반 복제의 주요한 단점으로 어떤 이유로 리더에 연결할 수 없다면 데이터베이스에 쓰기를 할 수 없다는 점이다.

이에, 쓰기를 허용하는 노드를 하나 이상 두는 것으로 자연스럽게 확정되었으며, 이 방식을 `다중리더` 설정 이라고 부른다.

**[다중 데이터센터 운영]**

일반적인 리더 기반 복제 설정은 리더가 하나의 데이터센터에 있고 모든 쓰기는 해당 데이터센터를 거쳐야 한다. 이에 반해, 다중 리더 설정에서는 각 데이터센터마다 리더가 있을 수 있으며, 각 데이터센터 내에는 보통의 리더 팔로워 복제를 사용하고 데이터센터 간에는 각 데이터 센터의 리더가 다른 데이터센터의 리더에게 변경 사항을 복제한다.

![image](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/71249347/96fde221-f1dc-4c62-8f06-e94dcd6d9488)

다중 리더에선 각 데이터센터마다 리더가 있을수 있으며, 각 데이터센터 내에는 보통의 리더 팔로워 복제를 사용하고 데이터센터 간에는 각 데이터센터의 리더가 다른 리더에게 변경사항을 복제한다.

- 다중리더 설정에서 모든 쓰기는 로컬 데이터센터에서 처리 후 비동기 방식으로 다른 데이터센터에 복제되는데, 이 때 데이터센터간 네트워크 지연은 사용자에게 숨겨지고 사용자가 인지하는 성능은 더 좋게 느껴진다.
- 다중 리더 설정은 각 데이터센터는 다른 데이터센터와 독립적으로 동작하고 고장 난 데이터센터가 온라인으로 돌아 왔을때 복제를 따라 잡는다.
- 비동기 복제를 사용하는 다중 리더 설정은 일시적인 네트워크 중단에도 쓰기 처리는 진행된다.

## 오프라인 작업을 하는 클라이언트

디바이스가 현재 인터넷에 연결됐는지 여부와 관계없이 언제든 회의를 볼 수 있어야(읽기 요청) 하고, 언제라도 회의에 참가 할 수 있어야 한다.(쓰기 요청) 이 경우 모든 디바이스에는 리더처럼 동작하는 로컬 데이터베이스가 있고, 모든 모든 디바이스 상에서 캘린더의 복제 서버 간 다중 리더 복제를 비동기로 수행하는 프로세스(동기화)가 있다.

## 협업 편집

동시에 여러 사람이 문서를 편집할 수 있는 애플리케이션ㅇ르 실시간 협업 편집 이라고 한다.

보통은 다른 사용자가 같은 문서를 편집하려면 첫 번째 사용자의 변경이 커밋되고 잠김이 해제될 때까지 기다려야 하지만, 더 빠른 협업을 위해 변경 단위를 매우 작게 해서 잠금일 피할 수 있으며, 이러한 방식은 여러 사용자가 동시에 편집할 수 있지만 충돌 해소가 필요한 경우 등의 문제를 야기한다.

## 쓰기 충돌 다루기

다중 리더 복제에서 제일 큰 문제는 쓰기 충돌이 발생한다는 점이며, 충돌 해소가 필요하다는 의미다.

![image](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/71249347/73e60996-0d07-4887-bca7-d77576d80e9f)

- 다중 리더 복제에서 가장 큰 문제는 쓰기 충돌
- 각 사용자가 동시에 편집 후 로컬 리더에 저장하였으나 변경을 비동기로 복제 시 쓰기 충돌 발생
- 동기식으로 충돌 감지를 하면 다중 리더 복제의 장점을 잃어 버림

## 충돌 회피

- 충돌을 처리하는 제일 간단한 전략.
- 특정 레코드의 모든 쓰기가 동일한 리더를 거치도록 애플리케이션이 보장하면 충돌은 발생하지 않음.
- 데이터센터가 고장 나서 트래픽을 다른 데이터센터로 다시 라우팅해야 하거나 사용자가 다른 지역으로 이동해 다른 데이터센터가 가깝다면 레코드를 위해 지정된 리더를 변경하는 경우 충돌 회피가 실패함 → 다른 리더에서 동시 기록 가능성을 대처해야 함.

## 일관된 상태 수렴

- 모든 복제 계획은 모든 복제 서버가 최종적으로는 동일하다는 사실을 보장 해야함.
- 데이터베이스는 수렴 방식으로 충돌을 해소해야 함.
- 각 쓰기에 고유ID를 부여하고 가장 높은 ID를 가진 쓰기를 고르고, 다른 쓰기를 버린다. 이를 최종 쓰기 승리(LWW)라고 한다.
- 각 복제 서버에 고유 ID를 부여하고 높은 숫자의 복제 서버에서 생긴 쓰기가 낮은 숫자의 복제 서버에서 생긴 쓰기보다 항상 우선적으로 적용되게 한다.(데이터 유실 가능성이 있음.)
- 사전순으로 정렬한 후 연결한다.
- 명시적 데이터 구조에 충돌을 기록해 모든 정보를 보존한다.(충돌을 해소하는 애플리케이션 코드를 작성한다.)

## 사용자 정의 충돌 해소 로직

충돌을 해소하는 가장 적합한 방법은 애플리케이션에 따라 다르며 코드를 사용해 충돌 해소 로직을 작성하고 이는 쓰기나 읽기 수행중 실행될 수 있다.

- 쓰기 수행중

  복제된 변경 사항 로그에서 데이터베이스 시스템 충돌이 감지되면 충돌 핸들러를 호출한다.(백그라운드에서 실행)


- 읽기 수행중

  충돌을 감지하면 모든충돌쓰기를 저장하며, 다음 번 읽기 시 여러 데이터를 반환되고, 애플리케이션은 사용자에게 충돌 내용을 보여주거나 자동으로 충돌을 해소할 수 있다.(충돌을 해소한 결과는 다시 기록)

## 다중 리더 복제 토폴로지

`복제 토폴로지`는 쓰기를 한 노드에서 다른 노드로 전달하는 통신 경로를 설명한다.

리더가 둘 이상이라면 다양한 토폴로지가 가능하다.

![image](https://github.com/Learning-Is-Vital-In-Development/23-11-DesigningDataIntensiveApplications/assets/71249347/687e29c6-1da3-468e-846d-ea61ce73e26e)

- `원형 토폴로지`는 각 노드가 하나의 노드로부터 쓰기를 받고, 이 쓰기를 다른 한 노드에게만 전달한다.(MySQL에서 기본적으로 이 방식을 사용)
- `별 모양 토폴로지`는 지정된 루트 노드 하나가 다른 모든 노드에 쓰기를 전달 한다.(트리로 일반화)
- `전체 연결토폴로지`는 모든 리더가 각자의 쓰기를 모든 리더에게 전송한다.
- 원형과 별 모양 토폴로지는 하나의 노드에 장애가 다른 노드 간 복제 흐름의 방해를 주기 때문에 내결함성이 좋지않다.
- 전체 연결 토폴로지는 단일 장애점을 피할 수 있어 내결함성이 더 좋다, 다만 리더간 네트워크 연결 속도가 다르다면 일부 복제 데이터가 다른 데이터를 추월하여 일관된 순서로 복제되지 않을 수 있다.