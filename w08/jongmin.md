
# 분산 데이터

- 확장성: 부하 분산
- 내결함성 / 고가용성: 장비 하나에 문제가 발생해도 다른 장비 사용
- 지연시간: 지리적으로 가까운 곳에 데이터 센터 위치

# 고부하로 확장
- 공유 메모리 아키텍처: 스케일 업
- 비공유 아키텍처: 스케일 아웃
	- 노드 간 통신이 필요해서 복잡해짐

복제 대 파티셔닝
- 복제: 같은 데이터의 복사본을 다른 여러 노드에 유지함, 중복성을 제공함
- 파티셔닝: 큰 데이터베이스를 파티션이라는 작은 서브넷으로 나누고 각 파티션을 각기 다른 노드에 할당(샤딩)


# 5장: 복제

복제가 필요한 이유
- 확장성: 부하 분산
- 내결함성 / 고가용성: 장비 하나에 문제가 발생해도 다른 장비 사용
- 지연시간: 지리적으로 가까운 곳에 데이터 센터 위치시켜 지연 시간을 줄임

노드 간 변경을 복제하기 위한 3가지 인기 있는 알고리즘
1. 단일 리더
2. 다중 리더
3. 리더 없는 복제

복제에서 고려해야할 트레이드오프
- 동기식 vs 비동기식
- 잘못된 복제본의 처리

*최종적 일관성: 시간이 지나면 결국은 노드들의 데이터가 일치하게됨

## 5.1. 리더와 팔로워

리더 기반으로 복제하는 방법, Active / Passive, Master / Slave 라고도 함
- 노드 중 하나를 리더로 지정하고 리더가 데이터를 쓰기 할 때마다 복제 로그나 변경 스트림을 팔로워에게 전송함
- 각 팔로워는 로그를 받아 리더가 처리한 것과 동일한 순서로 모든 쓰기를 적용함

### 5.1.1. 동기식 대 비동기식 복제

- 복제가 동기식으로 비동기식으로 일어나는지를 지정 (보통은 관계형 데이터베이스의 옵션)
- 동기식은 팔로워와 리더가 동일한 데이터를 가지고 있는 것을 보장할 수 있음
- 하지만 팔로워가 죽거나 네트워크 문제로 응답하지 않으면 쓰기 작업이 처리 될 수 없음

- 보통 리더 기반 복제는 비동기식으로 구성

### 5.1.2. 새로운 팔로워 설정

- 복제 수를 늘리거나 장애 노드 대체 시 새로운 팔로워 설정이 필요

새로운 팔로워가 리더의 데이터 복제본을 정확히 가지고 있는지 보장하는 방법
1. 스냅샷 데이터를 팔로워 노드에 복사
2. 팔로워는 리더에 연결해 스냅샷 이후에 발생한 모든 데이터 변경을 요청
- PostgreSQL: log sequence
- MySQL: Binlog
3. 팔로워가 스냅샷 이후 데이터 변경의 미처리분을 모두 처리하면 OK
	
### 5.1.3. 노드 중단 처리

- 개별 노드의 장애에도 전체 시스템이 동작하게끔 노드 중단의 영향을 최소화

#### 5.1.3.1. 팔로워 장애: 따라잡기 복구

- 팔로워는 연결이 끊어진 이후에 발생한 데이터 변경을 리더로부터 싱크 받음 (심플))

#### 5.1.3.2. 리더 장애: 장애 복구

까다로움
- 리더가 장애인지 판단하는 기준 (ex. 지연시간 30초?)
- 팔로워 중 하나를 리더로 승격 해야함
- 클라이언트는 쓰기 요청 시 새로운 리더에 요청해야함


팔로워가 이전 리더의 모든 데이터를 수신했다고 보장할 수 있는가?

### 5.2.3. 복제 로그 구현

#### 5.2.3.1. 구문 기반 복제
```
Insert ....
```

#### 5.2.3.2. 쓰기 전 로그 배송


#### 5.2.3.3. 논리적(로우 기반) 로그 복제

- MySQL Binlog
- CDC (Change Data Capture)에 활용
- 논리적 로그 형식은 외부 애플리케이션에서 파싱하기 쉬움 
```
(a, 1, 2, 3, 4)
```


## 5.2. 복제 지연 문제

### 5.2.1. 자신이 쓴 내용 읽기

### 5.2.2. 단조 읽기

### 5.2.3. 일관된 순서로 읽기

### 5.2.4. 복제 지연을 위한 해결책


## 5.3. 다중 리더 복제

### 5.3.1. 다중 리더 복제의 사용 사례

### 5.3.2. 쓰기 충돌 다루기

### 5.2.3. 다중 리더 복제 토폴로지


