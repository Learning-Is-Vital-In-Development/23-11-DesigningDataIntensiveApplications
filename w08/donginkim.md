복제란 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지한다는 의미이다. 데이터 복제가 필요한 이유는 여러가지다.

- 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다.
- 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성을 노핑ㄴ다.
- 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다.

복제중인 데이터가 시간이 지나도 변경되지 않는다면 복제는 쉽다. 복제에서 모든 어려움은 **복제된 데이터의 변경 처리**에 있다.

노드 간 변경을 복제하기 위해 세 가지 인기있는 알고리즘인 **단일 리더(single-leader)**, **다중 리더(multi-leader)**, **리더 없는(leaderless)** 복제를 살펴보겠다.

복제에서 고려해야할 많은 트레이드  오프

- 동기식 복제와 비동기식 복제
- 잘못된 복제본을 어떻게 처리할지

# 리더와 팔로워

데이터베이스의 복사본을 저장하는 각 노드를 복제 서버(replica)라고 한다. 다중 복제 서버를 사용하면 모든 복제 서버에 모든 데이터가 있다는 사실을 어떻게 보장할까?

> 모든 쓰기는 모든 복제서버에서 처리되어야 한다. 그렇지 않으면 복제 서버는 더 이상 동일한 데이터를 유지할 수 없다?

위의 문제에 대한 가장 일반적인 해결책은 리더 기반 복제(leader-based replication, 능동(active)/수동(passive), 마스터(master) 슬레이브(slave) 복제라고한다. 복제 서버 중 하나를 리더(leader)(마스터나 프라이머리(primary)라고도 함)로 지정한다. 클라이언트가 데이터베이스에 쓰기를 할 때 클라이언트는 요청을 리더에게 보내야 한다. 리더는 먼저 로컬 저장소에 새로운 데이터를 기록한다.

다른 복제 서버는 팔로워(follower)(읽기 복제 서버(read replica), 슬레이브, 2차(secondary), 핫 대기(hot standby))라고 한다. 리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 복제 로그(replication log)나 변경 스트림(change stream)의 일부로 팔로워에게 전송한다.

각 팔로워가 리더로부터 로그를 받으면 리더가 처리한 것과 동일한 순서로 모든 쓰기를 적용해 그에 맞게 데이터베이스의 로컬 복사본을 갱신한다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/a0f4601c-4a97-483e-ba50-c0c3b4cae197)

클라이언트가 데이터베이스로부터 읽기를 할 때 리더 혹은 팔로워에게 질의할 수 있다. 하지만 스기는 리더에게만 허용된다.

대부분의 RDB 뿐만 아니라 NoSQL, Message Broker에서도 사용된다.

## 동기식 대 비동기식 복제

복제가 동기식으로 발생하는지 비동기식으로 발생하는지 여부이다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/105c778a-c1d5-4edc-b8fa-239519e43851)

- 그림에서 Follower 1의 복제는 동기식이다.
    - 팔로워와 리더가 최신 데이터 복사본을 가지는 것을 보장한다.
    - 동기 팔로워가 응답하지 않는다면 쓰기가 처리될 수 없다.
- Follower 2의 복제는 비동기식이다.
- 보통 모든 팔로워가 동기식인 상황은 비현실적이다.
    - 보통 팔로워 하나가 동기식 나머지는 비동기식으로 하는 경우가 많다. 이런 설정을 반동기식(semi-synchronous)이라 한다.
- 보통 **리더 기반 복제는 완전히 비동기식으로 구성**한다.
    - 리더가 잘못되고 복구할 수 없으면 복제되지 않은 모든 쓰기는 유실된다.
    - 하지만 비동기식 설정은 모든 팔로워가 잘못되더라도 리더가 쓰기 처리를 계속할 수 있다는 장점이 있다.

> 리더 작동이 실패해서 비동기식 복제 시스템의 데이터가 유실되는 문제는 심각하다. 이를 해결하기 위해 체인 복제가 동기식 복제의 변형으로 연구되었다. 또한 복제 일관성과 합의(여러 노드가 값에 동의하는 것) 사이에는 강한 연관성이 있다.

## 새로운 팔로워 설정

복제 서버 수를 늘리거나 장애 노드의 대체를 위해 새로운 팔로워를 설정해야 한다. 새로운 팔로워가 리더의 데이터 복제본을 정확히 가지고 있는지 어떻게 보장할까?

1. 리더의 데이터베에스 스냅샷을 일정 시점에 가져온다. 대부분의 데이터베이스는 백업이 필요하기 때문에 이 기능을 갖추고 있다.
2. 스냅샷을 새로운 팔로워 노드에 복사한다.
3. 팔로워는 리더에 연결해 스냅샷 이후 발생한 모든 데이터 변경을 요청한다. 스냅샷이 리더의 복제 로그의 정확한 위치와 연관되어야 한다. 이 위치의 명칭은 다양한다. PostgreSQL 에서는 로그 일련번호(log sequence number)라 하고 MySQL에서는 이진로그 좌표(binlog coordinate)라 부른다.
4. 팔로워가 스냅샷 이후 데이터 변경의 미처리분(backlog)을 모두 처리했을 때 따라잡았다고 말한다. 이제부터 리더에 발생하는 데이터 변화를 이어 처리할 수 있다.

## 노드 중단 처리

- 계획된 유지보수로 인해 중단되는 경우가 있다. 하지만 중단시간 없이 개별 노드를 재부팅할 수 있다는 점은 운영과 유지보수의 큰 장점이다.
- 개별 노드의 장애에도 전체 시스템이 동작하게끔 유지하고 노드 중단의 영향을 최소화하는 것이 목표이다.

### 팔로워 장애: 따라잡기 복구

- 각 팔로워는 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에 보관한다.
- 팔로워가 죽어 재시작하거나 리더와 팔로워 사이의 네트워크가 일시적으로 중단된다면 팔로워는 쉽게 복구할 수 있다.
    - 보관된 로그에서 결함이 발생하기 전에 처리한 마지막 트랜잭션을 알아낸다.
    - 팔로워는 리더에 연결해 팔로워 연결이 끊어진 동안 발생한 데이터 변경을 모두 요청한다.
    - 변경이 다 적용되면 리더를 다 따라잡게되고 이전과 같이 데이터 변경의 스트림을 계속 받을 수 있다.

### 리더 장애: 장애 복구

리더의 장애를 처리하는 일은 까다롭다. **팔로워 중 하나를 새로운 리더로 승격**해야 하고 클라이언트는 새로운 리더로 쓰기를 전송하기 위해 재설정이 필요하며 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작해야 한다. 이 과정을 장애 복구(failover)라 한다.

장애복구는 관리자가 수동으로 진행하거나 자동으로 진행된다.

**자동 장애 복구**

1. 리더가 장애인지 판단
    - 대부분의 시스템은 타임아웃을 사용. 노드들은 서로 메시지를 주고 받으며 일정시간 동안 노드가 응답하지 않으면 죽은 것으로 간주한다.
2. 새로운 리더를 선택
    - 선출 과정(리더가 나머지 복제 서버의 대다수에 의해 선택됨)을 통해 이뤄지거나 이전에 선출된 제어 노드(controller note)에 의해 새로운 리더가 임명될 수 있다. 새로운 리더로 가장 적합한 후보는 보통 이전 리더의 최신 데이터 변경사항을 가진 복제 서버다.
3. 새로운 리더 사용을 위해 시스템을 재설정한다.
    - 클라이언트는 새로운 쓰기 요청을 새로운 리더에게 보내야 한다. 이전 리더가 돌아오면 자신이 리더라 믿을 수 있으며 다른 복제 서버들이 자신을 리더에서 물러나게 한 것을 알지 못한다. 시스템은 이전 리더가 팔로워가 되고 새로운 리더를 인식할 수 있게끔 해야한다.

장애 복구 과정에서 생길 수 있는 문제

- 비동기식 복제를 사용하면 새로운 리더는 이전 리더가 실패하기 전에 이전 리더의 쓰기 일부를 수신하지 못할 수 있다. 리더의 복제되지 않은 쓰기를 단순히 폐기하는 방법으로 많이 사용한다.
- 깃허브에서 유효하지 않은(out-of-date) MySQL 팔로워가 승격한 적이 있는데 PK를 할당하기 위해 자동 증가 카운터를 사용했다. 그런데 새로운 리더의 카운터는 이전 리더보다 뒤쳐져 있었기 때문에 이전 리더가 예전에 할당한 기본키를 재사용했다. 이 기본키는 레디스 저장에도 사용했기 때문에 기본키의 재사용은 MySQL과 레디스 간 불일치를 일으켰다. 결국 일부 개인 데이터가 잘못된 사용자에게 공개됐다.
- 특정 결함 시나리오에서 두 노드가 모두 자신이 리더라고 믿을 수 있다. 이런 상황을 플릿 브레인(split brain)이라고 한다. 두 리더가 쓰기를 받으면서 충돌을 해소하는 과정을 거치지 않으면 데이터가 유실되거나 오염된다. 일부 시스템에는 안전 장치로 두 리더가 감지되면 한 노드를 종료하는 매커니즘이 있다. 그러나 이 매커니즘도 주의깊게 설계하지않으면 두 리더가 모두 종료되는 경우가 있다.
- 리더가 죽었다고 판단 가능한 적절한 타임아웃은 얼마정도일까. 길면 리더가 작동하지 않은 시간이 길어지고 짧은 타임아웃은 불필요한 장애 복구가 진행될 수 있다.

## 복제 로그 구현

리더 기반 복제의 내부적인 동작

### 구문 기반 복제

리더는 모든 쓰기 요청(구문(statement))을 기록하고 쓰기를실행한 다음 구문 로그를 팔로워에게 전송한다. RDB는 모든 구문을 팔로워에게 전달하고 팔로워는 SQL 구문을 파싱하고 실행한다.

- 현재 날짜와 시간을 얻기 위한 NOW() 혹은 임의 숫자를 얻는 RAND() 같은 비결정적 함수를 호출하는 구문은 서버마다 다른 값을 생성할 수 있다.
- 자동증가 컬럼이나 데이터베이스에 의존하는 구문은 각 복제서버에서 정확히 같은 순서로 실행되어야 한다. 이 방식은 동시에 여러 트랜잭션이 수행되는 것을 제한하게 한다.
- 부수 효과를 가진 구문(트리거, 스토어드 프로시저, 사용자 정의 함수)은 완벽하게 결정적이지 않으면 각 복제 서버에서 다른 부수효과가 발생할 수 있다.

MySQL 5.1 이전에는 구문 기반 복제(statement-based replication)이 사용됐다. 하지만 이제 구문에 비결정성이 있다면 기본적으로 로우 기반 복제(row-based replication)로 변경한다.

### 쓰기 전 로그 배송

일반적으로 데이터베이스의 모든 쓰기는 로그에 기록한다.

- 로그 구조화 저장소 엔진의 경우 로그 자체가 저장소의 주요 부분이다. 로그 세그먼트는 작게 유지되고 백그라운드로 가비지 컬렉션을 한다.
- 개별 디스크 블록에 덮어쓰는 B 트리의 경우 모든 변경우 쓰기 전 로그(Write-ahead log, WAL)에 쓰기 때문에 고장 이후 일관성 있는 상태로 색인을 복원할 수 있다.

두 경우 모두 로그는 추가 전용(append-only) 바이트 열이다. 완전히 동일한 로그로 다른 노드에서 복제 서버를 구축할 수 있다. 리더는 디스크에 로그를 기록하는 일 이외에도 팔로워에게 네트워크로 로그를 전송하기도 한다. 가장 큰 단점은 로그가 제일 저수준의 데이터를 기술한다는 점이다. 데이터베이스가 저장소 형식을 다른 버전으로 변경한다면 리더와 팔로워의 데이터베이스 소프트웨어 버전을 다르게 실행할 수 없다.

WAL 배송(shipping)과 같이 복제 프로토콜이 버전의 불일치를 허용하지 않는다면 소프트웨어 업그레이드할 때 중단시간이 필요하다.

### 논리적(로우 기반) 로그 복제

복제 로그를 저장소 엔진 내부와 분리하기 위한 대안 하나는 복제와 저장소 엔진을 위해 다른 로그 형식을 상ㅇ하는 것이다. 복제 로그를 저장소 엔진의 (물리적) 데이터 표현과 구별하기 위해 논리적 로그(logical log)라고 부른다. 관계형 데이터베이스용 논리적 로그는 대개 로우 단위로 데이터베이스 테이블에 쓰기를 기술한 레코드 열이다.

- 삽입된 로우의 로그는 모든 컬럼의 새로운 값을 포함한다.
- 삭제된 로우의 로그는 로우를 고유하게 식별하는데 필요한 정보를 포함한다. 보통은 PK, PK가 없다면 모든 컬럼의 예전값을 로깅한다.
- 갱신된 로그는 로우를 고유하게 식별하는데 필요한 정보와 모든 컬럼의 새로운 값(적어도 변경된 모든 컬럼의 새로운 값)을 포함한다.

여러 로우를 수정하는 트랜잭션은 여러 로그 레코드를 생성한 다음 트랜잭션이 커밋됐음을 레코드에 표시한다. MySQL 이진 로그는 이 접근 방식을 사용한다. 논리적 로그를 저장소 엔진 내부와 분리했기 때문에 하위 호환성을 더 쉽게 유지할 수 있고 리더와 팔로워에서 다른 버전의 데이터베이스 소프트웨어, 심지어 다른 데이터베이스에서도 실행할 수 있다.

또한 논리적 로그 형식은 외부 애플리케이션이 파싱하기 더 쉽다. 이런 측면은 오프라인 분석이나 사용자 정의 색인과 캐시 구축을 위해 데이터 웨어하우스 같은 외부 시스템에 데이터베이스의 내용을 전송하고자 할 때 유용하다. 이 기술을 변경 데이터 캡처(change data capture, CDC)라 부른다.

### 트리거 기반 복제

오라클의 골든게이트(GoldenGate) 같은 도구는 데이터베이스 로그를 읽어 애플리케이션이 데이터를 변경할 수 있게 한다. 다른 방법으로는 RDB에서 사용할 수 있는 기능인 **트리거**나 **스토어드 프로시저**를 사용한다.

트리거는 사용자 정의 애플리케이션 코드를 등록할 수 있게 한다. 애플리케이션 코드는 데이터 베이스 시스템에서 데이터가 변경되면 자동으로 실행된다. 따라서 이 테이블로부터 데이터 변경을 외부 프로세스가 읽을 수 있다. 트리거 기반 복제에는 다른 복제 방식보다 많은 오버헤드가 있다. 

이 방식은 데이터베이스에 내장된 복제보다 버그나 제한상황이 많이 발생한다. 그럼에도 유연성 때문에 유용하다.

# 복제 지연 문제

---

복제는 노드 내결함성에만 필요한 것이 아니라 확장성(단일 장비에서 감당하지 못하는 요청을 처리)와 지연 시간(사용자에게 지리적으로 더 가까운 복제 서버를 위치)이 또 다른 이유다.

리더 기반 복제는 모든 쓰기가 단일 노드를 거쳐야하지만 읽기 전용 질의는 어떤 복제 서버에서도 가능하다. 대부분이 읽기 요청이고 쓰기가 아주 작은 비율로 구성된 작업부하(웹 상의 공통 패턴)라면 많은 팔로워를 만들어 팔로워 간 읽기 요청을 분산하는 옵션이 있다. 이 방식을 사용하면 리더의 부하를 없애고 복제 서버에서 읽기 요청을 처리할 수 있게 해준다.

- 읽기 확장(read-scaling) 아키텍처에서는 간단히 팔로워를 추가함으로써 읽기 전용 요청을 처리하는 용량을 늘릴 수 있다.
    - 실제로는 비동기식 복제에서만 동작한다.
    - 동기식으로 모든 팔로워에 복제를 시도한다면 단일 노드 장애나 네트워크 중단으로 전체 시스템의 쓰기가 불가능해진다.
    - 노드가 많아지면 다운될 가능성이 커져 완전한 동기식 설정은 불안정하다.
- 비동기 팔로워에서 데이터를 읽을 때 팔로워가 뒤처진다면 지난 정보를 볼 수도 있다.
    - 데이터베이스의 명백한 불일치다.
    - 하지만 이러한 불일치는 일시적이다.
    - 데이터베이스에 쓰기를 멈추고 잠시동안 기다리면 팔로워는 결국 따라잡고 리더와 일치한다. 이러한 효과를 **최종적 일관성**이라고 한다.
        - 최종적이란 용어는 모호하다. 리더에서 일어난 쓰기와 팔로워에서 반영 사이의 지연(복제 지연)은 실제로 눈에 띄지 않을 수 있지만 실제로 수 초에서 수 분으로 증가할수도 있다.

## 자신이 쓴 내용 읽기

비동기식 복제에는 사용자가 쓰기를 수행한 직후 데이터를 본다면 새로운 데이터는 아직 복제 서버에 반영되지 않을 수 있다. 이는 사용자 입장에서 데이터가 유실되는 것 같아 보여 상당히 불만족스러운 동작이다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/45eb30ac-62d3-4bdf-a16d-62af1cd64871)

- 이런 경우 쓰기 후 읽기 일관성(자신의 쓰기 읽기 일관성으로도 알려짐)이 필요하다.
- 사용자가 페이지를 재로딩했을 때 항상 자신이 제출한 모든 갱신을 볼 수 있음을 보장하며 다른 사용자에 대해서는 보장하지 않는다.
- 다른 사용자의 갱신은 일정 시간 이후까지 보이지 않을 수 있다.

**리더 기반 복제 시스템에서 쓰기 후 읽기 일관성을 구현하는 방법**

- 사용자가 수정한 내용을 읽을 때는 리더에서 읽는다. 그 밖에는 팔로워에서 읽는다.
    - 실제로 질의하지 않고 무엇이 수정됐는지 알 수 있는 방법이 필요하다.
        - 예를 들어 소셜 네트워크에서 사용자 프로필 정보는 보통 프로필 소유자만 편집할 수 있기 때문에 항상 사용자 소유의 프로필은 리더에서 읽고 다른 사용자의 프로필은 팔로워에서 읽는 규칙을 적용한다.
- 애플리케이션 내 대부분의 내용을 사용자가 편집할 가능성이 있다면 이 접근 방식은 대부분 리더에서 읽기 때문에 효율적이지 않다.
    - 리더에서 읽을지 말지를 결정하기 위해 다른 기준을 사용해야 한다.
        - 마지막 갱신 시간을 찾아서 마지막 갱신 후 1분 동안은 리더에서 모든 읽기를 수행한다. 혹은 팔로워에서 복제 지연을 모니터링해서 리더보다 1분 이상 늦은 모든 팔로워에 대한 질의를 금지할 수 있다.
- 클라이언트는 가장 최근 쓰기의 타임스탬프를 기억할 수 있다. 그러면 시스템은 사용자 읽기를 위한 복제 서버가 최소한 해당 타임스탬프까지 갱신을 반영할 수 있다.
    - 복제 서버가 아직 최신 내용이 아닌 경우 다른 복제 서버가 읽기를 처리하거나 복제 서버가 따라잡을 때까지 질의를 대기시킬 수 있다. 타임스탬프는 논리적 타임스탬프(로그 열 숫자처럼 쓰기의 순서를 지정함)거나 실제 시스템 시간(실제 시스템 시간인 경우 동기화가 중요)
- 복제 서버가 여러 데이터센터에 분산(사용자에게 지리적인 근접성이나 가용성을 위해)됐다면 복잡도가 증가한다.
    - 리더가 제공하는 모든 요청은 리더가 포함된 데이터센터로 라우팅돼야 한다.

단, 동일한 사용자가 여러 디바이스로 서비스 접근할 때 문제가 발생할 수 있다. 이 경우 디바이스 간(cross-device) 쓰기 후 일기 일관성이 제공돼야 한다.

- 사용자의 마지막 갱신 타임스탬프를 기억해야 하는 접근 방식은 어렵다. 한 디바이스에서 수행 중인 코드는 다른 디바이스에서 발생한 갱신을 알 수 없기 때문이다. 메타데이터는 중앙집중식으로 관리해야 한다.
- 복제 서버가 여러 데이터센터 간에 분산돼 있다면 다른 디바이스의 연결이 동일한 데이터센터로 라우팅된다는 보장이 없다.
    - 리더에서 읽어야 할 필요가 있는 접근법이라면 먼저 사용자 디바이스의 요청을 동일한 데이터센터로 라우팅 되어야 한다.

## 단조 읽기

비동기식 팔로워에서 읽을 때 발생할 수 있는 두 번재 이상 현상은 사용자가 **시간이 거꾸로 흐르는 현상**을 목격할 수 있다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/3d60a3b7-bc88-4799-a1b3-df0142f06615)

단조 읽기(monotonic read)는 이런 종류의 이상현상이 발생하지 않음을 보장한다.

- 강한 일관성보다는 덜한 보장이지만 최종적 읽관성보다는 더 강한 보장이다.
- 한 사용자가 여러 번에 걸쳐 여러 번 읽어도 시간이 되돌아가는 현상을 보지 않는다는 의미에서다.
- 이전에 새로운 데이터를 읽은 후에는 예전 데이터를 읽지 않는다.

**단조 읽기 방법**

- 사용자의 읽기가 항상 동일한 복제 서버에서 수행되게끔 하는 것.
    - 하지만 복제서버가 고장나면 다른 복제 서버로 라우팅해야 한다.

## 일관된 순서로 읽기

**인과성의 위반 우려**

- 인과성이 있는 데이터는 순서가 섞이면 안된다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/abca1e82-59e5-4292-8cd1-37e879d5c799)

- 이상 현상을 방지하기 위해 일관된 순서로 읽기(Consistent Prefix Read) 같은 또 다른 유형의 보장이 필요하다.
- 파티셔닝(샤딩)된 데이터베이스에서 발생하는 특징적인 문제다.
    - 데이터베이스가 항상 같은 순서로 쓰기를 적용한다면 읽기는 항상 일관된 순서를 보기 때문에 이러한 이상 현상을 일어나지 않는다.
    - 하지만 분산 데이터베이스에서 서로 다른 파티션은 독립적으로 동작하므로 쓰기의 전역 순서는 없다.
    - 즉, 사용자가 데이터베이스에서 읽을 때 예전 상태의 일부와 새로운 상태의 일부를 함께 볼 수 있다.
- 해결책
    - 서로 인과성이 있는 쓰기는 동일한 파티션에 기록되게끔 하는 방법이 있지만 효과적이진 않다.

## 복제 지연을 위한 해결책

최종적 일관성 시스템으로 작업할 대 복제 지연이 증가하면 어떻게 애플리케이션이 동작할까?

- 복제는 비동기적으로 동작하지만 동기식으로 동작하는 척을 해야한다.
- 올바른 작업 수행을 위해 데이터베이스를 신뢰할 수 있어야 한다. 이것이 트랜잭션이 있는 이유이다.
- 단일 노드 트랜잭션은 오랫동안 존재했지만 분산 데이터베이스로 전환하는 과정에서 많은 시스템이 트랜잭션을 포기했다.

# 다중 리더 복제

---

**리더 기반 복제에 주요한 단점**

- 리더가 하나만 존재하고 모든 쓰기는 해당 리더를 거쳐야 한다.
    - 따라서 리더에 장애가 나면 데이터베이스 쓰기는 불가능하다.

단점을 해결하기 위해 쓰기 허용 노드를 하나 이상으로 늘리며 쓰기 처리를 하는 각 노드는 데이터 변경을 다른 모든 노드에 전달해야한다. 이 방식을 다중 리더 설정이라 부른다. (마스터 마스터나 액티브/액티브 복제라고도 한다.

## 다중 리더 복제의 사용 사례

단일 데이터센터 내에 다중 리더 설정을 사용하는 설정은 이로 인해 추가된 복잡도에 비해 이점이 크지 않다. 몇가지 상황에서는 이 설정이 합리적일 수 있다.

### 다중 데이터센터 운영

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/cf68a6d8-169c-4b00-bf48-c02be0715113)

- 다중 리더 설정에서는 각 데이터센터마다 리더가 있을 수있다.
- 각 데이터 센터 내에는 보통의 리더 팔로워 복제를 사용하고 데이터센터 간에 각 데이터 센터의 리더가 다른 데이터센터의 리더에게 변경사항을 복제한다.

성능

- 단일 리더 설정에서 모든 쓰기는 인터넷을 통해 데이터센터로 이동해야 한다.

### 오프라인 작업을하는 클라이언트

### 협업 편집

### 쓰기 충돌 다루기

### 동기 대 비동기 충돌 감지

### 충돌 회피

### 일관된 상태 수렴

### 사용자 정의 충돌 해소 로직

## 쓰기 충돌 다루기

## 다중 리더 복제 토폴로지
