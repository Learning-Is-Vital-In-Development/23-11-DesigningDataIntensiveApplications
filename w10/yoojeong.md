## 파티셔닝

- 거대한 데이터셋을 서브셋으로 분리하여 관리하는 방법(aka 샤딩)
- 데이터 파티셔닝의 주된 이유는 **확장성**
  - 대용량 데이터셋을 여러 디스크에 분산시켜 질의 부하를 여러 프로세스로 분산시킬 수 있다
  - 각 노드에서 쿼리를 처리할 수 있으므로 질의 처리량을 늘릴 수 있다

<details>
<summary>파티셔닝 & 샤딩</summary>

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/699bebd3-a6f5-4b99-8467-334fd1bbf6b6)

- Partitioning    
  - 테이블에 데이터가 많아지면 인덱스(B-Tree)또한 커지게 되고 테이블에 읽기/쓰기가 있을 때 마다 인덱스에서 처리되는 시간도 늘어난다.
  - 이를 방지하기 위해 테이블을 적당한 크기로 쪼개는 작업을 수행한다.

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/1363dd86-bbb4-4af7-9a4f-d484c0c330a7)

- Sharding
  - 네트워크 요청에 대한 부하를 각각의 서버로 분산시키기 위해 사용된다.

</details>


### 파티셔닝과 복제

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/c2b68d30-ffcb-4c5d-9745-5b318ac5145f)

파티셔닝과 복제를 동시에 적용할 수 있다.

이 경우에는 복제의 모든 특성이 적용된다. 즉, 복제와 파티셔닝은 서로 연관이 없다.


### 키-값 데이터 파티셔닝

파티셔닝이 고르게 이뤄지지 않아 다른 파티션보다 데이터가 많거나 질의를 많이 받는 파티션이 있다면 쏠렸다(skewed)고 말하며 불균형하게 부하가 높은 파티션을 핫스팟(hot spot)이라고 한다.

#### 키 범위 기준 파티셔닝

- 백과사전처럼 각 파티션에 연속된 범위의 키를 할당해 파티셔닝

장점

- 데이터 분포가 균일하지 않을 수 있기 때문에 키 범위 크기가 반드시 동일할 필요는 없다.
  - ex. 1권(A-B)과 12권(T-Z)
  - 데이터를 고르게 분산시키기 위해서는 파티션 경계를 데이터에 맞춰 조정해야 한다. 
- 파티션 경계는 관리자가 수동으로 선택하거나 DB에서 자동으로 선택되게 할 수 있다. 
- 각 파티션 내에서는 키를 정렬된 순서로 저장할 수 있다. 
  - 범위 스캔이 용이해진다
  - 키를 연쇄된 색인으로 간주해 질의 하나로 관련 레코드 여러 개를 읽을 수 있다.


단점

- 특정한 접근 패턴이 핫스팟을 유발할 수 있다.
  - 타임스탬프가 키라면 하루동안 쓰기연산은 모두 동일한 파티션으로 전달된다.
  - 이 경우 해당 파티션만 과부하가 걸리고 나머지 파티션은 유휴상태로 대기하게 된다.


#### 키의 해시값 기준 파티셔닝 (Hash Base)

> redis consistent hashing, modular or hashing?

- 키에 적합한 해시 함수를 사용하여 각 파티션에 해시값 범위를 할당하고 해시값이 파티션 범위에 속하는 모든키를 그 파티션에 할당한다.
- 파티셔닝용 해시 함수는 암호적으로 강력할 필요가 없지만, 언어의 내장 해시 함수는 파티셔닝에는 적합하지 않을 수 있다.
  - 자바의 `Object.hashCode()`, 루비의 `Object#hash` 등은 같은 키를 넣어도 다른 프로세스에서 다른 해시값을 반환할 수 있다
  - [Java's hashCode is not safe for distributed systems](https://martin.kleppmann.com/2012/06/18/java-hashcode-unsafe-for-distributed-systems.html)
- 키를 파티션 사이에 균일하게 분산시키는 데 좋다.(일관성 해싱)
- 그러나 키가 모든 파티션에 흩어지기 때문에 범위 질의를 효율적으로 실행할 수 있다는 키범위 파티셔닝의 장점을 잃어버린다.

**Case. Cassandra**


- 카산드라에서 테이블을 선언할 때 여러 칼럼을 포함하는 ***복합 기본키***를 지정할 수 있다.
- 키의 첫 부분에만 해싱을 적용해 파티션 결정에 사용하고 남은 칼럼은 카산드라의 SS테이블에서 데이터를 정렬하는 연쇄된 색인으로 사용한다.
- 따라서 복합 키의 첫 번째 칼럼에 대해서는 값 범위로 검색하는 질의를 쓸 수 없지만 첫 번째 칼럼에 고정된 값을 지정하면 키의 다른 칼럼에 대해서는 범위 스캔을 효율적으로 실행할 수 있다.

### 파티셔닝과 보조 색인

- 보조 색인은 레코드를 유일하게 식별하는 용도가 아닌 특정 값이 발생한 항목을 검색하는 수단
  - 관계형 데이터베이스의 핵심요소이며 문서 데이터베이스에서도 흔하다.
  - 솔라나 ES 같은 검색 서버에게는 존재의 이유이다.
- 보조색인은 파티션에 깔끔하게 대응되지 않는 문제가 있다.
- 보조 색인이 있는 데이터베이스를 파티셔닝하는 데 널리 쓰이는 두 가지 방법
  - 문서 기반 파티셔닝
  - 용어 기반 파티셔닝
 

#### 문서 기준 보조 색인 파티셔닝(Partitioning Secondary Indexes by Document)

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/812b11f3-9701-4191-b759-3954334c4681)


- 보조 색인을 만들면 데이터베이스가 color:red 색인 항목에 해당하는 문서 ID를 매핑한다.
- 파티션별로 자신의 보조 색인을 유지하는 방식으로 각 파티션이 완전히 독립적으로 동작한다. (`지역 색인(local index)`)
- 모든 파티션으로 질의를 보내서 얻은 결과를 모두 모아야 한다. (`스캐터/개더(scatter/gather)`)
  - 보조 색인을 써서 읽는 질의는 큰 비용(꼬리 지연 시간 증폭(tail latency amplification))이 들 수 있다.
- 데이터베이스 벤더들은 대부분 보조 색인 질의가 단일 파티션에서만 실행되도록 파티셔닝 방식을 설계하기를 권장하지만 (단일 질의에서 여러 보조 색인을 사용할 때 등) 항상 가능하지는 않다.

#### 용어 기준 보조 색인 파티셔닝(Partitioning Secondary Indexes by Term)

![image](https://github.com/rachel5004/23-11-DesigningDataIntensiveApplications/assets/75432228/6ee64d9c-7de7-4d55-959b-1cf00c15c440)

- 각 파티션이 모든 파티션의 데이터를 담당하는 전역 색인(global index)을 공유한다.
  - 이 때는 전역 색인도 파티셔닝하여 한 노드에 병목이 되지 않게 한다.
- 모든 파티션의 빨간색 자동차 정보는 색인에서 color: red 항목에 저장되지만 color 색인이 a~r까지의 글자로 시작하는 색깔은 파티션 0에, s부터 z까지의 color는 파티션1에 저장된다.
- 찾고자하는 용어에 따라 색인의 파티션이 결정되므로 이런 식의 색인을 용어 기준으로 파티셔닝됐다(term-partitioned)고 한다.
  - 용어(term)는 전문 색인(full-text indexes)에서 나왔는데, 문서에 등장하는 모든 단어를 말한다.
- 색인을 파티셔닝할 때 용어 자체를 쓸 수도 있고 용어의 해시값을 사용할 수도 있다.
  - 용어 자체를 쓰면 범위 스캔에 유리한 반면 해시값을 사용하면 부하가 좀 더 고르게 분산된다.
- 장점 : 문서 기준 보조 색인 파티셔닝보다 읽기가 효율적이다.
  - Index는 범위별로 나눠져서 각 파티션마다 고유하기 때문에 모든 파티션에 “스캐터/개더”를 실행할 필요가 없이 원하는 용어를 포함하는 파티션으로만 요청을 보내면 된다.
- 단점 : 단일 문서를 쓸 때 해당 색인의 여러 파티션에 영향을 줄 수 있기 때문에 쓰기가 느리고 복잡하다.
- 전역 보조 색인은 대개 비동기로 갱신되기 떄문에 색인 반영이 뒤쳐질 수 있다.

### 파티션 재균형화


시간이 지나면 데이터베이스에 변화가 생긴다.

- 질의 처리량 증가해서 늘어난 부하를 처리하기 위해 CPU 추가해야 한다.
- 데이터셋 크기가 증가해서 데이터셋 저장에 사용할 디스크와 램을 추가해야 한다.
- 장비에 장애가 발생해서 그 장비가 담당하던 역할을 다른 장비가 넘겨받아야한다.

이런 변화가 생기면 데이터와 요청이 한 노드에서 다른 노드로 옮겨져야 한다. 클러스터에서 한 노드가 담당하던 부하를 다른 노드로 옮기는 과정을 재균형화(rebalancing)라고 한다. 파티션을 노드에 할당하는 방법을 파티션 재균형화라고 한다.

어떤 파티셔닝을 쓰는지에 무관하게 재균형화가 실행될 때 보통 만족시킬것으로 기대되는 최소 요구사항이 있다.

- 재균형화 후, 부하(데이터 저장소, 읽기 쓰기 요청)가 클러스터 내에 있는 노드들 사이에 균등하게 분배돼야 한다.
- 재균형화 도중에도 데이터베이스는 읽기 쓰기 요청을 받아들여야 한다.
- 재균형화가 빨리 실행되고 네트워크와 디스크 I/O 부하를 최소화할 수 있도록 노드들 사이에 데이터가 필요 이상으로 옮겨져서는 안된다.

