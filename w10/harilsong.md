# Ch6 파티셔닝

데이터셋이 매우 크거나 질의 처리량이 매우 많다면 복제만으로는 부족하고 데이터를 파티션으로 쪼갤 필요가 있다. 이를 샤딩이라고도 한다.

데이터 파티셔닝을 원하는 주된 이유는 **확장성**이다. 비공유 클러스터(shared-nothing cluster)에서 다른 파티션은 다른 노드에 저장될 수 있다. 따라서 대용량 데이터셋이 여러 디스크에 분산될 수 있고 질의 부하는 여러 프로세서에 분산될 수 있다.

각 노드에서 자신의 파티션에 해당하는 질의를 독립적으로 실행할 수 있으므로 노드를 추가함으로써 질의 처리량을 늘릴 수 있다.
크고 복잡한 질의는 훨씬 더 어렵기는 하지만 여러 노드에서 병렬 실행이 가능하다.

## 파티셔닝과 복제

보통 복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장한다. 각 레코드는 정확히 한 파티션에 속하더라도 이를 여러 다른 노드에 저장해서 내결함성을 보장할 수 있다는 의미다.

한 노드에 여러 파티션을 저장할 수도 있다. 리더 팔로워 복제 모델을 사용한다면 각 파티션의 리더는 하나의 노드에 할당되고 팔로워들을은 다른 노드에 할당된다. 각 노드는 어떤 파티션에게는 리더이면서 다른 파티션에게는 팔로워가 될 수 있다.

## 키-값 데이터 파티셔닝

대량의 데이터를 파티셔닝한다고 생각해보자. 어떤 레코드를 어느 노드에 저장할지 어떻게 결정해야 할까?

파티셔닝의 목적은 데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것이다. 모든 노드가 동일한 분량을 담당한다고 가정할 때 10대의 노드를 사용하면 한대를 사용할 때보다 이론상으로 10배의 데이터를 저장하고 10배의 읽기, 쓰기 요청을 처리할 수 있다.

파티셔닝이 고르게 이뤄지지 않아 다른 파티션보다 데이터가 많거나 질의를 많이 받는 파티션이 있다면 쏠렸다(skewed)고 말하며, 파티셔닝의 효과가 매우 떨어진다. 극단적인 경우 모든 부하가 한 파티션에 몰려 10개 중 9개 노드는 유휴 상태에 있고 요청을 받는 노드 하나가 병목이 될 수 있다. 불균형하게 부하가 높은 파티션을 **핫스팟**이라고 한다.

핫스팟을 회피하는 가장 단순한 방법은 레코드를 할당할 노드를 무작위로 선택하는 것이다. 그러면 데이터가 노드들 사이에 매우 고르게 분산되지만 커다란 단점이 있는데, 어떤 레코드를 읽으려고 할 때 해당 레코드가 어느 노드에 저장됐는지 알 수 없으므로 모든 노드에서 병렬적으로 질의를 실행해야 한다.

이 문제를 회피하기 위해 단순한 키-값 데이터 모델을 사용해볼 수 있다. 이 모델에서는 항상 기본키를 통해 레코드에 접근한다. 이를테면 종이 백과사전에서는 항목을 찾을 때 제목을 사용한다. 모든 항목이 알파벳 순으로 정렬돼 있으므로 언제나 찾고자 하는 항목을 빠르게 찾을 수 있다.

### 키 범위 기준 파티셔닝

파티셔닝 하는 방법 중 하나는 종이 백과사전처럼 각 파티션에 연속된 범위(어떤 최솟값에서 최댓값까지)의 키를 할당하는 것이다. 각 범위들 사이의 경계를 알면 어떤 키가 어느 파티션에 속하는지 쉽게 찾을 수 있다. 또 어떤 파티션이 어느 노드에 할당됐는지 알면 적절한 노드로 요청을 직접 보낼 수 있다.

데이터가 고르게 분포하지 않을 수도 있기 때문에 키 범위 크기가 반드시 동일할 필요는 없다. 영단어는 x 나 z 로 시작하는 단어보다 다른 알파벳으로 시작하는 단어가 훨씬 많다. 알파벳으로 범위를 할당하면 다른 것들보다 훨씬 커지는 파티션이 생긴다. 데이터를 고르게 분산시키려면 파티션 경계를 데이터에 맞춰 조정해야 한다.

각 파티션 내에서는 트리를 사용하여 키를 정렬된 순서로 저장할 수 있다. 이렇게 하면 범위 스캔이 쉬워지고 키를 연쇄된 색인으로 간주해서 질의 하나로 관련 레코드 여러 개를 읽어오는 데 사용할 수 있다.

그러나 키 범위 기준 파티셔닝은 특정한 접근 패턴이 핫스팟을 유발하는 단점이 있다. 예를 들어 타임스탬프를 키로 사용한다면 1일치의 쓰기 연산은 모두 동일한 파티션으로 전달되어 해당 파티션에만 과부하가 걸리고 나머지 파티션은 유휴 상태로 남아 있을 수 있다.

이 문제를 회피하려면 키의 첫 번째 요소로 타임스탬프가 아닌 다른 것을 사용해야 한다. 이를테면 타임스탬프 앞에 이름을 붙여서 파티셔닝할 때 이름을 먼저 사용한 후 시간을 사용하게 할 수 있다. 동시에 동작하는 센서가 많이 있다면 쓰기 부하가 파티션 사이에 더 균등하게 퍼진다. 이제 하나의 시간 범위 내에서 여러 센서의 값을 얻고 싶다면 센서 이름마다 별개의 범위 질의를 실행해야 한다.

### 키의 해시값 기준 파티셔닝

쏠림과 핫스팟의 위험 때문에 많은 분산 데이터스토어는 키의 파티션을 정하는 데 해시 함수를 사용한다.

좋은 해시 함수는 쏠린 데이터를 입력으로 받아 균일하게 분산되게 한다. 입력 문자열이 거의 유사해도 해시값은 숫자 범위 내에서 균일하게 분산된다.

파티셔닝용 해시 함수는 암호적으로 강력할 필요는 없다. 예를 들어 카산드라와 몽고DB 는 MD5 를 쓰고 볼드모트는 파울러 놀 보(Fowler-Noll-Vo) 함수를 사용한다. 많은 프로그래밍 언어에 간단한 해시 함수가 내장돼 있지만(해시 테이블에 사용되므로) 파티셔닝에는 적합하지 않을 수 있다. 예를 드어 자바의 `Object.hashCode()` 와 루비의 `Object#hash` 는 같은 키를 넣어도 다른 프로세스에서는 다른 해시값을 반환할 수 있다.

키에 적합한 해시 함수를 구했다면 각 파티션에 키 범위 대신 해시값 범위를 할당하고 해시값이 파티션의 범위에 속하는 모든 키를 그 파티션에 할당하면 된다. 이 기법은 키를 파티션 사이에 균일하게 분산시키는 데 좋다. 파티션 경계는 크기가 동일하도록 나눌 수도 있고 무작위에 가깝게 선택할 수도 있다.

그러나 유감스럽게도 파티셔닝에 키의 해시값을 사용해서 파티셔닝하면 키 범위 파티셔닝이 가진 범위 질의를 효율적으로 실행할 수 있는 능력을 잃어 버린다. 전에는 인접했던 키들이 이제는 모든 파티션에 흩어져서 정렬 순서가 유지되지 않는다.

카산드라는 두 가지 파티셔닝 전략 사이에서 타협한다. 카산드라에서 테이블을 선언할 때 여러 칼럼을 포함하는 복합 기본키를 지정할 수 있다. 키의 첫 부분에만 해싱을 적용해 파티션 결정에 사용하고 남은 칼럼은 카산드라의 SS테이블에서 데이터를 정렬하는 연쇄된 색인(clustering index)으로 사용한다. 따라서 복합 키의 첫 번째 컬럼에 대해서는 값 범위로 검색하는 질의를 쓸 수 없지만 첫 번째 컬럼에 고정된 값을 지정하면 키의 다른 컬럼에 대해서는 범위 스캔을 효율적으로 실행할 수 있다.

### 쏠린 작업부하와 핫스팟 완화

키를 해싱해서 파티션을 정하면 핫스팟을 줄이는 데 도움이 되지만 완벽히 제거할 수는 없다. 동일한 키를 읽고 쓰는 극단적인 상황에서는 모든 요청이 동일한 파티션으로 쏠리게 된다. 예를 들면 소셜 미디어 사이트에서 수백만 명의 팔로워를 거느린 유명인이 실행한 작업 때문에 동일한 키에 막대한 양의 데이터를 기록해야 할 수도 있다.

요청이 매우 많이 쏠리는 키를 발견했을 때 간단한 해결책은 각 키의 시작이나 끝에 임의의 숫자를 붙이는 것이다. 임의의 10진수 두 개만 붙이더라도 한 키에 대한 쓰기 작업이 100개의 다른 키로 균등하게 분산되고 그 키들은 다른 파티션으로 분산될 수 있다.

다른 키에 쪼개서 쓰면 읽기를 실행할 때 추가적인 작업이 필요해진다. 100개의 키에 해당하는 데이터를 읽어서 조합해야 하기 때문이다. 이 기법은 요청이 몰리는 소수의 키에만 적용하는게 타당하다. 따라서 어떤 키가 쪼개졌는지 추적할 방법도 있어야 한다. 트레이드오프를 꼼꼼히 따져볼 필요가 있다.

## 파티셔닝과 보조 색인(Secondary Indexes)

레코드를 기본키를 통해서만 접근한다면 키로부터 파티션을 결정하고 이를 사용해 해당 키를 담당하는 파티션으로 읽기 쓰기 요청을 전달할 수 있다.

보조 색인(Secondary Index)이 연관되면 상황이 복잡해진다. 보조 색인은 보통 레코드를 유일하게 식별하는 용도가 아니라 특정한 값이 발생한 항목을 검색하는 수단이다.

보조 색인은 관계형 데이터베이스의 핵심 요소이며 문서 데이터베이스에서도 흔하다. 데이터 모델링에 매우 유용하기 때문이며 엘라스틱서치 같은 검색 서버에게는 존재의 이유다.

보조 색인은 파티션에 깔끔하게 대응되지 않은 문제점이 있다.

### 문서 기준 보조 색인 파티셔닝

문서 기준으로 보조 색인을 생성하면 각 파티션이 완전히 독립적으로 동작한다. 각 파티션은 자신의 보조 색인을 유지하며 그 파티션에 속하는 문서만 담당한다. 다른 파티션에 어떤 데이터가 저장되는지는 신경 쓰지 않는다. 데이터베이스에 문서 추가, 삭제, 갱신 등의 쓰기 작업을 실행할 때는 쓰려고 하는 문서 ID 를 포함하는 파티션만 다루면 된다. 그러한 까닭에 문서 파티셔닝 색인은 지역 색인(local index)이라고도 한다.

그러나 문서 기준으로 파티셔닝된 색인을 써서 읽을 때는 특정한 조건의 데이터가 동일한 파티션에 저장되어있다는 보장이 없으므로 특정 조건의 데이터를 찾고 싶다면 **모든** 파티션으로 질의를 보내서 얻은 결과를 모두 모아야 한다.

파티셔닝된 데이터베이스에서 이런 식으로 질의를 보내는 방법을 **스캐터/개더(scatter/gather)** 라고도 하는데 보조 색인을 써서 읽는 질의는 큰 비용이 들 수 있다. 여러 파티션에서 질의를 병렬 실행하더라도 스캐터/개더는 꼬리 지연 시간 증폭이 발생하기 쉽다. 그럼에도 보조 색인을 문서 기준으로 파티셔닝하는 경우가 많다. 몽고DB, 리악, 카산드라, 엘라스틱서치, 솔라클라우드, 볼트DB 는 모두 문서 기준으로 파티셔닝된 보조 색인을 사용한다. 여러 데이터베이스 벤더들은 대부분 보조 색인 질의가 단일 파티션에서만 실행되도록 파티셔닝 방식을 설계하기를 권장하지만, 단일 질의에서 여러 보조 색인을 사용할 때가 있는 것처럼 항상 가능하지는 않다.

### 용어 기준 보조 색인 파티셔닝

## 파티션 재균형화

### 재균형화 전략

### 운영: 자동 재균형화와 수동 재균형화

## 요청 라우팅

### 병렬 질의 실행
