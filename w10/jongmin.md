
# 6.  파티셔닝


**데이터셋이 매우 크거나 질의 처리량이 매우 많다면** 복제만으로는 부족하고 **데이터를 파티션으로 쪼갤 필요가 있음** (샤딩)


파티셔닝의 목적: **핫스팟(불균형적으로 높은 부하를 받는 노드)이 생기지 않게** 하면서 **데이터와 질의 부하**를 여러 장비에 **균일하게 분배**하는 것
- 데이터 적합한 파티셔닝 방식을 선택
- 클러스터에 노드가 추가 / 삭제 될 때 파티션 재균형화 진행 (데이터양이 증가/ 감소 했을 때도 재균형화)

파티셔닝 방식
- 키 범위 파티셔닝
	- 키가 정렬돼 있고 개별 파티션은 특정 범위의 값에 속하는 모든 키를 담당
	- 장점: 키가 정렬돼 있어 범위 질의가 효율적임
	- 단점: 특정 범위 데이터에만 자주 접근하여 핫스팟이 생길 위험이 있음 (ex. 이름을 ㄱ~ㅎ으로 파티셔닝했을 때 ㄱ 파티션에 ㅎ 파티션보다 접근이 많을 수 있음)
	- 재균형화: 한 파티션이 너무 커지면 키 범위를 두 개로 쪼개 동적으로 재균형화를 실행 (ex. ㄱ 파티션쪼개기)
- 해시 파티셔닝
	- 각 키에 해시함수를 적용하고 개별 파티션은 특정 범위의 해시값을 담당함
	- 장점: 부하를 균일하게 분산할 수 있음
	- 단점: 키 순서가 보장되지 않아 범위 질의가 제한적인
	- 재균형화: 고정된 개수의 파티션을 미리 만들어 각 노드에 몇 개씩의 파티션을 할당하며 노드가 추가되거나 제거되면 파티션을 통째로 노드 사이에서 이동

키의 일부분은 파티션 식별용으로 나머지 부분은 정렬 순서용으로 만든 복합키 사용
(DynamoDB: Partition Key, Sort Key ?)

파티셔닝과 보조 색인 사이의 상호작용: 보조 색인도 파티셔닝이 필요한데 두가지 방법이 있음
- 문서 파티셔닝 색인(지역 색인)
	- 보조 색인을 기본키와 값이 저장된 파티션에 저장함
	- **문서를 쓸 때는 파티션 하나만 갱신**하면 되지만 보조 **색인을 읽으려면 모든 파티션에 요청**해야함 (스캐더/개더))
- 용어 파티셔닝 색인(전역 색인)
	- 색인된 값을 사용해서 보조 색인을 별도로 파티셔닝함 (a~r: 1번파티션, s ~: 2번 파티션)
	- 보조 색인 항목은 기본키의 모든 파티션에 있는 레코드를 포함할 수도 있음
	- **문서를 쓸 때는 여러 개를 갱신**해야 하지만 **읽기는 단일 파티션에서 실행**될 수 있음

요청 라우팅: 서비스 찾기의 일종
- 클라이언트에서 요청을 보내려고 할 때 어느 노드로 접속해야 하는지 어떻게 알 수 있을까?

1. 클라이언트가 아무 노드에나 접속한 후 해당 노드에 데이터가 있으면 그대로 리턴, 없다면 데이터가 있는 노드를 찾아서 데이터를 가져온 후 클라이언트에게 리턴
2. 클라이언트의 모든 요청을 라우팅 계층으로 보냄
3. 클라이언트가 파티셔닝 방법과 파티션이 어떤 노드에 할당됐는지를 알고 있게함 (중개자가 필요없음)


## 6.1.  파티셔닝과 복제

## 6.2.  키-값 데이터 파티셔닝

### 6.2.1.  키 범위 기준 파티셔닝
### 6.2.2.  키의 해시값 기준 파티셔닝
### 6.2.3. 쏠린 작업부하와 핫스팟 완화
- 소셜 미디어 사이트에서 수백만명의 팔로워를 거느린 유명인이 뭔가를 하면 후폭풍이 발생할 수 있음
- 현대 데이터 시스템은 대부분 크게 쏠린 작업부하를 자동으로 보정하지 못함
	- 따라서 애플리케이션 레벨에서 쏠림을 완화해야함
	- ex. 요청이 매우 많이 쏠리는 키의 시작이나 끝에 임의의 숫자를 붙여 분산되도록 하기

## 6.3. 파티셔닝과 보조 색인

### 6.3.1. 문서 기준 보조 색인 파티셔닝
### 6.3.2. 용어 기준 보조 색인 파티셔닝


## 6.4. 파티션 재균형화

### 6.4.1. 재균형화 전략

### 6.4.2. 운영: 자동 재균형화와 수동 재균형화
- 재균형화는 많은 비용이 들기에 시스템에서 재균형화를 추천하지만 최종 재균형화는 관리자 확인 후 수동으로 하도록 하는게 좋을 수도 있음


## 6.5. 요청 라우팅

### 6.5.1. 병렬 질의 실행


## 6.6. 정리