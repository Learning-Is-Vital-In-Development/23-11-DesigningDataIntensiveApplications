# 06 파티셔닝

- 데이터셋이 매우 크거나 처리량이 매우 높다면 복제뿐만이 아니라 데이터를 파티션으로 쪼갤 필요가 있다. 이를 샤딩이라고 한다.
    - 용어혼동
        - 몽고DB, 엘라스틱서치, 솔라클라우드 - 샤드(shard)
        - HBase - 리전(region)
        - 빅테이블 - 태블릿(tablet)
        - 카산드라, 리악 - 브이노드(vnode)
        - 카우치베이스 - 브이버켓(vBucket)
- 파티션을 나눌 때는 보통 데이터 단위(레코드, 로우, 문서)가 하나의 파티션에 속하게 된다.
    - 각 파티션은 그 자체로 작은 데이터베이스가 된다.
- 파니셔닝의 주된 이유는 **확장성**이다. 비공유 클러스터(shared-nothing cluster)에서 다른 파티션은 다른 노드에 저장될 수 있다(비공유(shared nothing)는 2부에서..)
    - 여러 디스크에 분산되고 질의 부하를 여러 프로세스에서 분산시킬 수 있다.

# 파티셔닝과 복제

- 보통 복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장한다. 각 레코드는 한 파티션에 속하더라도 다른 노드에 저장해서 내결함성을 보장할 수 있다.
- 한 노드에 여러 파티션을 저장할 수 있다.
- 각 파티션의 리더는 하나의 노드에 할당되고 팔로워들은 다른 노드에 할당된다. 각 노드는 어떤 파티션에게는 리더이면서 다른 파티션에게는 팔로워가 될 수 있다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/fd21bc77-795c-4933-9eca-4ececca5161c)
각 노드는 어떤 파티션에게는 리더로 어떤 파티션에게는 팔로워로 동작한다.

# 키-값 데이터 파티셔닝

- 파티셔닝의 목적: 데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것
    - 모든 노드가 동일한 분량을 담당한다고 가정할 때 10대의 노드를 사용하면 한 대를 사용할 때보다 이론상으로 10배의 데이터를 저장, 질의를 처리 가능
- 하지만 파티셔닝이 고르게 이뤄지지 않으면 **쏠렸다(skewed)**라고 한다. 극단적인 경우 모든 부하가 한 파티션에 몰릴 수 있는데 병목이 될 수 있다. 이렇게 불균형하게 부하가 높은 파티션을 **핫스팟**이라고 한다.
- 핫스팟을 회피하는 방법
    - 가장 단순한 방법은 무작위다. 하지만 이는 어떤 레코드를 읽으려고 할 때 어느 노드에 저장됐는지 알 수 없어서 모든 노드에 병렬적으로 질의해야 한다.
    - 키-값 데이터 모델은 기본키를 통해 레코드를 접근하기 때문에 이를 정렬하면 빠르게 찾을 수 있다.

## 키 범위 기준 파티셔닝

파티션하는 방법

- 각 파티션에 연속된 범위(어떤 최솟값에서 최대값까지)의 키를 할당하는 것
    - 각 범위들 사이의 경계를 알면 어떤 키가 어느 파티션에 속하는지 쉽게 찾을 수 있다.
    - 어떤 파티션이 어떤 노드에 할당됐는지 알면 적절한 노드로 요청을 직접 보낼 수 있다.
- 키 범위는 동일할 필요가 없다. 데이터가 고르게 분포될 필요가 없기 때문이다.
    - ex)
- 데이터를 고르게 분산시키려면 파티션 경계를 데이터에 맞춰 조정해야 한다.
    - 개발자가 수동으로 선택하거나 DB가 자동으로 선택하게 할 수 있다.
    - 빅테이블, HBase, 리싱크DB, 몽고DB 버전 2.4 이전
- 각 파티션 내에서는 키를 정렬된 순서로 저장 가능. 범위 스캔이 쉬워지며 키를 연쇄된 색인으로 간주해서 질의 하나로 관련 레코드 여러개를 읽어오는데 사용 가능
    - 타임스탬프를 키로 사용할 경우 범위 스캔이 유용하다.
- 키 범위 기준 파티셔닝은 특정 접근 패턴이 핫스팟을 유발하기도 한다.
    - 쓰기 연산이 배치처럼 한 번에 동작할 때. 데이터가 몰리는 경우가 있다.
    - 키의 요소로 타임스탬프가 아닌거를 사용하면 된다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/f08963c2-8f43-4c65-8970-9af1eb92e3a1)

## 키의 해시값 기준 파티셔닝

- 쏠림과 핫스팟의 위험을 해결하기 위해 키의 파티션을 정하는 데 해시 함수를 쓴다.
- 좋은 해시 함수는 쏠린 데이터를 균일하게 분산되게 한다.
    - 파티셔닝 해시함수는 암호적으로 강력할 필요가 없다.
        - 카산드라, 몽고 DB - MD5
        - 볼드모트 - 파울러 놀 보(Folwer-Noll-Vo) 함수 사용
    - 하지만 다른 프로세스에서 다른 해시값을 반환하는 가능성은 제한해야한다.
- 키에 적합한 해시함수를 구하면 각 파티션에 해시값 범위를 할당하고 해시값이 파티션의 범위에 속하는 모든 키를 파티션에 할당하면 된다.


![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/bdd5bc61-c5a6-42f2-9dff-48cc443ed6ee)

- 키를 파티션 사이에 균일하게 분산하는 게 좋다.
- 파티션 경계는 크기가 동일하도록 나눌 수 있고 무작위에 가깝게 선택할 수 있다.
    
    **일관성 해싱**
    
    > 카저(Karger)가 정의한 대로 CDN(content delivery network) 같은 인터넷 규모의 캐시 시스템에서 부하를 균등하게 분산시키는 방법. 중앙 제어나 분산 합의(ditributed consensus)가 필요하지 않도록 파티션 경계를 무작위로 선택한다. 다만 복제 일관성이나 ACID 일관성과는 관련이 없으며 특별한 재균형화 방법을 의미한다. 혼동하기 쉬우므로 그냥 **해시 파티셔닝**을 쓰는 게 좋다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/cdca12dc-d85b-4b92-b776-06c4576742a7)

- 하지만 해시값을 사용하면 키 범위 파티셔닝의 장점인 범위 질의를 효율적으로 실행할 수 없다.
- 전에 인접했던 키를 활성화하면 범위 질의가 모든 파티션에 전송돼야 한다. 몽고DB에서 해시 기반 샤딩 모드를 활성화하면 범위 질의가 모든 파티션에 전송되어야 한다. 리악, 카우치베이스, 볼드모트에서는 기본키에 대한 범위 질의가 지원되지 않는다.

## 쏠린 작업부하와 핫프사 완화

- 해싱해서 파티션을 정하면 핫스팟을 줄일 수 있지만 항상 동일한 키를 읽고 쓰는 극단적인 상황에서 모든 요청이 동일한 파티션에 쏠리게 된다.
- 유명인 문제
    - SNS에서 수백만명의 팔로워를 거느린 유명인이 어떤 작업을 하면 후폭풍이 발생할 수 있다. 해당 키에 막대한 양의 데이터를 기록해야 할 수도 있다.
    - 동일한 ID의 해시값은 해싱으로 부하를 해결하지 못한다.
- 현대 데이터 시스템은 크게 쏠린 작업부하를 자동으로 보정하지 못하므로 애플리케이션에서 쏠림을 완화해야 한다.
    - 예를 들어 요청이 많은 키를 발견했을 때 각 키의 시작이나 끝에 임의의 숫자를 붙인다. 그렇다면 한 키에 대한 쓰기 작업이 100개의 다른 키로 균등하게 분산된다.
        - 하짐나 다른 키에 쪼개서 쓰면 읽기를 실행할 때 추가적인 작업이 필요해진다. 키에 해당하는 데이터를 각각 읽어서 조합해야하기 때문이다. 또한 쓰기 오버헤드가 발생할 수도 있다. 따라서 어떤 키가 쪼개졌는지 추적할 방법도 있어야 한다.

# 파티셔닝과 보조 색인

- 앞서 이야기한 내용들은 키-값 데이터 모델 이야기다.
- 인덱스가 들어가면 상황이 복잡해진다. 인덱스는 보통 특정한 값이 발생한 항목을 검색하는 수단이다.
- 인덱스는 RDB의 핵심이며 문서형 데이터베이스에서도 흔하다. 또한 엘라스틱서치나 솔라 같은 검색 서버에는 존재의 이유 그 자체다.

인덱스가 있는 데이터베이스를 파니셔닝하는 방법은 **문서 기반 파티셔닝**과 **용어 기반 파티셔닝**이다.

## 문서 기준 보조 색인 파티셔닝

문서 ID(document ID)라는 고유 ID가 있고 데이터베이스를 문서 ID 기준으로 파티셔닝한다고 했을 때, 인덱스를 만들기 위해서는 데이터베이스가 자동으로 색인을 생성할 수 있어야 한다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/8554f595-674a-4558-a716-fa775d3c40a7)

- 인덱스는 각 파티션이 완전히 독립적으로 동작한다. 각 파티션은 자신의 인덱스만 유지하며 그 파티션에 속하는 문서만 담당한다.
- 데이터베이스에 문서 추가, 삭제, 갱신 등의 쓰기 작업을 실행할 때 쓰려고 하는 문서 ID를 포함하는 파티션만 다루면 된다.
    - 문서 파티셔닝 색인은 전역 색인(global index)와 반대로 지역 색인(local index)라고도 한다.
    - 하지만 파티셔닝 된 데이터베이스의 질의를 할 때는 모든 파티션에 보내야 원하는 결과를 얻을 수 있다.
        - 이 방식을 스캐터/개더(scatter/gather)라고 한다.
        - 꼬리 지연 시간 증폭이 발생할 수 있지만 몽고DB, 리악, 카산드라, 엘라스틱 서치, 솔라클라우드, 볼트DB는 모두 문서 기준으로 파티셔닝된 인덱스를 사용한다.
        - 인덱스 질의가 단일 파티션에서만 실행되도록 파티셔닝 방식을 설계를 원하지만 항상 가능하지가 않다.

## 용어 기준 보조 색인 파티셔닝

- 각 파티션이 자신만의 지역 색인을 갖게 하는 대신 모든 파티션의 데이터를 담당하는 전역 색인을 만들 수도 있다. 한 노드에만 색인을 저장하면 해당 노드가 병목이 되어 파티셔닝의 목적을 해칠 수 있다. 전역 색인도 파티셔닝 해야지만 기본키 색인과는 다른 식으로 할 수 있다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/e4b3ea51-7cca-43c1-84c0-8da220c52ff6)

- 이미지를 보면 a-r까지 파티션0에 s-z까지는 파티션1에 저장을 한다.
- 찾고자 하는 용어에 따라 색인의 파티션이 결정되므로 이런 식의 색인을 용어 기준으로 파티셔닝됐다(term-partitioned)고 한다. 용어라는 이름은 전문 색인에서 나왔으며 문서에 등장하는 모든 단어를 뜻한다.
- 색인을 파티셔닝할 때 용어 자체를 쓸 수도 있고 용어의 해시값을 사용할 수도 있다. 용어 자체로 파티셔닝하면 범위 스캔에 유용하면 반면 용어의 해시값을 사용해 파티셔닝 하면 부하가 좀 더 고르게 분산된다.
- 문서 파티셔닝 색인에 비해 전역(용어 파티셔닝) 색인이 갖는 이점은 읽기가 효율적이다.
    - 스캐터/개더를 실행할 필요 없이 원하는 용어를 포함하는 파티션으로만 요청을 보내면 된다. 대신 쓰기가 느리고 복잡하다.
        - 단일 문서를 쓸 대 색인의 여러 파티션에 영향을 줄 수 있기 때문이다.
- 실제로 전역 보조 색인은 대개 비동기로 갱신된다.
    - 사용처로는 오라클 데이터 웨어하우스, 리악의 검색 기능 등에서 사용한다.

# 파티션 재균형화

시간이 지나면 데이터베이스에 변화를 생긴다.

- 질의 처리량이 증가해서 늘어난 부하를 처리하기 위해 CPU를 더 추가하고 싶다.
- 데이터셋 크기가 증가해서 데이터셋 저장에 사용할 디스크와 램을 추가하고 싶다.
- 장비에 장애가 발생해서 그 장비가 담당하던 역할은 다른 장비가 넘겨받아야 한다.

이러한 변화가 생기면 데이터와 요청이 한 노드에서 다른 노드로 옮겨져야 한다. 클러스터에서 한 노드가 담당하던 부하를 다른 노드로 옮기는 과정을 재균형화(rebalancing)라고 한다.

- 재균형화 후. 부하(데이터 저장소, 읽기 쓰기 요청)가 클러스터 내에 있는 노드들 사이에 균등하게 분배돼야 한다.
- 재균형화 도중에도 데이터베이스는 읽기 쓰기 요청을 받아들여야 한다.
- 재균형화가 빨리 실행되고 네트워크와 디스크 I/O 부하를 최소화할 수 있도록 노드들 사이에 데이터가 필요 이상으로 옮겨 져서는 안된다.

## 재균형화 전략

### 쓰면 안 되는 방법: 해시값에 모드 N 연산을 실행

- 키의 해시값 기준으로 파티셔닝할 때 사용 가능한 해시값 범위를 나누고 각 범위를 한 파티션에 할당하는 게 선이라 했다.
- 하지만 모듈러 연산은 쓰지 않는다. 하지만 노드의 개수가 늘어나면 키가 자주 이동해야 한다. 키가 자주 이동하면 재균형화 비용이 지나치게 커진다.

### 파티션 개수 고정

- 파티션을 노드 대수보다 많이 만들고 각 노드에 여러 파티션을 할당하면 된다. 노드가 10대로 구성된 클러스터에서 처음부터 파티션을 1,000개로 쪼개서 각 노드마다 약 100개의 파티션을 할당할 수 있다.
- 클러스터에 노드가 추가되면 새 노드는 파티션이 다시 균일하게 분배될 때 가지 기존 노드에서 파티션 몇 개를 뺏어올 수 있다. 클러스터에서 노드가 제거되면 이 과정이 반대로 실행된다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/5076d0df-8847-4b3c-bc22-c71df8e196eb)

- 장단점
    - 장점 : 파티션 통째로 이동. 바뀌는점은 “어느 노드에 어느 파티션이 할당되었나” 뿐
    - 단점 : 파티션 수는 고정인데 데이터셋 크기 변동이 심할 경우 => 적절한 파티션 수 지정 어려움
        - 대부분 처음 설정된 파티션 수 = 사용 가능한 노드 대수의 최대치
        - 파티션이 너무 작으면 오버헤드↑, 너무 크면 재균형화와 노드 장애 시 복구 비용↑

### 동적 파티셔닝

- 파티션 개수가 고정되면 문제가 생기는 경우 (ex. 키 범위 파티셔닝)
- 동적 파티셔닝
    - 파티션 크기가 설정된 값을 넘어서면 두개로 쪼갬
    - 파티션 크기가 임곗값 아래로 떨어지면 인접한 파티션과 합침 (like B트리)
- **사전 분할(pre-splitting)**
    - 빈 데이터베이스의 초기 파티션 집합 설정
- 장단점
    - 장점 : 전체 데이터양에 맞게 조정되는 적절한 파티션 수 (오버헤드 ↓)
    - 단점 : 시작 시에는 파티션이 하나 (사전정보 x)
- 사용 예
    - HBase, RethinkDB (키 범위), MongoDB (>2.4, 키 범위 & 해시)

### 노드 비례 파티셔닝

- 노드당 할당되는 파티션 개수를 고정
    - 노드 대수가 동일하면 (= 파티션 개수 고정)
    - 노드 대수가 증가하면 => 파티션 크기 ↓ (절반은 두고 절반은 새 노드에 할당)
- 장단점
    - 장점 : 개별 파티션 크기가 안정적
    - 단점 : 신규 노드 추가로 인한 파티션 분할 시 무작위 분할 => 균등하지 않은 분할 가능성
        - 무작위 분할 => 해시 기반 파티셔닝 사용 (=일관성 해싱)

# 운영: 자동 재균형화와 수동 재균형화

- 재균형화는 자동으로해야할까 수동으로해야할까?
    - 완전 자동 재균형화 vs 완전 수동 재균형화
    - 그 중간 어디쯤.. => 시스템이 자동으로 파티션 할당을 제안하고 + 관리자가 확정해야 반영되는
- 자동 재균형화
    - 편리하지만, 예측이 어렵고 성능 저하 이슈나 연쇄 장애 가능성
- 수동 재균형화
    - 느리지만 예상치 못한 이슈 방지 가능

# 요청 라우팅

“Service Discovery”
![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/139bcd20-8ab7-4648-966a-964c5d7d51cb)

- Service Discovery 접근법 (라우팅 방법) 3가지
    1. 클라이언트는 아무 노드나 읽어서 어느 노드에 있는지 찾아서 요청
    2. 라우팅 계층은 모든 요청을 라우팅 계층으로 보내서 전달. 파티션 인지 로드밸런서(Partition-aware LB) 
    3. Client가 파티셔닝 방법 및 할당 위치를 알고 직접 해당 노드에 요청
- 파티션의 변경 사항을 어떻게 알것인가
![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/13680fd7-c226-43cc-938a-6317ca7193c2)

- **파티션의 변경 사항을 어떻게 알것인가**
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/42cbe704-281a-45d0-9033-fbddd5f484df/4d048b01-bcf2-438e-b581-9c0131844c9c/Untitled.png)
    
    - 외부의 별도 코디네이션 (ex. Zookeeper) 사용 : 변경사항에 대해 모든걸 관리하고 알려줌
    - 가십 프로토콜 (gossip protocol): 클러스터 상태 변화를 노드 사이에 퍼뜨림. 노드 복잡도 ↑ 외부의존도 ↓

## 병렬 질의 실행

- 더 복잡한 종류의 질의 (분석용)
    - => 대규모 병렬 처리 (MPP, Massively Parallel Processing) 관계형 DB
- MPP 질의 최적화기가 복잡한 질의를 분해하여 서로 다른 노드에서 병렬적 실행 가능하게함
    - 웨어하우스 질의 (join, filter, grouping, aggregation)
- 데이터 웨어하우스 질의 고속 병렬 실행
