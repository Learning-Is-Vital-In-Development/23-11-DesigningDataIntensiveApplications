# 06 파티셔닝

- 데이터셋이 매우 크거나 처리량이 매우 높다면 복제뿐만이 아니라 데이터를 파티션으로 쪼갤 필요가 있다. 이를 샤딩이라고 한다.
    - 용어혼동
        - 몽고DB, 엘라스틱서치, 솔라클라우드 - 샤드(shard)
        - HBase - 리전(region)
        - 빅테이블 - 태블릿(tablet)
        - 카산드라, 리악 - 브이노드(vnode)
        - 카우치베이스 - 브이버켓(vBucket)
- 파티션을 나눌 때는 보통 데이터 단위(레코드, 로우, 문서)가 하나의 파티션에 속하게 된다.
    - 각 파티션은 그 자체로 작은 데이터베이스가 된다.
- 파니셔닝의 주된 이유는 **확장성**이다. 비공유 클러스터(shared-nothing cluster)에서 다른 파티션은 다른 노드에 저장될 수 있다(비공유(shared nothing)는 2부에서..)
    - 여러 디스크에 분산되고 질의 부하를 여러 프로세스에서 분산시킬 수 있다.

# 파티셔닝과 복제

- 보통 복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장한다. 각 레코드는 한 파티션에 속하더라도 다른 노드에 저장해서 내결함성을 보장할 수 있다.
- 한 노드에 여러 파티션을 저장할 수 있다.
- 각 파티션의 리더는 하나의 노드에 할당되고 팔로워들은 다른 노드에 할당된다. 각 노드는 어떤 파티션에게는 리더이면서 다른 파티션에게는 팔로워가 될 수 있다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/fd21bc77-795c-4933-9eca-4ececca5161c)
각 노드는 어떤 파티션에게는 리더로 어떤 파티션에게는 팔로워로 동작한다.

# 키-값 데이터 파티셔닝

- 파티셔닝의 목적: 데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것
    - 모든 노드가 동일한 분량을 담당한다고 가정할 때 10대의 노드를 사용하면 한 대를 사용할 때보다 이론상으로 10배의 데이터를 저장, 질의를 처리 가능
- 하지만 파티셔닝이 고르게 이뤄지지 않으면 **쏠렸다(skewed)**라고 한다. 극단적인 경우 모든 부하가 한 파티션에 몰릴 수 있는데 병목이 될 수 있다. 이렇게 불균형하게 부하가 높은 파티션을 **핫스팟**이라고 한다.
- 핫스팟을 회피하는 방법
    - 가장 단순한 방법은 무작위다. 하지만 이는 어떤 레코드를 읽으려고 할 때 어느 노드에 저장됐는지 알 수 없어서 모든 노드에 병렬적으로 질의해야 한다.
    - 키-값 데이터 모델은 기본키를 통해 레코드를 접근하기 때문에 이를 정렬하면 빠르게 찾을 수 있다.

## 키 범위 기준 파티셔닝

파티션하는 방법

- 각 파티션에 연속된 범위(어떤 최솟값에서 최대값까지)의 키를 할당하는 것
    - 각 범위들 사이의 경계를 알면 어떤 키가 어느 파티션에 속하는지 쉽게 찾을 수 있다.
    - 어떤 파티션이 어떤 노드에 할당됐는지 알면 적절한 노드로 요청을 직접 보낼 수 있다.
- 키 범위는 동일할 필요가 없다. 데이터가 고르게 분포될 필요가 없기 때문이다.
    - ex)
- 데이터를 고르게 분산시키려면 파티션 경계를 데이터에 맞춰 조정해야 한다.
    - 개발자가 수동으로 선택하거나 DB가 자동으로 선택하게 할 수 있다.
    - 빅테이블, HBase, 리싱크DB, 몽고DB 버전 2.4 이전
- 각 파티션 내에서는 키를 정렬된 순서로 저장 가능. 범위 스캔이 쉬워지며 키를 연쇄된 색인으로 간주해서 질의 하나로 관련 레코드 여러개를 읽어오는데 사용 가능
    - 타임스탬프를 키로 사용할 경우 범위 스캔이 유용하다.
- 키 범위 기준 파티셔닝은 특정 접근 패턴이 핫스팟을 유발하기도 한다.
    - 쓰기 연산이 배치처럼 한 번에 동작할 때. 데이터가 몰리는 경우가 있다.
    - 키의 요소로 타임스탬프가 아닌거를 사용하면 된다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/f08963c2-8f43-4c65-8970-9af1eb92e3a1)

## 키의 해시값 기준 파티셔닝

- 쏠림과 핫스팟의 위험을 해결하기 위해 키의 파티션을 정하는 데 해시 함수를 쓴다.
- 좋은 해시 함수는 쏠린 데이터를 균일하게 분산되게 한다.
    - 파티셔닝 해시함수는 암호적으로 강력할 필요가 없다.
        - 카산드라, 몽고 DB - MD5
        - 볼드모트 - 파울러 놀 보(Folwer-Noll-Vo) 함수 사용
    - 하지만 다른 프로세스에서 다른 해시값을 반환하는 가능성은 제한해야한다.
- 키에 적합한 해시함수를 구하면 각 파티션에 해시값 범위를 할당하고 해시값이 파티션의 범위에 속하는 모든 키를 파티션에 할당하면 된다.


![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/bdd5bc61-c5a6-42f2-9dff-48cc443ed6ee)

- 키를 파티션 사이에 균일하게 분산하는 게 좋다.
- 파티션 경계는 크기가 동일하도록 나눌 수 있고 무작위에 가깝게 선택할 수 있다.
    
    **일관성 해싱**
    
    > 카저(Karger)가 정의한 대로 CDN(content delivery network) 같은 인터넷 규모의 캐시 시스템에서 부하를 균등하게 분산시키는 방법. 중앙 제어나 분산 합의(ditributed consensus)가 필요하지 않도록 파티션 경계를 무작위로 선택한다. 다만 복제 일관성이나 ACID 일관성과는 관련이 없으며 특별한 재균형화 방법을 의미한다. 혼동하기 쉬우므로 그냥 **해시 파티셔닝**을 쓰는 게 좋다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/cdca12dc-d85b-4b92-b776-06c4576742a7)

- 하지만 해시값을 사용하면 키 범위 파티셔닝의 장점인 범위 질의를 효율적으로 실행할 수 없다.
- 전에 인접했던 키를 활성화하면 범위 질의가 모든 파티션에 전송돼야 한다. 몽고DB에서 해시 기반 샤딩 모드를 활성화하면 범위 질의가 모든 파티션에 전송되어야 한다. 리악, 카우치베이스, 볼드모트에서는 기본키에 대한 범위 질의가 지원되지 않는다.

## 쏠린 작업부하와 핫프사 완화

- 해싱해서 파티션을 정하면 핫스팟을 줄일 수 있지만 항상 동일한 키를 읽고 쓰는 극단적인 상황에서 모든 요청이 동일한 파티션에 쏠리게 된다.
- 유명인 문제
    - SNS에서 수백만명의 팔로워를 거느린 유명인이 어떤 작업을 하면 후폭풍이 발생할 수 있다. 해당 키에 막대한 양의 데이터를 기록해야 할 수도 있다.
    - 동일한 ID의 해시값은 해싱으로 부하를 해결하지 못한다.
- 현대 데이터 시스템은 크게 쏠린 작업부하를 자동으로 보정하지 못하므로 애플리케이션에서 쏠림을 완화해야 한다.
    - 예를 들어 요청이 많은 키를 발견했을 때 각 키의 시작이나 끝에 임의의 숫자를 붙인다. 그렇다면 한 키에 대한 쓰기 작업이 100개의 다른 키로 균등하게 분산된다.
        - 하짐나 다른 키에 쪼개서 쓰면 읽기를 실행할 때 추가적인 작업이 필요해진다. 키에 해당하는 데이터를 각각 읽어서 조합해야하기 때문이다. 또한 쓰기 오버헤드가 발생할 수도 있다. 따라서 어떤 키가 쪼개졌는지 추적할 방법도 있어야 한다.

# 파티셔닝과 보조 색인

- 앞서 이야기한 내용들은 키-값 데이터 모델 이야기다.
- 인덱스가 들어가면 상황이 복잡해진다. 인덱스는 보통 특정한 값이 발생한 항목을 검색하는 수단이다.
- 인덱스는 RDB의 핵심이며 문서형 데이터베이스에서도 흔하다. 또한 엘라스틱서치나 솔라 같은 검색 서버에는 존재의 이유 그 자체다.

인덱스가 있는 데이터베이스를 파니셔닝하는 방법은 **문서 기반 파티셔닝**과 **용어 기반 파티셔닝**이다.

## 문서 기준 보조 색인 파티셔닝

문서 ID(document ID)라는 고유 ID가 있고 데이터베이스를 문서 ID 기준으로 파티셔닝한다고 했을 때, 인덱스를 만들기 위해서는 데이터베이스가 자동으로 색인을 생성할 수 있어야 한다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/8554f595-674a-4558-a716-fa775d3c40a7)

- 인덱스는 각 파티션이 완전히 독립적으로 동작한다. 각 파티션은 자신의 인덱스만 유지하며 그 파티션에 속하는 문서만 담당한다.
- 데이터베이스에 문서 추가, 삭제, 갱신 등의 쓰기 작업을 실행할 때 쓰려고 하는 문서 ID를 포함하는 파티션만 다루면 된다.
    - 문서 파티셔닝 색인은 전역 색인(global index)와 반대로 지역 색인(local index)라고도 한다.
    - 하지만 파티셔닝 된 데이터베이스의 질의를 할 때는 모든 파티션에 보내야 원하는 결과를 얻을 수 있다.
        - 이 방식을 스캐터/개더(scatter/gather)라고 한다.
        - 꼬리 지연 시간 증폭이 발생할 수 있지만 몽고DB, 리악, 카산드라, 엘라스틱 서치, 솔라클라우드, 볼트DB는 모두 문서 기준으로 파티셔닝된 인덱스를 사용한다.
        - 인덱스 질의가 단일 파티션에서만 실행되도록 파티셔닝 방식을 설계를 원하지만 항상 가능하지가 않다.

## 용어 기준 보조 색인 파티셔닝

- 각 파티션이 자신만의 지역 색인을 갖게 하는 대신 모든 파티션의 데이터를 담당하는 전역 색인을 만들 수도 있다. 한 노드에만 색인을 저장하면 해당 노드가 병목이 되어 파티셔닝의 목적을 해칠 수 있다. 전역 색인도 파티셔닝 해야지만 기본키 색인과는 다른 식으로 할 수 있다.

![image](https://github.com/eastperson/23-11-DesigningDataIntensiveApplications/assets/66561524/e4b3ea51-7cca-43c1-84c0-8da220c52ff6)

- 이미지를 보면 a-r까지 파티션0에 s-z까지는 파티션1에 저장을 한다.
- 찾고자 하는 용어에 따라 색인의 파티션이 결정되므로 이런 식의 색인을 용어 기준으로 파티셔닝됐다(term-partitioned)고 한다. 용어라는 이름은 전문 색인에서 나왔으며 문서에 등장하는 모든 단어를 뜻한다.
- 색인을 파티셔닝할 때 용어 자체를 쓸 수도 있고 용어의 해시값을 사용할 수도 있다. 용어 자체로 파티셔닝하면 범위 스캔에 유용하면 반면 용어의 해시값을 사용해 파티셔닝 하면 부하가 좀 더 고르게 분산된다.
- 문서 파티셔닝 색인에 비해 전역(용어 파티셔닝) 색인이 갖는 이점은 읽기가 효율적이다.
    - 스캐터/개더를 실행할 필요 없이 원하는 용어를 포함하는 파티션으로만 요청을 보내면 된다. 대신 쓰기가 느리고 복잡하다.
        - 단일 문서를 쓸 대 색인의 여러 파티션에 영향을 줄 수 있기 때문이다.
- 실제로 전역 보조 색인은 대개 비동기로 갱신된다.
    - 사용처로는 오라클 데이터 웨어하우스, 리악의 검색 기능 등에서 사용한다.

