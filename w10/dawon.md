# 06장 파티셔닝

`6장의 핵심 내용`

- 저장하고 처리할 데이터가 너무 많아서 장비 한대로 처리하는게 불가능해지면, 데이터를 파티션으로 쪼개는 작업 →  **파티셔닝(샤딩)**
    - **파티셔닝 목적** : 확장성, 핫스팟(불균형적으로 높은 부하를 받는 노드)가 생기지 않게 하면서 데이터와 질의 부하를 여러 장비에 균일하게 분배
- 파티셔닝 기법 2가지 : 키 범위 파티셔닝, 해시 파티셔닝
- 보조 색인 파티셔닝 2가지 : 문서 파티셔닝 색인, 용어 파티셔닝 색인

---

## 들어가기에 앞서

5장에서 동일한 데이터의 복사본 여러 개를 다른 노드에 저장하는 개념인 복제를 다뤘다. 

데이터셋이 매우 크거나 질의 처리량이 매우 높다면 복제만으로는 부족하고 데이터를 파티션으로 쪼갤 필요가 있다. 이작업을 샤딩이라한다. 

> *파티션 
샤드(shard): 몽고DB, 엘라스틱 서치, 솔라클라우드
리전(region) :HBase
태블릿(tablet) : 빅데이블
브이노드(vnode) : 카산드라, 리악
브이버켓(vBucket) : 카우치베이스
> 

**왜 데이터 파티셔닝을 하는가?** 주된 이유는 **확장성**이다. **비공유 클러스터(shared-nothing cluster)**에서 다른 파티션은 다른 노드에 저장될 수 있기에 대용량 데이터셋이 여러 디스크에 분산될 수 있고 질의 부하는 여러 프로세서에 분산될 수 있다. 크고 복잡한 질의는 어렵지만 여러 노드에서 병렬 실행도 가능하다.

**파티셔닝 지원 데이터베이스**

파티셔닝 지원 데이터베이스는 과거 다음 제품들에서 개척되었다.

- 테라데이터(Teradata)
- 탠텀 논스톱 SQL(Tandem NonSteop SQL)

그리고 최근에는 NoSQL , 하둡 기반 데이터 웨어하우스에서 재발견되었다.

어떤 시스템들은 트랜잭션 작업 부하용, 어떤 시스템들은 분석용으로 설계되었지만, 파티셔닝의 기본 원칙은 두 종류의 작업부하에 모두 적용된다.

이번 포스팅에서는 아래와 같은 내용을 살펴볼 것이다. 

- 대용량 데이터셋을 **파티셔닝** 하는 몇 가지 방법
- 데이터 색인과 파티셔닝의 **상호작용** 방식
- **재균형화**(rebalancing)
- 요청 **라우팅**

# 0. 파티셔닝과 복제

보통 복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장한다.

각 레코드는 정확히 한 파티션에 속하더라도 이를 여러 다른 노드에 저장해서 내결함성을 보장할 수 있다.

리더 팔로워 복제 모델을 사용한다면 파티셔닝과 복제의 조합은 아래 그림과 같은 형태가 된다. 
각 파티션의 리더는 하나의 노드에 할당되고 팔로워들은 다른 노드에 할당된다. 각 노드는 어떤 파티션에게는 리더이면서 다른 파티션에게는 팔로워가 될 수 있다. 

![복제와 파티셔닝의 조합 : 각 노드는 어떤 파티션에게는 리더로 어떤 파티션에게는 팔로워로 동작한다.](https://prod-files-secure.s3.us-west-2.amazonaws.com/fe5d7f0e-3b33-4513-9b73-373a7fef9157/16496aaa-c466-43bd-90b8-3a21d2b4d7d2/Untitled.png)

복제와 파티셔닝의 조합 : 각 노드는 어떤 파티션에게는 리더로 어떤 파티션에게는 팔로워로 동작한다.

# 1. ****key-value 데이터 파티셔닝****

**대량의 데이터를 파티셔닝한다고 할 때 어떤 레코드를 어떤 노드에 저장할 지 어떻게 결정해야 할까?** 
→ ***파티셔닝의 목적은 데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것이다.***

파티셔닝이 고르게 이뤄지지 않아 다른 파티션보다 데이터가 많거나 질의를 많이 받는 파티션이 있다면 **`쏠렸다(skewed)`**고 말한다. 

N개의 노드로 파티셔닝을 한다고 할지라도 그 중 하나의 노드가 모든 요청을 처리하게 되면, 파티셔닝의 의미가 없을 수 있다.

이와 같이 불균형하게 부하가 높은 파티션을 **`핫스팟`**이라고 한다.

### 레코드를 어떻게 할당하는 것이 좋을까? (핫스팟 회피)

- 랜덤 파티셔닝 (레코드 할당할 노드 무작위 선정)
    - 장점) 데이터가 노드들 사이에 매우 고르게 분산된다.
    - 단점) 어떤 레코드를 읽으려고 할 때 해당 레코드가 어느 노드에 저장되어있는지 알 수 없으므로 노드에서 병렬적으로 질의 실행해야한다.
- **(추천)** 키-값 데이터 모델 사용
    - 항상 기본키를 통해 레코드에 접근한다. 모든 항목이 제목의 알파벳 순으로 정렬돼 있기에 언제나 찾고자 하는 항목을 빨리 찾을 수 있다.

노드에 병렬적으로 질의를 하는 랜덤 파티셔닝 방법은 비효율적이므로 키-값 데이터 모델을 사용하는 방법에 대해 더 자세히 알아보겠다.

### 키 범위 기준 파티셔닝

- **키 범위 기준 파티셔닝** : 각 파티션에 연속된 범위의 키를 할당하는 식으로 파티셔닝을 한다.
    - 각 범위들 사이의 경계를 알면 어떤 키가 어느 파티션에 속하는지 찾기 쉽다.
    - 특정 파티션이 어떤 노드에 할당됐는지 알면 적절한 노드로 요청을 직접 보낼 수 있다.
    - 데이터 분포가 균일하지 않을수 있기 떄문에 키 범위 크기가 반드시 동일할 필요는 없다.
    - 파티션 경계는 관리자가 수동으로 선택하거나 DB에서 자동으로 선택되게 할 수 있다.

각 파티션 내에서는 키를 정렬된 순서로 저장할 수 있어 범위 스캔이 유용하지만, 타임스탬프가 키라면 **`핫스팟`**을 유발할 수 있다.

이런 문제를 회피하기 위해서는 키의 첫 번째 요소로 타임스탬프 말고 다른걸 사용해야 한다. 
→ 타임스템프 앞에 센서 이름을 붙여서 파티셔닝 할 때 센서이름을 먼저 사용한 후 시간을 사용할 수 있게 한다. 이렇게되면 하나의 시간 범위내에 여러 센서의 값을 얻고 싶다면 센서 이름마다 별개의 범위 질의를 실행하면된다. 실제로 IoT 분야에서 비슷한 방법으로 데이터를 운용하곤 한다.

### 키의 해시값 기준 파티셔닝

- **키 해시값 기준 파티셔닝** : 해시 함수를 통해 쏠림, 핫스팟을 방지할 수 있지만, 범위 질의를 효율적으로 실행할 수 없다.
    - 인접한 키들이 모든 파티션에 흩어져 정렬 순서가 유지되지 않기 때문

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/fe5d7f0e-3b33-4513-9b73-373a7fef9157/68bc81e9-4957-4368-afef-e2ab6b4a257f/Untitled.png)

이러한 해시 함수를 사용해서 해시값 범위를 할당하고, 해시값이 파티션의 범위에 속하는 모든 키를 그 파티션에 할당하면 다음과 같은 모습이 나온다.

이 기법은 키를 파티션 사이에 균일하게 분산시키는데 좋다.

파티션 경계는 크기가 동일하도록 나눌 수도 있고 무작위에 가깝게 선택할 수도 있다.

이런 기법을 **`일관성 해싱`**이라 부르기도 한다.

> 
> 
> 
> ****DB별 전략****
> 
> - **몽고 DB** : 해시 기반 샤딩 모드를 활성화하면 범위 질의가 모든 파티션에 전송돼야 한다.
> - **리악, 카우치베이스, 볼드모트** : 기본키에 대한 범위 질의가 지원되지 않는다.
> - **카산드라**
>     - 테이블 선언시 여러 칼럼을 포함하는 **복합 기본키**를 지정할 수 있다.
>     - 키의 첫 부분에만 해싱을 적용해 파티션 결정에 사용한다.
>     - 남은 칼럼은 SS테이블에서 데이터를 정렬하는연쇄된 색인으로 사용한다.

### 쏠린 작업 부하와 핫스팟 완화

앞에서 설명한 대로 키를 해싱해서 파티션을 정하면 핫스팟을 줄이는데 도움이된다.하지만 핫스팟을 완벽히 제거하는것을 불가능하다. 

**동일한 키에 편중되는 작업**

해시 함수를 이용해 핫스팟을 줄이려 시도를 하지만, 클라이언트가 항상 동일한 키를 읽고 쓰는 경우에는 하나의 파티션으로 모든 요청이 쏠리게 된다.

트위터나 인스타그램에서 수백만의 팔로워를 가지고 있는 유명인사들이 새로운 글을 올린다면, 우리가 우려한 동일한 키에서 막대한 양의 작업이 수행될 수 있다.  모두 동일한 ID의 해시값을 사용하기에 해싱도 도움이 되지 않는다.

**쏠린 작업부하 완화책**

현대 데이터 시스템은 대부분 크게 쏠린 작업부하를 자동으로 보정하지 못하므로 애플리케이션에서 쏠림을 완화해야한다. 

- 임의의 10진수 두개만 붙이더라도 한키에 대한 쓰기 작업이 **100개의 다른 키로 균등하게 분산**되고 그 키들은 다른 파티션으로 분산될 수 있다.

각 키의 시작이나 끝에 임의의 숫자를 붙여서 해결할 수 있으나, 다른키에 쪼개서 쓰면 읽기를 실행할 떄 추가작업(**100개의 키에 해당하는 데이터를 읽어서 조합**)이 필요해지므로 요청이 몰리는 소수의 키에만 적용하는게 적절하다. 쓰기 처리량이 낮은 대다수 키에 적용하면 불필요한 오버헤드가 생긴다.

미래에는 데이터 시스템이 쏠린 작업부하를 자동으로 감지해서 보정할 수 있겠지만 아직은 애플리케이션에 대한 트레이드오프를 꼼꼼히 따져볼 필요가 있다.

# 2.  ****파티셔닝과 보조 색인****

보조 색인이 연관되면 기존의 키-값 데이터 모델을 이용한 파티셔닝 방식으로는 구현 복잡도가 많이 높아진다. 또한, 보조 색인은 파티션에 깔끔하게 대응되지 않는 문제점도 있다.

그렇기에 HBase나 볼드모트같은 DB에서는 보조색인을 지원하지 않는다.

따라서 보조 색인은 보통 레코드를 유일하게 식별하는 용도가 아니라 특정한 값이 발생한 항목을 검색하는 수단이다.

사용자 123이 실행한 액션을 모두 찾거나 hogwash라는 단어를 포함하는 글을 모두 찾거나 빨간색 자동차를 모두 찾는 등의 작업에 쓰인다. 

→ RDB의 핵심 요소이고 문서 데이터베이스에서도 흔하고 데이터 모델링에 매우 유용하다.

**보조 색인을 지원하는 DB에서는 어떻게 파티셔닝을 해야 할까?**

- **문서 기준(`지역 색인(local index)`) :** Document ID 기준(위 그림의 191, 214 .. )으로 파티셔닝 하고, scatter/gather 형식으로 질의. 쓰기가 효율적.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/fe5d7f0e-3b33-4513-9b73-373a7fef9157/71e6a7b1-29a1-41ea-a575-a88b93c9e108/Untitled.png)
    
    - 각 파티션은 완전히 독립적으로 동작한다.
        - 자신의 보조 색인을 만들고, 유지하며 해당 파티션에 속하는 문서만 담당한다.
        - 다른 파티션이 어떤 데이터를 가지고 있는지에 대해 알지 못한다.
    - 빨간색 자동차는 파티션 0, 파티션 1 둘 다 존재한다. 빨간색 자동차를 모두 찾기 위해서는 모든 파티션에 질의를 보내 결과를 집계해야한다.
        - 파티셔닝된 DB에 이런 식으로 질의를 보내는 방법을 **스캐터/개더(scatter/gather)**라 한다.
    
- **용어 기준 :** 모든 파티션의 데이터를 담당하는 전역 색인이 파티셔닝 되어 있음. 읽기가 효율적, 원하는 용어 포함 파티션으로만 요청을 보내면 됨.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/fe5d7f0e-3b33-4513-9b73-373a7fef9157/0a1320bb-5f77-4043-b5cb-41089bd7428c/Untitled.png)
    
    - 보조색인이 자기 파티션 뿐 아니라 모든 파티션의 데이터를 담당, **`전역성(global index)`**을 가지도록 만들 수 있다.
    - 위 그림에서 자동차 색상을 알파벳으로 정렬한 다음 a부터 r까지는 파티션 0 s부터 z까지는 파티션 1에 저장되도록 파티셔닝 한다
    - 이처럼 용어에 따라 색인의 파티션이 결정되는 색인을 **파티셔닝 됐다(term-partitioned)**고 한다.
    - 전역 보조 색인은 대게 비동기로 갱신된다. → 쓰기 실행한 후 바로 색인을 읽으면 변경 사항이 색인에 반영되지 않았을수도 있음
        - 예) 아마존 다이나모DB는 정상적인 상황에서는 전역 보조 색인을 갱신하는데 1초도 안걸리지만 인프라에 결함이 생기면 반영 지연시간이 더 길어질 수 있다.
    - 단점)
        - 느리고 복잡하다. → 단일 문서를 쓸 때 해당 색인의 여러 파티션에 영향을 줄 수 있기 떄문에
        - 쓰기에 영향받는 모든 파티션에 걸친 트랜잭션을 실행해야하는데 모든 DB가 분산 트랜잭션을 지원하지는 않음

# 3.  파티션 재균형화

시간이 지나면 DB에 아래와 같이 변화가 생긴다.

> 질의 처리량이 증가해 늘어난 부하를 처리하기 위해 CPU 추가가 필요할 때
데이터 셋 크기 증가로 저장에 사용할 Disk, Ram 추가가 필요할 때
장비에 장애가 발생해서 다른 장비가 그 역할을 받아야 할 때
> 

클러스터에서 한 노드가 담당하던 부하를 다른 노드로 옮기는 과정을 **`rebalancing`**이라고 한다.

### **재균형화 전략**

**⚠️쓰면 안되는 방법⚠️**

- 해시값에 모드 N 연산을 실행  : 대부분의 키가 노드를 옮겨야 할 수 있다. 비용이 지나치게 크다.

👍가능한 **방법** 👍

- 파티션 개수 고정 : 처음부터 파티션을 더 많이 만든다. 새 노드가 추가되면 파티션이 분배될 때까지 기존 노드에서 파티션을 뻇어온다. 파티션은 노드 사이에서 통째로 이동하기만 하면 된다. 단, 변동이 심해 수를 정하기 어려운 환경이라면 해당 방법을 채택하기 어렵다.
- 동적 파티셔닝 : 파티션 크기가 설정 값을 넘으면 파티션을 두 개로 쪼개 각각에 원래 파티션의 절반 정도의 데이터가 포함되게 한다. 반대로 합쳐질 수도 있다. 빈 데이터베이스는 파티션 경계를 어디로 정해야 하는지 사전 정보가 없으므로, 시작할 때는 파티션이 하나라는 함정이 있다. 따라서 pre-splitting을 지원하기도 한다.
- 노드 비례 파티셔닝 : 노드당 할당하는 파티션 개수를 고정한다. 새 노드가 추가되면 고정 개수의 파티션을 무작위 선택해 분할하고 각 분할된 파티션의 절반은 그대로 두고 절반은 새 노드에 할당한다.

### **운영 : 자동 재균형화와 수동 재균형화**

재균형화는 자동으로 실행될까, 수동으로 실행될까? 적절히 조합해보는 반자동 재균형화 방법도 있다.

**자동 재균형화**

- 관리자의 개입 없이 시스템이 자동으로 언제 파티션을 노드 사이에 이동할지를 결정한다.
- 일상적인 유지보수에 손이 덜가기에 편리하다.
- **언제 재균형화가 될지 예측하기 어렵다.**
- 재균형화는 비용이 큰 연산인데, 자동 장애 감지와 조합될 경우 불필요한 상황에서 재균형화를 시도하며 연쇄장애가 발생할 수 있다.

**수동 재균형화**

- 관리자가 명시적으로 파티션을 노드에 할당하도록 설정하고 관리자가 재설정할 때만 파티션 할당이 변경된다.

**반자동 재균형화**

완전히 수동으로 하기에는 인적 부담이 크고, 완전히 자동으로 하기에는 재균형화의 시점을 파악하기 힘들고, 불필요한 재균형화로 비용이 낭비될 수 있다.

그렇기에 **자동으로 파티션 할당은 제안하지만, 반영은 관리자가 확정해야 하도록 하는 반자동 재균형화가 있다.**

→ 예) 카우치베이스, 리악, 볼드모트

# 4.  요청 라우팅

클라이언트에서 요청을 보내려고 할 때 어느 노드로 접속해야 하는지 어떻게 알 수 있을까?

**"foo 키를 읽거나 쓰려면 어떤 IP 주소와 포트 번호로 접속해야 할까?"**

이 문제는 DB에 국한되지 않은 **Service Discovery**의 일종이다.

- 클라이언트가 Round-Robin LB를 통해 접속하게 한다.
- 모든 요청을 라우팅 계층으로 먼저 보내고, 라우팅 계층에서는 노드를 알아내 요청을 전달한다.
- 클라이언트가 파티셔닝 방법과 파티션이 어떤 노드에 할당됐는지를 알고 있게 한다.
    - 이 경우 클라이언트는 중개자 없이 올바른 노드로 직접 바로 접속할 수 있다.

### 병렬질의  (10장 참고)

지금까지는 단일 키를 쓰거나 읽는 매우 간단한 질의(문서 파티셔닝 보조색인을 쓰는 경우는 스캐터/개더가 추가됨)에 대해서만 설명했다. 이는 대부분 NoSQL 분산 데이터스토어에서 지원되는 접근 수준이다. 

그러나 분석용으로 자주사용되는 대규모 병렬 처리(massively parallel processing, **MPP**)는 훨씬 복잡한 질의를 지원한다. MPP Query Optimizer는 복잡한 질의를 여러 실행 단계와 파티션으로 분해하며 이들 중 다수는 데이터베이스 클러스터 내의 서로 다른 노드에서 병렬적으로 실행될 수 있다.
